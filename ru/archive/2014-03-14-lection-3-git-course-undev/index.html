<!doctype html><html lang=ru dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>Git. Просто Git. Лекция 3. Инструменты Git. &#183; Андрей Куманяев</title><meta name=title content="Git. Просто Git. Лекция 3. Инструменты Git. &#183; Андрей Куманяев"><script type=text/javascript src=https://zzet.org/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=https://zzet.org/css/main.bundle.min.100caa677b4bc416cdd884107b203b4869f9b413a19aa57d12069fb826f1abe9.css integrity="sha256-EAyqZ3tLxBbN2IQQeyA7SGn5tBOhmqV9EgafuCbxq+k="><meta name=description content="
      
        
      
    "><meta name=robots content="all"><link rel=canonical href=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/"><meta property="og:site_name" content="Андрей Куманяев"><meta property="og:title" content="Git. Просто Git. Лекция 3. Инструменты Git."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2014-02-09T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git. Просто Git. Лекция 3. Инструменты Git."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"","name":"Git. Просто Git. Лекция 3. Инструменты Git.","headline":"Git. Просто Git. Лекция 3. Инструменты Git.","inLanguage":"ru","url":"https:\/\/zzet.org\/ru\/archive\/2014-03-14-lection-3-git-course-undev\/","author":{"@type":"Person","name":"Андрей Куманяев"},"copyrightYear":"2014","dateCreated":"2014-02-09T00:00:00\u002b00:00","datePublished":"2014-02-09T00:00:00\u002b00:00","dateModified":"2014-02-09T00:00:00\u002b00:00","mainEntityOfPage":"true","wordCount":"20127"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zzet.org/ru/","name":"Андрей Куманяев","position":1},{"@type":"ListItem","item":"https://zzet.org/ru/archive/","name":"","position":2},{"@type":"ListItem","name":"Git. Просто Git. Лекция 3. Инструменты Git.","position":3}]}</script><meta name=author content="Андрей Куманяев"><link href=https://twitter.com/username rel=me><link href=https://github.com/zzet rel=me><link href=https://x.com/zzetorg rel=me><link href=https://www.reddit.com/user/zzet/ rel=me><link href=https://www.linkedin.com/in/andrey-kumanyaev/ rel=me><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGXR3BQCTQ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VGXR3BQCTQ")}</script></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Перейти к содержанию</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/ru/>Андрей Куманяев</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/about/ title="Обо мне"><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Обо мне</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Блог</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://github.com/zzet title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://x.com/zzetorg title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/>Андрей Куманяев</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/>archive</a><span class="px-1 text-primary-500">/</span></li><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/>Git. Просто Git. Лекция 3. Инструменты Git.</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Git. Просто Git. Лекция 3. Инструменты Git.</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time><span class="px-2 text-primary-500">&#183;</span><span title="Время чтения">95 минут</span><span class="px-2 text-primary-500">&#183;</span>
<span class=mb-[2px]><a href=https://github.com/zzet.github.com/content/archive/2014-03-14-lection-3-git-course-undev.ru.md class="text-lg hover:text-primary-500" rel="noopener noreferrer" target=_blank title=Редактировать><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M490.3 40.4c21.9 21.87 21.9 57.33.0 79.2l-30 30.1-98-97.98 30.1-30.06C414.3-.2135 449.7-.2135 471.6 21.66L490.3 40.4zM172.4 241.7 339.7 74.34l98 97.96L270.3 339.6C264.2 345.8 256.7 350.4 248.4 353.2l-88.8 29.6C150.1 385.6 141.5 383.4 135 376.1 128.6 370.5 126.4 361 129.2 352.4l29.6-88.8C161.6 255.3 166.2 247.8 172.4 241.7v0zM192 63.1c17.7.0 32 15.23 32 32 0 18.6-14.3 32-32 32H96c-17.67.0-32 15.2-32 32V416c0 17.7 14.33 32 32 32H352c17.7.0 32-14.3 32-32V319.1c0-16.8 14.3-32 32-32s32 15.2 32 32V416c0 53-43 96-96 96H96c-53.02.0-96-43-96-96V159.1c0-53 42.98-96 96-96h96z"/></svg></span></a></span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><h1 id=инструменты-git class="relative group">Инструменты Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b-git aria-label=Якорь>#</a></span></h1><p>К этому времени вы уже изучили большинство повседневных команд и способы организации рабочего процесса, необходимые для того, чтобы поддерживать Git-репозиторий для контроля вашего исходного кода. Вы выполнили основные задания, связанные с добавлением файлов под версионный контроль и записью сделанных изменений, и вы вооружились мощью подготовительной области (staging area), легковесного ветвления и слияния.</p><p>Сейчас вы познакомитесь с множеством весьма сильных возможностей Git&rsquo;а. Вы совсем не обязательно будете использовать их каждый день, но, возможно, в какой-то момент они вам понадобятся.</p><h2 id=выбор-ревизии class="relative group">Выбор ревизии <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d1%8b%d0%b1%d0%be%d1%80-%d1%80%d0%b5%d0%b2%d0%b8%d0%b7%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h2><p>Git позволяет указывать конкретные коммиты или их последовательности несколькими способами. Они не всегда очевидны, но иногда их полезно знать.</p><h3 id=одиночные-ревизии class="relative group">Одиночные ревизии <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%bd%d1%8b%d0%b5-%d1%80%d0%b5%d0%b2%d0%b8%d0%b7%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h3><p>Вы можете просто сослаться на коммит по его SHA-1 хешу, но также существуют более понятные для человека способы ссылаться на коммиты. В этом разделе кратко описаны различные способы обратиться к одному определённому коммиту.</p><h3 id=сокращённый-sha class="relative group">Сокращённый SHA <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%be%d0%ba%d1%80%d0%b0%d1%89%d1%91%d0%bd%d0%bd%d1%8b%d0%b9-sha aria-label=Якорь>#</a></span></h3><p>Git достаточно умён для того, чтобы понять какой коммит вы имеете в виду по первым нескольким символам (частичному хешу), конечно, если их не меньше четырёх и они однозначны, то есть если хеш только одного объекта в вашем репозитории начинается с этих символов.</p><p>Предположим, что вы хотите посмотреть содержимое какого-то конкретного коммита. Вы выполняете команду <code>git log</code> и находите этот коммит (например, тот, в котором вы добавили какую-то функциональность):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log
</span></span><span style=display:flex><span>commit 734713bc047d87bf7eac9674765ae793478c50d3
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri Jan <span style=color:#ae81ff>2</span> 18:32:33 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fixed refs handling, added gc auto, updated tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
</span></span><span style=display:flex><span>Merge: 1c002dd... 35cfb2b...
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Dec <span style=color:#ae81ff>11</span> 15:08:43 <span style=color:#ae81ff>2008</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge commit <span style=color:#e6db74>&#39;phedders/rdocs&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Dec <span style=color:#ae81ff>11</span> 14:58:32 <span style=color:#ae81ff>2008</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    added some blame and merge stuff
</span></span></code></pre></div><p>В нашем случае выберем коммит <code>1c002dd....</code>. При использовании <code>git show</code> для просмотра содержимого этого коммита следующие команды эквивалентны (предполагая, что сокращённые версии однозначны):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
</span></span><span style=display:flex><span>$ git show 1c002dd4b536e7479f
</span></span><span style=display:flex><span>$ git show 1c002d
</span></span></code></pre></div><p>Git может показать короткие уникальные сокращения ваших SHA-1 хешей. Если вы передадите опцию <code>--abbrev-commit</code> команде <code>git log</code>, то её вывод будет использовать сокращённые значения, сохраняя их уникальными; по умолчанию будут использоваться семь символов, но при необходимости длина будет увеличена для сохранения однозначности хешей:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --abbrev-commit --pretty<span style=color:#f92672>=</span>oneline
</span></span><span style=display:flex><span>ca82a6d changed the version number
</span></span><span style=display:flex><span>085bb3b removed unnecessary test code
</span></span><span style=display:flex><span>a11bef0 first commit
</span></span></code></pre></div><p>В общем случае восемь-десять символов более чем достаточно для уникальности внутри проекта. В одном из самых больших проектов, использующих Git, ядре Linux только начинает появляться необходимость использовать 12 символов из 40 возможных для сохранения уникальности.</p><h3 id=небольшое-замечание-о-sha-1 class="relative group">Небольшое замечание о SHA-1 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bd%d0%b5%d0%b1%d0%be%d0%bb%d1%8c%d1%88%d0%be%d0%b5-%d0%b7%d0%b0%d0%bc%d0%b5%d1%87%d0%b0%d0%bd%d0%b8%d0%b5-%d0%be-sha-1 aria-label=Якорь>#</a></span></h3><p>Многие люди интересуются, что произойдёт, если они в какой-то момент, по некоторой случайности, получат два объекта в репозитории, которые будут иметь два одинаковых значения SHA-1 хеша. Что тогда?</p><p>Если вы вдруг закоммитите объект, SHA-1 хеш которого такой же, как у некоторого предыдущего объекта в вашем репозитории, Git обнаружит предыдущий объект в своей базе данных и посчитает, что он уже был записан. Если вы в какой-то момент попытаетесь получить этот объект опять, вы всегда будете получать данные первого объекта.</p><p>Однако, вы должны осознавать то, как смехотворно маловероятен этот сценарий. Длина SHA-1 составляет 20 байт или 160 бит. Количество случайно хешированных объектов, необходимое для того, чтобы получить 50% вероятность одиночного совпадения составляет порядка 2^80 (формула для определения вероятности совпадения: <code>p = (n(n-1)/2) * (1/2^160))</code>). 2^80 это 1.2 x 10^24 или один миллион миллиарда миллиардов. Это в 1200 раз больше количества песчинок на земле.</p><p>Вот пример для того, чтобы вы поняли, что необходимо, чтобы получить SHA-1 коллизию. Если бы все 6.5 миллиардов людей на Земле программировали и каждую секунду каждый из них производил количество кода, эквивалентное всей истории ядра Linux (1 миллион Git-объектов) и отправлял его в один огромный Git-репозиторий, то потребовалось бы 5 лет для того, чтобы заполнить репозиторий достаточно для того, чтобы получить 50% вероятность единичной SHA-1 коллизии. Более вероятно, что каждый член вашей команды программистов будет атакован и убит волками в несвязанных друг с другом случаях в одну и ту же ночь.</p><h3 id=ссылки-на-ветки class="relative group">Ссылки на ветки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b8-%d0%bd%d0%b0-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Для самого прямого метода указать коммит необходимо, чтобы этот коммит имел ветку, ссылающуюся на него. Тогда вы можете использовать имя ветки в любой команде Git&rsquo;а, которая ожидает коммит или значение SHA-1. Например, если вы хотите посмотреть последний коммит в ветке, следующие команды эквивалентны, предполагая, что ветка <code>topic1</code> ссылается на <code>ca82a6d</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>$ git show topic1
</span></span></code></pre></div><p>Чтобы посмотреть, на какой именно SHA указывает ветка, или понять для какого-то из приведённых примеров, к каким SHA он сводится, можно использовать служебную (plumbing) утилиту Git&rsquo;а, которая называется <code>rev-parse</code>. Более подробно о служебных утилитах будет говориться в лекции 5; в основном <code>rev-parse</code> нужна для выполнения низкоуровневых операций и не предназначена для использования в повседневной работе. Однако, она может пригодиться, если вам необходимо разобраться, что происходит на самом деле. Сейчас вы можете попробовать применить <code>rev-parse</code> к своей ветке.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rev-parse topic1
</span></span><span style=display:flex><span>ca82a6dff817ec66f44342007202690a93763949
</span></span></code></pre></div><h3 id=reflog-сокращения class="relative group">RefLog-сокращения <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#reflog-%d1%81%d0%be%d0%ba%d1%80%d0%b0%d1%89%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Одна из вещей, которую Git делает в фоновом режиме, пока вы работаете, это запоминание ссылочного лога — лога того, где находились HEAD и ветки в течение последних нескольких месяцев.</p><p>Ссылочный лог можно просмотреть с помощью <code>git reflog</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reflog
</span></span><span style=display:flex><span>734713b... HEAD@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>: commit: fixed refs handling, added gc auto, updated
</span></span><span style=display:flex><span>d921970... HEAD@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>: merge phedders/rdocs: Merge made by recursive.
</span></span><span style=display:flex><span>1c002dd... HEAD@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>: commit: added some blame and merge stuff
</span></span><span style=display:flex><span>1c36188... HEAD@<span style=color:#f92672>{</span>3<span style=color:#f92672>}</span>: rebase -i <span style=color:#f92672>(</span>squash<span style=color:#f92672>)</span>: updating HEAD
</span></span><span style=display:flex><span>95df984... HEAD@<span style=color:#f92672>{</span>4<span style=color:#f92672>}</span>: commit: <span style=color:#75715e># This is a combination of two commits.</span>
</span></span><span style=display:flex><span>1c36188... HEAD@<span style=color:#f92672>{</span>5<span style=color:#f92672>}</span>: rebase -i <span style=color:#f92672>(</span>squash<span style=color:#f92672>)</span>: updating HEAD
</span></span><span style=display:flex><span>7e05da5... HEAD@<span style=color:#f92672>{</span>6<span style=color:#f92672>}</span>: rebase -i <span style=color:#f92672>(</span>pick<span style=color:#f92672>)</span>: updating HEAD
</span></span></code></pre></div><p>Каждый раз, когда верхушка ветки обновляется по какой-либо причине, Git сохраняет информацию об этом в эту временную историю. И вы можете использовать и эти данные для задания старых коммитов. Если вы хотите посмотреть, какое значение было у HEAD в вашем репозитории пять шагов назад, используйте ссылку вида <code>@{n}</code> так же, как показано в выводе команды <code>reflog</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show HEAD@<span style=color:#f92672>{</span>5<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Также вы можете использовать эту команду, чтобы увидеть, где ветка была некоторое время назад. Например, чтобы увидеть, где была ветка <code>master</code> вчера, наберите</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show master@<span style=color:#f92672>{</span>yesterday<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Эта команда покажет, где верхушка ветки находилась вчера. Такой подход работает только для данных, которые всё ещё находятся в ссылочном логе. Так что вы не сможете использовать его для коммитов с давностью в несколько месяцев.</p><p>Чтобы просмотреть информацию ссылочного лога в таком же формате, как вывод <code>git log</code>, можно выполнить <code>git log -g</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -g master
</span></span><span style=display:flex><span>commit 734713bc047d87bf7eac9674765ae793478c50d3
</span></span><span style=display:flex><span>Reflog: master@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>Scott Chacon &lt;schacon@gmail.com&gt;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Reflog message: commit: fixed refs handling, added gc auto, updated 
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri Jan <span style=color:#ae81ff>2</span> 18:32:33 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fixed refs handling, added gc auto, updated tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
</span></span><span style=display:flex><span>Reflog: master@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>Scott Chacon &lt;schacon@gmail.com&gt;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Reflog message: merge phedders/rdocs: Merge made by recursive.
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Dec <span style=color:#ae81ff>11</span> 15:08:43 <span style=color:#ae81ff>2008</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge commit <span style=color:#e6db74>&#39;phedders/rdocs&#39;</span>
</span></span></code></pre></div><p>Важно отметить, что информация в ссылочном логе строго локальная — это лог того, чем вы занимались со своим репозиторием. Ссылки не будут теми же самыми в чьей-то чужой копии репозитория; и после того как вы только что склонировали репозиторий, ссылочный лог будет пустым, так как вы ещё ничего не делали со своим репозиторием. Команда <code>git show HEAD@{2.months.ago}</code> сработает, только если вы склонировали свой проект как минимум два месяца назад. Если вы склонировали его пять минут назад, то вы ничего не получите.</p><h3 id=ссылки-на-предков class="relative group">Ссылки на предков <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b8-%d0%bd%d0%b0-%d0%bf%d1%80%d0%b5%d0%b4%d0%ba%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Ещё один основной способ указать коммит — указать коммит через его предков. Если поставить <code>^</code> в конце ссылки, для Git&rsquo;а это будет означать родителя этого коммита.
Допустим, история вашего проекта выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#39;%h %s&#39;</span> --graph
</span></span><span style=display:flex><span>* 734713b fixed refs handling, added gc auto, updated tests
</span></span><span style=display:flex><span>*   d921970 Merge commit <span style=color:#e6db74>&#39;phedders/rdocs&#39;</span>
</span></span><span style=display:flex><span>|<span style=color:#ae81ff>\ </span> 
</span></span><span style=display:flex><span>| * 35cfb2b Some rdoc changes
</span></span><span style=display:flex><span>* | 1c002dd added some blame and merge stuff
</span></span><span style=display:flex><span>|/  
</span></span><span style=display:flex><span>* 1c36188 ignore *.gem
</span></span><span style=display:flex><span>* 9b29157 add open3_detach to gemspec file list
</span></span></code></pre></div><p>В этом случае вы можете посмотреть предыдущий коммит, указав <code>HEAD^</code>, что означает &ldquo;родитель HEAD&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show HEAD^
</span></span><span style=display:flex><span>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
</span></span><span style=display:flex><span>Merge: 1c002dd... 35cfb2b...
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Dec <span style=color:#ae81ff>11</span> 15:08:43 <span style=color:#ae81ff>2008</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge commit <span style=color:#e6db74>&#39;phedders/rdocs&#39;</span>
</span></span></code></pre></div><p>Вы также можете указать некоторое число после <code>^</code>. Например, <code>d921970^2</code> означает &ldquo;второй родитель коммита d921970&rdquo;. Такой синтаксис полезен только для коммитов-слияний, которые имеют больше, чем одного родителя. Первый родитель — это ветка, на которой вы находились во время слияния, а второй — коммит на ветке, которая была слита:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show d921970^
</span></span><span style=display:flex><span>commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Dec <span style=color:#ae81ff>11</span> 14:58:32 <span style=color:#ae81ff>2008</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    added some blame and merge stuff
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git show d921970^2
</span></span><span style=display:flex><span>commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
</span></span><span style=display:flex><span>Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
</span></span><span style=display:flex><span>Date:   Wed Dec <span style=color:#ae81ff>10</span> 22:22:03 <span style=color:#ae81ff>2008</span> +0000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Some rdoc changes
</span></span></code></pre></div><p>Другое основное обозначение для указания на предков — это <code>~</code>. Это тоже ссылка на первого родителя, поэтому <code>HEAD~</code> и <code>HEAD^</code> эквивалентны. Различия становятся очевидными, только когда вы указываете число. <code>HEAD~2</code> означает первого родителя первого родителя HEAD или прародителя — это переход по первым родителям указанное количество раз. Например, для показанной выше истории, <code>HEAD~3</code> будет</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show HEAD~3
</span></span><span style=display:flex><span>commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
</span></span><span style=display:flex><span>Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
</span></span><span style=display:flex><span>Date:   Fri Nov <span style=color:#ae81ff>7</span> 13:47:59 <span style=color:#ae81ff>2008</span> -0500
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ignore *.gem
</span></span></code></pre></div><p>То же самое можно записать как <code>HEAD^^^</code>, что опять же означает первого родителя первого родителя первого родителя:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show HEAD^^^
</span></span><span style=display:flex><span>commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
</span></span><span style=display:flex><span>Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
</span></span><span style=display:flex><span>Date:   Fri Nov <span style=color:#ae81ff>7</span> 13:47:59 <span style=color:#ae81ff>2008</span> -0500
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ignore *.gem
</span></span></code></pre></div><p>Кроме того, можно комбинировать эти обозначения. Например, можно получить второго родителя для предыдущей ссылки (мы предполагаем, что это коммит-слияние) написав <code>HEAD~3^2</code>, ну и так далее.</p><h3 id=диапазон-коммитов class="relative group">Диапазон коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%b8%d0%b0%d0%bf%d0%b0%d0%b7%d0%be%d0%bd-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Теперь, когда вы умеете задавать отдельные коммиты, разберёмся, как указать диапазон коммитов. Это особенно полезно при управлении ветками — если у вас много веток, вы можете использовать обозначения диапазонов, чтобы ответить на вопросы типа &ldquo;Какие в этой ветке есть коммиты, которые не были слиты в основную ветку?&rdquo;</p><h4 id=две-точки class="relative group">Две точки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%b2%d0%b5-%d1%82%d0%be%d1%87%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h4><p>Наиболее распространённый способ задать диапазон коммитов — это запись с двумя точками. По существу, таким образом вы просите Git взять набор коммитов, достижимых из одного коммита, но не достижимых из другого. Например, пускай ваша история коммитов выглядит так, как показано на рисунке 6-1.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0601-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-1. Пример истории для выбора набора коммитов.</p></blockquote><p>Допустим, вы хотите посмотреть, что в вашей ветке <code>experiment</code> ещё не было слито в ветку <code>master</code>. Можно попросить Git показать вам лог только таких коммитов с помощью <code>master..experiment</code> — эта запись означает &ldquo;все коммиты, достижимые из experiment, которые недостижимы из master&rdquo;. Для краткости и большей понятности в примерах мы будем использовать буквы для обозначения коммитов на диаграмме вместо настоящего вывода лога в том порядке, в каком они будут отображены:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log master..experiment
</span></span><span style=display:flex><span>D
</span></span><span style=display:flex><span>C
</span></span></code></pre></div><p>С другой стороны, если вы хотите получить обратное — все коммиты в <code>master</code>, которых нет в <code>experiment</code>, можно переставить имена веток. Запись <code>experiment..master</code> покажет всё, что есть в <code>master</code>, но недостижимо из <code>experiment</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log experiment..master
</span></span><span style=display:flex><span>F
</span></span><span style=display:flex><span>E
</span></span></code></pre></div><p>Такое полезно, если вы хотите, чтобы ветка <code>experiment</code> была обновлённой, и хотите посмотреть, что вы собираетесь в неё слить. Ещё один частый случай использования этого синтаксиса — посмотреть, что вы собираетесь отправить на удалённый сервер:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log origin/master..HEAD
</span></span></code></pre></div><p>Эта команда покажет вам все коммиты в текущей ветке, которых нет в ветке <code>master</code> на сервере <code>origin</code>. Если бы вы выполнили <code>git push</code>, при условии, что текущая ветка отслеживает <code>origin/master</code>, то коммиты, которые перечислены в выводе <code>git log origin/master..HEAD</code> это те коммиты, которые были бы отправлены на сервер.
Кроме того, можно опустить одну из сторон в такой записи — Git подставит туда HEAD. Например, вы можете получить такой же результат, как и в предыдущем примере, набрав <code>git log origin/master..</code> — Git подставит HEAD сам, если одна из сторон отсутствует.</p><h4 id=множество-вершин class="relative group">Множество вершин <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bc%d0%bd%d0%be%d0%b6%d0%b5%d1%81%d1%82%d0%b2%d0%be-%d0%b2%d0%b5%d1%80%d1%88%d0%b8%d0%bd aria-label=Якорь>#</a></span></h4><p>Запись с двумя точками полезна как сокращение, но, возможно, вы захотите указать больше двух веток, чтобы указать нужную ревизию. Например, чтобы посмотреть, какие коммиты находятся в одной из нескольких веток, но не в текущей. Git позволяет сделать это с помощью использования либо символа <code>^</code>, либо <code>--not</code> перед любыми ссылками, коммиты, достижимые из которых, вы не хотите видеть. Таким образом, следующие три команды эквивалентны:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log refA..refB
</span></span><span style=display:flex><span>$ git log ^refA refB
</span></span><span style=display:flex><span>$ git log refB --not refA
</span></span></code></pre></div><p>Это удобно, потому что с помощью такого синтаксиса можно указать более двух ссылок в своём запросе, чего вы не сможете сделать с помощью двух точек. Например, если вы хотите увидеть все коммиты достижимые из <code>refA</code> или <code>refB</code>, но не из <code>refC</code>, можно набрать одну из таких команд:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log refA refB ^refC
</span></span><span style=display:flex><span>$ git log refA refB --not refC
</span></span></code></pre></div><p>Всё это делает систему выбора ревизий очень мощной, что должно помочь вам определять, что содержится в ваших ветках.</p><h4 id=три-точки class="relative group">Три точки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%82%d1%80%d0%b8-%d1%82%d0%be%d1%87%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h4><p>Последняя основная запись для выбора диапазона коммитов — это запись с тремя точками, которая означает те коммиты, которые достижимы по одной из двух ссылок, но не по обеим одновременно. Вернёмся к примеру истории коммитов на рисунке 3-1.
Если вы хотите увидеть, что находится в <code>master</code> или <code>experiment</code>, но не в обоих сразу, выполните</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log master...experiment
</span></span><span style=display:flex><span>F
</span></span><span style=display:flex><span>E
</span></span><span style=display:flex><span>D
</span></span><span style=display:flex><span>C
</span></span></code></pre></div><p>Повторимся, что это даст вам стандартный <code>log</code>-вывод, но покажет только информацию об этих четырёх коммитах, упорядоченных по дате коммита, как и обычно.</p><p>В этом случае вместе с командой <code>log</code> обычно используют параметр <code>--left-right</code>, который показывает, на какой стороне диапазона находится каждый коммит. Это помогает сделать данные полезнее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --left-right master...experiment
</span></span><span style=display:flex><span>&lt; F
</span></span><span style=display:flex><span>&lt; E
</span></span><span style=display:flex><span>&gt; D
</span></span><span style=display:flex><span>&gt; C
</span></span></code></pre></div><p>С помощью этих инструментов вы можете намного легче объяснить Git&rsquo;у, какой коммит или коммиты вы хотите изучить.</p><h2 id=интерактивное-индексирование class="relative group">Интерактивное индексирование <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d0%b2%d0%bd%d0%be%d0%b5-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5 aria-label=Якорь>#</a></span></h2><p>Вместе с Git&rsquo;ом поставляется пара сценариев (script), облегчающих выполнение некоторых задач в командной строке. Сейчас мы посмотрим на несколько интерактивных команд, которые помогут вам легко смастерить свои коммиты так, чтобы включить в них только определённые части файлов. Эти инструменты сильно помогают в случае, когда вы поменяли кучу файлов, а потом решили, что хотите, чтобы эти изменения были в нескольких сфокусированных коммитах, а не в одном большом путанном коммите. Так вы сможете убедиться, что ваши коммиты — это логически разделённые наборы изменений, которые будет легко просматривать другим разработчикам, работающим с вами.
Если вы выполните <code>git add</code> с опцией <code>-i</code> или <code>--interactive</code>, Git перейдёт в режим интерактивной оболочки и покажет что-то похожее на это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add -i
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:    unchanged        +0/-1 TODO
</span></span><span style=display:flex><span>  2:    unchanged        +1/-1 index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*** Commands ***
</span></span><span style=display:flex><span>  1: status     2: update      3: revert     4: add untracked
</span></span><span style=display:flex><span>  5: patch      6: diff        7: quit       8: help
</span></span><span style=display:flex><span>What now&gt; 
</span></span></code></pre></div><p>Как видите, эта команда показывает содержимое индекса, но в другом виде — по сути, ту же информацию вы получили бы при вызове <code>git status</code>, но здесь она в более сжатом и информативном виде. <code>git add -i</code> показывает проиндексированные изменения слева, а непроиндексированные — справа.</p><p>Затем идёт раздел Commands (команды). Тут можно сделать многие вещи, включая добавление файлов в индекс, удаление файлов из индекса, индексирование файлов частями, добавление неотслеживаемых файлов и просмотр дельт (diff) проиндексированных изменений.</p><h3 id=добавление-и-удаление-файлов-из-индекса class="relative group">Добавление и удаление файлов из индекса <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2-%d0%b8%d0%b7-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b0 aria-label=Якорь>#</a></span></h3><p>Если набрать <code>2</code> или <code>u</code> в приглашении <code>What now></code>, сценарий спросит, какие файлы вы хотите добавить в индекс:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:    unchanged        +0/-1 TODO
</span></span><span style=display:flex><span>  2:    unchanged        +1/-1 index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span><span style=display:flex><span>Update&gt;&gt;
</span></span></code></pre></div><p>Чтобы проиндексировать файлы TODO и index.html, нужно набрать их номера:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Update&gt;&gt; 1,2
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>* 1:    unchanged        +0/-1 TODO
</span></span><span style=display:flex><span>* 2:    unchanged        +1/-1 index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span><span style=display:flex><span>Update&gt;&gt;
</span></span></code></pre></div><p>Символ <code>*</code> рядом с каждым файлом означает, что файл выбран для индексирования. Если вы сейчас ничего не будете вводить, а нажмёте Enter в приглашении <code>Update>></code>, то Git возьмёт всё, что уже выбрано, и добавит в индекс:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Update&gt;&gt; 
</span></span><span style=display:flex><span>updated <span style=color:#ae81ff>2</span> paths
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*** Commands ***
</span></span><span style=display:flex><span>  1: status     2: update      3: revert     4: add untracked
</span></span><span style=display:flex><span>  5: patch      6: diff        7: quit       8: help
</span></span><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:        +0/-1      nothing TODO
</span></span><span style=display:flex><span>  2:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span></code></pre></div><p>Как видите, теперь файлы TODO и index.html проиндексированы (staged), а файл simplegit.rb — всё ещё нет. Если в этот момент вы хотите удалить файл TODO из индекса, используйте опцию <code>3</code> или <code>r</code> (revert):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*** Commands ***
</span></span><span style=display:flex><span>  1: status     2: update      3: revert     4: add untracked
</span></span><span style=display:flex><span>  5: patch      6: diff        7: quit       8: help
</span></span><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:        +0/-1      nothing TODO
</span></span><span style=display:flex><span>  2:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span><span style=display:flex><span>Revert&gt;&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>* 1:        +0/-1      nothing TODO
</span></span><span style=display:flex><span>  2:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span><span style=display:flex><span>Revert&gt;&gt; <span style=color:#f92672>[</span>enter<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>reverted one path
</span></span></code></pre></div><p>Взглянув на статус снова, вы увидите, что файл TODO удалён из индекса:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*** Commands ***
</span></span><span style=display:flex><span>  1: status     2: update      3: revert     4: add untracked
</span></span><span style=display:flex><span>  5: patch      6: diff        7: quit       8: help
</span></span><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:    unchanged        +0/-1 TODO
</span></span><span style=display:flex><span>  2:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>  3:    unchanged        +5/-1 lib/simplegit.rb
</span></span></code></pre></div><p>Чтобы посмотреть дельту для проиндексированных изменений, используйте команду <code>6</code> или <code>d</code> (diff). Она покажет вам список проиндексированных файлов, и вы сможете выбрать те, для которых хотите посмотреть дельту. Это почти то же, что указать <code>git diff --cached</code> в командной строке:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*** Commands ***
</span></span><span style=display:flex><span>  1: status     2: update      3: revert     4: add untracked
</span></span><span style=display:flex><span>  5: patch      6: diff        7: quit       8: help
</span></span><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>Review diff&gt;&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>diff --git a/index.html b/index.html
</span></span><span style=display:flex><span>index 4d07108..4335f49 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/index.html
</span></span><span style=display:flex><span>+++ b/index.html
</span></span><span style=display:flex><span>@@ -16,7 +16,7 @@ Date Finder
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> &lt;p id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;out&#34;</span>&gt;...&lt;/p&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-&lt;div id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;footer&#34;</span>&gt;contact : support@github.com&lt;/div&gt;
</span></span><span style=display:flex><span>+&lt;div id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;footer&#34;</span>&gt;contact : email.support@github.com&lt;/div&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> &lt;script type<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/javascript&#34;</span>&gt;
</span></span></code></pre></div><p>С помощью этих базовых команд вы можете использовать интерактивный режим для <code>git add</code>, чтобы немного проще работать со своим индексом.</p><h3 id=индексирование-по-частям class="relative group">Индексирование по частям <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be-%d1%87%d0%b0%d1%81%d1%82%d1%8f%d0%bc aria-label=Якорь>#</a></span></h3><p>Для Git&rsquo;а также возможно индексировать определённые части файлов, а не всё сразу. Например, если вы сделали несколько изменений в файле simplegit.rb и хотите проиндексировать одно из них, а другое — нет, то сделать такое в Git&rsquo;е очень легко. В строке приглашения интерактивного режима наберите <code>5</code> или <code>p</code> (patch). Git спросит, какие файлы вы хотите индексировать частями; затем для каждой части изменений в выбранных файлах один за другим будут показываться куски дельт файла, и вас будут спрашивать, хотите ли вы занести их в индекс:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
</span></span><span style=display:flex><span>index dd5ecc4..57399e0 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/lib/simplegit.rb
</span></span><span style=display:flex><span>+++ b/lib/simplegit.rb
</span></span><span style=display:flex><span>@@ -22,7 +22,7 @@ class SimpleGit
</span></span><span style=display:flex><span>   end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   def log<span style=color:#f92672>(</span>treeish <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;master&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>-    command<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;git log -n 25 #{treeish}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>+    command<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;git log -n 30 #{treeish}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   def blame<span style=color:#f92672>(</span>path<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Stage this hunk <span style=color:#f92672>[</span>y,n,a,d,/,j,J,g,e,?<span style=color:#f92672>]</span>? 
</span></span></code></pre></div><p>На этой стадии у вас много вариантов действий. Набрав <code>?</code>, вы получите список возможных действий:</p><pre tabindex=0><code>Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk (добавить этот кусок в индекс)
n - do not stage this hunk (не добавлять этот кусок в индекс)
a - stage this and all the remaining hunks in the file (добавить этот и все оставшиеся куски в этом файле в индекс)
d - do not stage this hunk nor any of the remaining hunks in the file (не добавлять в индекс ни этот, ни последующие куски в этом файле)
g - select a hunk to go to (выбрать кусок и перейти к нему)
/ - search for a hunk matching the given regex (поиск куска по регулярному выражению)
j - leave this hunk undecided, see next undecided hunk (отложить решение для этого куска, перейти к следующему отложенному куску)
J - leave this hunk undecided, see next hunk (отложить решение для этого куска, перейти к следующему куску)
k - leave this hunk undecided, see previous undecided hunk (отложить решение для этого куска, перейти к предыдущему отложенному куску)
K - leave this hunk undecided, see previous hunk (отложить решение для этого куска, перейти к предыдущему куску)
s - split the current hunk into smaller hunks (разбить текущий кусок на меньшие части)
e - manually edit the current hunk (отредактировать текущий кусок вручную)
? - print help (вывести справку)
</code></pre><p>Как правило, вы будете использовать <code>y</code> или <code>n</code> для индексирования каждого куска, но индексирование всех кусков сразу в некоторых файлах или откладывание решения на потом также может оказаться полезным. Если вы добавите в индекс одну часть файла, а другую часть — нет, вывод статуса будет выглядеть так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>What now&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>           staged     unstaged path
</span></span><span style=display:flex><span>  1:    unchanged        +0/-1 TODO
</span></span><span style=display:flex><span>  2:        +1/-1      nothing index.html
</span></span><span style=display:flex><span>  3:        +1/-1        +4/-0 lib/simplegit.rb
</span></span></code></pre></div><p>Статус файла simplegit.rb выглядит любопытно. Он показывает, что часть строк в индексе, а часть — не в индексе. Мы частично проиндексировали этот файл. Теперь вы можете выйти из интерактивного сценария и выполнить <code>git commit</code>, чтобы создать коммит из этих частично проиндексированных файлов.</p><p>В заключение скажем, что нет необходимости входить в интерактивный режим <code>git add</code>, чтобы выполнять индексирование частями — вы можете запустить тот же сценарий, набрав <code>git add -p</code> или <code>git add --patch</code> в командной строке.</p><h2 id=прятанье class="relative group">Прятанье <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d1%8f%d1%82%d0%b0%d0%bd%d1%8c%d0%b5 aria-label=Якорь>#</a></span></h2><p>Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того, чтобы позже можно было вернуться в это же состояние. Ответ на эту проблему — команда <code>git stash</code>.</p><p>Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений, которые вы потом в любое время можете снова применить.</p><h3 id=прятанье-своих-трудов class="relative group">Прятанье своих трудов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d1%8f%d1%82%d0%b0%d0%bd%d1%8c%d0%b5-%d1%81%d0%b2%d0%be%d0%b8%d1%85-%d1%82%d1%80%d1%83%d0%b4%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Чтобы продемонстрировать, как это работает, предположим, что вы идёте к своему проекту и начинаете работать над парой файлов и, возможно, добавляете в индекс одно из изменений. Если вы выполните <code>git status</code>, вы увидите грязное состояние проекта:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   lib/simplegit.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Теперь вы хотите поменять ветку, но не хотите делать коммит с тем, над чем вы ещё работаете; тогда вы прячете эти изменения. Чтобы создать новую &ldquo;заначку&rdquo;, выполните <code>git stash</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash
</span></span><span style=display:flex><span>Saved working directory and index state <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;WIP on master: 049d078 added the index file&#34;</span>
</span></span><span style=display:flex><span>HEAD is now at 049d078 added the index file
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>To restore them type <span style=color:#e6db74>&#34;git stash apply&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Ваш рабочий каталог чист:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span>nothing to commit <span style=color:#f92672>(</span>working directory clean<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>В данный момент вы легко можете переключить ветки и поработать где-то ещё; ваши изменения сохранены в стеке. Чтобы посмотреть, что у вас есть припрятанного, используйте <code>git stash list</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash list
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>: WIP on master: 049d078 added the index file
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>: WIP on master: c264051... Revert <span style=color:#e6db74>&#34;added file_size&#34;</span>
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>: WIP on master: 21d80a5... added number to log
</span></span></code></pre></div><p>В нашем случае две &ldquo;заначки&rdquo; были сделаны ранее, так что у вас теперь три разных припрятанных работы. Вы можете снова применить ту, которую только что спрятали, с помощью команды, показанной в справке в выводе первоначальной команды <code>stash</code>: <code>git stash apply</code>. Если вы хотите применить одну из старых заначек, можете сделать это, указав её имя так: <code>git stash apply stash@{2}</code>. Если не указывать ничего, Git будет подразумевать, что вы хотите применить последнюю спрятанную работу:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash apply
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   lib/simplegit.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Как видите, Git восстановил изменения в файлах, которые вы отменили, когда использовали команду <code>stash</code>. В нашем случае у вас был чистый рабочий каталог, когда вы восстанавливали спрятанные изменения, и к тому же вы делали это на той же ветке, на которой находились во время прятанья. Но наличие чистого рабочего каталога и применение на той же ветке не обязательны для <code>git stash apply</code>. Вы можете спрятать изменения на одной ветке, переключиться позже на другую ветку и попытаться восстановить изменения. У вас в рабочем каталоге также могут быть изменённые и недокоммиченные файлы во время применения спрятанного — Git выдаст вам конфликты слияния, если что-то уже не может быть применено чисто.</p><p>Изменения в файлах были восстановлены, но файлы в индексе — нет. Чтобы добиться такого, необходимо выполнить команду <code>git stash apply</code> с опцией <code>--index</code>, тогда команда попытается применить изменения в индексе. Если бы вы выполнили команду так, а не как раньше, то получили бы исходное состояние:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash apply --index
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   lib/simplegit.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Всё, что делает опция apply — это пытается применить спрятанную работу — то, что вы спрятали, всё ещё будет находиться в стеке. Чтобы удалить спрятанное, выполните <code>git stash drop</code> с именем &ldquo;заначки&rdquo;, которую нужно удалить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash list
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>: WIP on master: 049d078 added the index file
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>: WIP on master: c264051... Revert <span style=color:#e6db74>&#34;added file_size&#34;</span>
</span></span><span style=display:flex><span>stash@<span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>: WIP on master: 21d80a5... added number to log
</span></span><span style=display:flex><span>$ git stash drop stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Dropped stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>364e91f3f268f0900bc3ee613f9f733e82aaed43<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Также можно выполнить <code>git stash pop</code>, чтобы применить спрятанные изменения и сразу же удалить их из стека.</p><h3 id=откат-применения-спрятанных-изменений class="relative group">Откат применения спрятанных изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%ba%d0%b0%d1%82-%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d1%81%d0%bf%d1%80%d1%8f%d1%82%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h3><p>При некоторых сценариях использования, может понадобиться применить спрятанные изменения, поработать, а потом отменить изменения, внесённые командой <code>stash apply</code>. Git не предоставляет команды <code>stash unapply</code>, но можно добиться того же эффекта получив сначала патч для спрятанных изменений, а потом применив его в перевёрнутом виде:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash show -p stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span> | git apply -R
</span></span></code></pre></div><p>Снова, если вы не указываете параметр для <code>stash</code>, Git подразумевает то, что было спрятано последним:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash show -p | git apply -R
</span></span></code></pre></div><p>Если хотите, сделайте псевдоним и добавьте в свой Git команду <code>stash-unapply</code>. Например, так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global alias.stash-unapply <span style=color:#e6db74>&#39;!git stash show -p | git apply -R&#39;</span>
</span></span><span style=display:flex><span>$ git stash
</span></span><span style=display:flex><span>$ <span style=color:#75715e>#... work work work</span>
</span></span><span style=display:flex><span>$ git stash-unapply
</span></span></code></pre></div><h3 id=создание-ветки-из-спрятанных-изменений class="relative group">Создание ветки из спрятанных изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8-%d0%b8%d0%b7-%d1%81%d0%bf%d1%80%d1%8f%d1%82%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h3><p>Если вы спрятали какие-то наработки и оставили их на время, а в это время продолжили работать на той же ветке, то у вас могут возникнуть трудности с восстановлением спрятанной работы. Если <code>apply</code> попытается изменить файл, который вы редактировали после прятанья, то возникнет конфликт слияния, который надо будет разрешить. Если нужен более простой способ снова потестировать спрятанную работу, можно выполнить команду <code>git stash branch</code>, которая создаст вам новую ветку с началом из того коммита, на котором вы находились во время прятанья, восстановит в ней вашу работу и затем удалит спрятанное, если оно применилось успешно:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git stash branch testchanges
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;testchanges&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># On branch testchanges</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   lib/simplegit.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>Dropped refs/stash@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>f0dfc4d5dc332d1cee34a634182e168c4efc3359<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Это сокращение удобно для того, чтобы легко восстановить свою работу, а затем поработать над ней в новой ветке.</p><h2 id=перезапись-истории class="relative group">Перезапись истории <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d0%b7%d0%b0%d0%bf%d0%b8%d1%81%d1%8c-%d0%b8%d1%81%d1%82%d0%be%d1%80%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h2><p>Неоднократно во время работы с Git&rsquo;ом, вам может захотеться по какой-либо причине исправить свою историю коммитов. Одна из чудесных особенностей Git&rsquo;а заключается в том, что он даёт возможность принять решение в самый последний момент. Используя индекс, вы можете решить, какие файлы пойдут в какие коммиты, непосредственно перед тем, как сделать коммит. Вы можете воспользоваться командой <code>stash</code>, решив, что над чем-то ещё не стоило начинать работать. А также вы можете переписать уже сделанные коммиты так, будто они были сделаны как-то по-другому. В частности, это может быть изменение порядка следования коммитов, редактирование сообщений или модифицирование файлов в коммите, уплотнение и разделение коммитов, а также полное удаление некоторых коммитов — но только до того, как вы поделитесь наработками с другими.</p><p>В этом разделе вы узнаете, как делать подобные полезные вещи, чтобы перед публикацией приводить историю коммитов в желаемый вид.</p><h3 id=изменение-последнего-коммита class="relative group">Изменение последнего коммита <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d0%bd%d0%b5%d0%b3%d0%be-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%b0 aria-label=Якорь>#</a></span></h3><p>Изменение последнего коммита — это, вероятно, наиболее типичный случай переписывания истории, который вы будете делать. Как правило, вам от вашего последнего коммита понадобятся две основные вещи: изменить сообщение коммита или изменить только что записанный снимок состояния, добавив, изменив или удалив из него файлы.</p><p>Если вы всего лишь хотите изменить сообщение последнего коммита — это очень просто:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div><p>Выполнив это, вы попадёте в свой текстовый редактор, в котором будет находиться сообщение последнего коммита, готовое к тому, чтобы его отредактировали. Когда вы сохраните текст и закроете редактор, Git создаст новый коммит с вашим сообщением и сделает его новым последним коммитом.</p><p>Если вы сделали коммит и затем хотите изменить снимок состояния в коммите, добавив или изменив файлы, допустим, потому что вы забыли добавить только что созданный файл, когда делали коммит, то процесс выглядит в основном так же. Вы добавляете в индекс изменения, которые хотите, редактируя файл и выполняя для него <code>git add</code> или выполняя <code>git rm</code> для отслеживаемого файла, и затем <code>git commit --amend</code> возьмёт текущий индекс и сделает его снимком состояния нового коммита.</p><p>Будьте осторожны, используя этот приём, потому что <code>git commit --amend</code> меняет SHA-1 коммита. Тут как с маленьким перемещением (rebase) — не правьте последний коммит, если вы его уже куда-то отправили.</p><h3 id=изменение-сообщений-нескольких-коммитов class="relative group">Изменение сообщений нескольких коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d0%b9-%d0%bd%d0%b5%d1%81%d0%ba%d0%be%d0%bb%d1%8c%d0%ba%d0%b8%d1%85-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Чтобы изменить коммит, находящийся глубоко в истории, вам придётся перейти к использованию более сложных инструментов. В Git&rsquo;е нет специального инструмента для редактирования истории, но вы можете использовать <code>rebase</code> для перемещения ряда коммитов на то же самое место, где они были изначально, а не куда-то в другое место. Используя инструмент для интерактивного перемещения, вы можете останавливаться на каждом коммите, который хотите изменить, и редактировать сообщение, добавлять файлы или делать что-то ещё. Интерактивное перемещение можно запустить, добавив опцию <code>-i</code> к <code>git rebase</code>. Необходимо указать, насколько далёкие в истории коммиты вы хотите переписать, сообщив команде, на какой коммит выполняется перемещение.</p><p>Например, если вы хотите изменить сообщения последних трёх коммитов или сообщения для только некоторых коммитов в этой группе, вам надо передать в <code>git rebase -i</code> в качестве аргумента родителя последнего коммита, который вы хотите изменить, то есть <code>HEAD~2^</code> или <code>HEAD~3</code>. Наверное, проще запомнить <code>~3</code>, потому что вы пытаетесь отредактировать три последних коммита, но имейте в виду, что на самом деле вы обозначили четвёртый сверху коммит — родительский коммит для того, который хотите отредактировать:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rebase -i HEAD~3
</span></span></code></pre></div><p>Снова напомним, что это команда для перемещения, то есть все коммиты в диапазоне <code>HEAD~3..HEAD</code> будут переписаны вне зависимости от того, меняли ли вы в них сообщение или нет. Не трогайте те коммиты, которые вы уже отправили на центральный сервер — сделав так, вы запутаете других разработчиков, дав им разные версии одних и тех же изменений.</p><p>Запуск этой команды выдаст вам в текстовом редакторе список коммитов, который будет выглядеть следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pick f7f3f6d changed my name a bit
</span></span><span style=display:flex><span>pick 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>pick a5f4a0d added cat-file
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Rebase 710f0f8..a5f4a0d onto 710f0f8</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Commands:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  p, pick = use commit</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  e, edit = use commit, but stop for amending</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  s, squash = use commit, but meld into previous commit</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># However, if you remove everything, the rebase will be aborted.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Важно отметить, что эти коммиты выведены в обратном порядке по сравнению с тем, как вы их обычно видите, используя команду <code>log</code>. Запустив <code>log</code>, вы получите что-то вроде этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#34;%h %s&#34;</span> HEAD~3..HEAD
</span></span><span style=display:flex><span>a5f4a0d added cat-file
</span></span><span style=display:flex><span>310154e updated README formatting and added blame
</span></span><span style=display:flex><span>f7f3f6d changed my name a bit
</span></span></code></pre></div><p>Обратите внимание на обратный порядок. Интерактивное перемещение выдаёт сценарий, который будет выполнен. Он начнётся с коммита, который вы указали в командной строке (<code>HEAD~3</code>), и воспроизведёт изменения, сделанные каждым из этих коммитов, сверху вниз. Наверху указан самый старый коммит, а не самый новый, потому что он будет воспроизведён первым.</p><p>Вам надо отредактировать сценарий так, чтобы он останавливался на коммитах, которые вы хотите отредактировать. Чтобы сделать это, замените слово pick на слово edit для каждого коммита, на котором сценарий должен остановиться. Например, чтобы изменить сообщение только для третьего коммита, отредактируйте файл так, чтобы он выглядел следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>edit f7f3f6d changed my name a bit
</span></span><span style=display:flex><span>pick 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>pick a5f4a0d added cat-file
</span></span></code></pre></div><p>Когда вы сохраните и выйдете из редактора, Git откатит вас назад к последнему коммиту в списке и выкинет вас в командную строку, выдав следующее сообщение:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rebase -i HEAD~3
</span></span><span style=display:flex><span>Stopped at 7482e0d... updated the gemspec to hopefully work better
</span></span><span style=display:flex><span>You can amend the commit now, with
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       git commit --amend
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Once you’re satisfied with your changes, run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       git rebase --continue
</span></span></code></pre></div><p>В этой инструкции в точности сказано, что надо сделать. Наберите</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div><p>Измените сообщение коммита и выйдите из редактора. Теперь выполните</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rebase --continue
</span></span></code></pre></div><p>Данная команда применит оставшиеся два коммита автоматически и закончит на этом. Если вы измените pick на edit для большего количества строк, то вы повторите эти шаги для каждого коммита, где вы напишете edit. Каждый раз Git будет останавливаться, давая вам исправить коммит, а потом, когда вы закончите, будет продолжать.</p><h3 id=переупорядочение-коммитов class="relative group">Переупорядочение коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%83%d0%bf%d0%be%d1%80%d1%8f%d0%b4%d0%be%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Интерактивное перемещение можно также использовать для изменения порядка следования и для полного удаления коммитов. Если вы хотите удалить коммит &ldquo;added cat-file&rdquo; и поменять порядок, в котором идут два других коммита, измените сценарий для rebase с такого</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pick f7f3f6d changed my name a bit
</span></span><span style=display:flex><span>pick 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>pick a5f4a0d added cat-file
</span></span></code></pre></div><p>на такой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pick 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>pick f7f3f6d changed my name a bit
</span></span></code></pre></div><p>Когда вы сохраните и выйдете из редактора, Git откатит вашу ветку к родительскому для этих трёх коммиту, применит <code>310154e</code>, затем <code>f7f3f6d</code>, а потом остановится. Вы фактически поменяли порядок следования коммитов и полностью удалили коммит &ldquo;added cat-file&rdquo;.</p><h3 id=уплотнение-коммитов class="relative group">Уплотнение коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%bf%d0%bb%d0%be%d1%82%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>С помощью интерактивного перемещения также возможно взять несколько коммитов и сплющить их в один коммит. Сценарий выдаёт полезное сообщение с инструкциями для перемещения:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Commands:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  p, pick = use commit</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  e, edit = use commit, but stop for amending</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  s, squash = use commit, but meld into previous commit</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># However, if you remove everything, the rebase will be aborted.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Если вместо &ldquo;pick&rdquo; или &ldquo;edit&rdquo; указать &ldquo;squash&rdquo;, Git применит изменения и из этого коммита, и из предыдущего, а затем даст вам объединить сообщения для коммитов. Итак, чтобы сделать один коммит из трёх наших коммитов, надо сделать так, чтобы сценарий выглядел следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pick f7f3f6d changed my name a bit
</span></span><span style=display:flex><span>squash 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>squash a5f4a0d added cat-file
</span></span></code></pre></div><p>Когда вы сохраните и выйдете из редактора, Git применит все три изменения, а затем опять выдаст вам редактор для того, чтобы объединить сообщения трёх коммитов:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># This is a combination of 3 commits.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># The first commit&#39;s message is:</span>
</span></span><span style=display:flex><span>changed my name a bit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This is the 2nd commit message:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>updated README formatting and added blame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This is the 3rd commit message:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>added cat-file
</span></span></code></pre></div><p>Когда вы это сохраните, у вас будет один коммит, который вносит изменения такие же, как три бывших коммита.</p><h3 id=разбиение-коммита class="relative group">Разбиение коммита <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%80%d0%b0%d0%b7%d0%b1%d0%b8%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%b0 aria-label=Якорь>#</a></span></h3><p>Разбиение коммита — это отмена коммита, а затем индексирование изменений частями и добавление коммитов столько раз, сколько коммитов вы хотите получить. Предположим, что вы хотите разбить средний из наших трёх коммитов. Вместо &ldquo;updated README formatting and added blame&rdquo; вы хотите получить два отдельных коммита: &ldquo;updated README formatting&rdquo; в качестве первого и &ldquo;added blame&rdquo; в качестве второго. Вы можете сделать это в сценарии <code>rebase -i</code>, поставив &ldquo;edit&rdquo; в инструкции для коммита, который хотите разбить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>pick f7f3f6d changed my name a bit
</span></span><span style=display:flex><span>edit 310154e updated README formatting and added blame
</span></span><span style=display:flex><span>pick a5f4a0d added cat-file
</span></span></code></pre></div><p>Когда вы сохраните и выйдете из редактора, Git откатится к родителю первого коммита в списке, применит первый коммит (<code>f7f3f6d</code>), применит второй (<code>310154e</code>) и выбросит вас в консоль. Здесь вы можете сбросить последний коммит в смешанном режиме с помощью <code>git reset HEAD^</code> — это в сущности отменит этот коммит и оставит изменённые файлы непроиндексированными. Теперь вы можете взять сброшенные изменения и создать из них несколько коммитов. Просто добавляйте файлы в индекс и делайте коммиты, пока не сделаете несколько штук. Затем, когда закончите, выполните <code>git rebase --continue</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reset HEAD^
</span></span><span style=display:flex><span>$ git add README
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;updated README formatting&#39;</span>
</span></span><span style=display:flex><span>$ git add lib/simplegit.rb
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;added blame&#39;</span>
</span></span><span style=display:flex><span>$ git rebase --continue
</span></span></code></pre></div><p>Когда Git применит последний коммит (<code>a5f4a0d</code>) в сценарии, история будет выглядеть так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -4 --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#34;%h %s&#34;</span>
</span></span><span style=display:flex><span>1c002dd added cat-file
</span></span><span style=display:flex><span>9b29157 added blame
</span></span><span style=display:flex><span>35cfb2b updated README formatting
</span></span><span style=display:flex><span>f3cc40e changed my name a bit
</span></span></code></pre></div><p>Повторимся ещё раз, что эта операция меняет SHA всех коммитов в списке, так что убедитесь, что ни один из коммитов в этом списке вы ещё не успели отправить в общий репозиторий.</p><h3 id=крайнее-средство-filter-branch class="relative group">Крайнее средство: filter-branch <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%ba%d1%80%d0%b0%d0%b9%d0%bd%d0%b5%d0%b5-%d1%81%d1%80%d0%b5%d0%b4%d1%81%d1%82%d0%b2%d0%be-filter-branch aria-label=Якорь>#</a></span></h3><p>Есть ещё один вариант переписывания истории, который можно использовать, если надо переписать большое количество коммитов в автоматизируемой форме — например, везде поменять свой e-mail адрес или удалить файл из каждого коммита — это команда <code>filter-branch</code>. Она может переписать огромные периоды вашей истории, так что, возможно, вообще не стоит использовать её, если ваш проект успел стать публичным и другие люди уже работают на основе коммитов, которые вы собрались переписать. Однако, она может быть весьма полезной. Мы посмотрим на некоторые типичные варианты использования команды так, чтобы вы получили представление о тех вещах, на которые она способна.</p><h4 id=удаление-файла-изо-всех-коммитов class="relative group">Удаление файла изо всех коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0-%d0%b8%d0%b7%d0%be-%d0%b2%d1%81%d0%b5%d1%85-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h4><p>Такое случается довольно часто. Кто-нибудь случайно добавляет в коммит огромный бинарный файл, необдуманно выполнив <code>git add .</code>, и вы хотите удалить его отовсюду. Или, может быть, вы нечаянно добавили в коммит файл содержащий пароль, а теперь хотите сделать код этого проекта открытым. <code>filter-branch</code> — это тот инструмент, который вы наверняка захотите использовать, чтобы прочесать всю историю. Чтобы удалить файл с именем passwords.txt изо всей истории, используйте опцию <code>--tree-filter</code> для <code>filter-branch</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git filter-branch --tree-filter <span style=color:#e6db74>&#39;rm -f passwords.txt&#39;</span> HEAD
</span></span><span style=display:flex><span>Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd <span style=color:#f92672>(</span>21/21<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Ref <span style=color:#e6db74>&#39;refs/heads/master&#39;</span> was rewritten
</span></span></code></pre></div><p>Опция <code>--tree-filter</code> выполняет указанную команду после выгрузки каждой версии проекта и затем заново делает коммит из результата. В нашем случае мы удалили файл с именем passwords.txt из каждого снимка состояния независимо от того, существовал ли он там или нет. Если вы хотите удалить все случайно добавленные резервные копии, сделанные вашим текстовым редактором, выполните что-то типа <code>git filter-branch --tree-filter "find * -type f -name '*~' -delete" HEAD</code>.</p><p>Вы увидите, как Git переписывает деревья и коммиты, а в конце переставляет указатель ветки. Как правило, хороший вариант — делать это в тестовой ветке, а затем жёстко сбрасывать ветку master с помощью <code>reset --hard</code>, когда вы поймёте, что результат — это то, чего вы действительно добивались. Чтобы запустить <code>filter-branch</code> для всех веток, можно передать команде параметр <code>--all</code>.</p><h4 id=сделать-подкаталог-новым-корнем class="relative group">Сделать подкаталог новым корнем <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%b4%d0%b5%d0%bb%d0%b0%d1%82%d1%8c-%d0%bf%d0%be%d0%b4%d0%ba%d0%b0%d1%82%d0%b0%d0%bb%d0%be%d0%b3-%d0%bd%d0%be%d0%b2%d1%8b%d0%bc-%d0%ba%d0%be%d1%80%d0%bd%d0%b5%d0%bc aria-label=Якорь>#</a></span></h4><p>Предположим, вы импортировали репозиторий из другой системы контроля версий, и в нём есть бессмысленные каталоги (trunk, tags, и др.). Если вы хотите сделать <code>trunk</code> новым корнем проекта, команда <code>filter-branch</code> может помочь вам сделать и это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git filter-branch --subdirectory-filter trunk HEAD
</span></span><span style=display:flex><span>Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f <span style=color:#f92672>(</span>12/12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Ref <span style=color:#e6db74>&#39;refs/heads/master&#39;</span> was rewritten
</span></span></code></pre></div><p>Теперь всюду корневой каталог проекта будет в подкаталоге <code>trunk</code>. Git также автоматически удалит все коммиты, которые не затрагивают данный подкаталог.</p><h4 id=глобальное-изменение-e-mail-адреса class="relative group">Глобальное изменение e-mail адреса <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b3%d0%bb%d0%be%d0%b1%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b5-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-e-mail-%d0%b0%d0%b4%d1%80%d0%b5%d1%81%d0%b0 aria-label=Якорь>#</a></span></h4><p>Ещё один типичный случай — это, когда вы забыли выполнить <code>git config</code>, чтобы задать своё имя и e-mail адрес, перед тем как начать работать. Или, возможно, вы хотите открыть код своего проекта с работы и поменять все свои рабочие e-mail&rsquo;ы на свой личный адрес. В любом случае с помощью <code>filter-branch</code> вы с таким же успехом можете поменять адреса почты в нескольких коммитах за один раз. Вам надо быть аккуратным, чтобы не поменять и чужие адреса, поэтому используйте <code>--commit-filter</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git filter-branch --commit-filter <span style=color:#e6db74>&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if [ &#34;$GIT_AUTHOR_EMAIL&#34; = &#34;schacon@localhost&#34; ];
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            GIT_AUTHOR_NAME=&#34;Scott Chacon&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            GIT_AUTHOR_EMAIL=&#34;schacon@example.com&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            git commit-tree &#34;$@&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    else
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            git commit-tree &#34;$@&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>	fi&#39;</span> HEAD
</span></span></code></pre></div><p>Эта команда проходит по всем коммитам и переписывает их так, чтобы там был указан новый адрес. Так как коммиты содержат значения SHA-1 своих родителей, эта команда поменяет все SHA в вашей истории, а не только те, в которых есть указанный e-mail адрес.</p><h2 id=отладка-с-помощью-git class="relative group">Отладка с помощью Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-git aria-label=Якорь>#</a></span></h2><p>Git также предоставляет несколько инструментов, призванных помочь вам в отладке ваших проектов. Так как Git сконструирован так, чтобы работать с практически любыми типами проектов, эти инструменты довольно общие, но зачастую они могут помочь отловить ошибку или её виновника, если что-то пошло не так.</p><h3 id=аннотация-файла class="relative group">Аннотация файла <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b0%d0%bd%d0%bd%d0%be%d1%82%d0%b0%d1%86%d0%b8%d1%8f-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0 aria-label=Якорь>#</a></span></h3><p>Если вы отловили ошибку в коде и хотите узнать, когда и по какой причине она была внесена, то аннотация файла — лучший инструмент для этого случая. Он покажет вам, какие коммиты модифицировали каждую строку файла в последний раз. Так что, если вы видите, что какой-то метод в коде содержит ошибку, то можно сделать аннотацию нужного файла с помощью <code>git blame</code>, чтобы посмотреть, когда и кем каждая строка метода была в последний раз отредактирована. В этом примере используется опция <code>-L</code>, чтобы ограничить вывод строками с 12ой по 22ую:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git blame -L 12,22 simplegit.rb 
</span></span><span style=display:flex><span>^4832fe2 <span style=color:#f92672>(</span>Scott Chacon  2008-03-15 10:31:28 -0700 12<span style=color:#f92672>)</span>  def show<span style=color:#f92672>(</span>tree <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;master&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>^4832fe2 <span style=color:#f92672>(</span>Scott Chacon  2008-03-15 10:31:28 -0700 13<span style=color:#f92672>)</span>   command<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;git show #{tree}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>^4832fe2 <span style=color:#f92672>(</span>Scott Chacon  2008-03-15 10:31:28 -0700 14<span style=color:#f92672>)</span>  end
</span></span><span style=display:flex><span>^4832fe2 <span style=color:#f92672>(</span>Scott Chacon  2008-03-15 10:31:28 -0700 15<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>9f6560e4 <span style=color:#f92672>(</span>Scott Chacon  2008-03-17 21:52:20 -0700 16<span style=color:#f92672>)</span>  def log<span style=color:#f92672>(</span>tree <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;master&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>79eaf55d <span style=color:#f92672>(</span>Scott Chacon  2008-04-06 10:15:08 -0700 17<span style=color:#f92672>)</span>   command<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;git log #{tree}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>9f6560e4 <span style=color:#f92672>(</span>Scott Chacon  2008-03-17 21:52:20 -0700 18<span style=color:#f92672>)</span>  end
</span></span><span style=display:flex><span>9f6560e4 <span style=color:#f92672>(</span>Scott Chacon  2008-03-17 21:52:20 -0700 19<span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>42cf2861 <span style=color:#f92672>(</span>Magnus Chacon 2008-04-13 10:45:01 -0700 20<span style=color:#f92672>)</span>  def blame<span style=color:#f92672>(</span>path<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>42cf2861 <span style=color:#f92672>(</span>Magnus Chacon 2008-04-13 10:45:01 -0700 21<span style=color:#f92672>)</span>   command<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;git blame #{path}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>42cf2861 <span style=color:#f92672>(</span>Magnus Chacon 2008-04-13 10:45:01 -0700 22<span style=color:#f92672>)</span>  end
</span></span></code></pre></div><p>Заметьте, что первое поле — это частичная SHA-1 коммита, в котором последний раз менялась строка. Следующие два поля — это значения, полученные из этого коммита — имя автора и дата создания коммита. Так что вы легко можете понять, кто и когда менял данную строку. Затем идут номера строк и содержимое файла. Также обратите внимание на строки с <code>^4832fe2</code>, это те строки, которые находятся здесь со времён первого коммита для этого файла. Это коммит, в котором этот файл был впервые добавлен в проект, и с тех пор те строки не менялись. Это всё несколько сбивает с толку, потому что только что вы увидели по крайней мере три разных способа изменить SHA коммита с помощью <code>^</code>, но тут вот такое значение.</p><p>Ещё одна крутая вещь в Git&rsquo;е — это то, что он не отслеживает переименования файлов в явном виде. Он записывает снимки состояний, а затем пытается выяснить, что было переименовано неявно уже после того, как это случилось. Одна из интересных функций, возможная благодаря этому, заключается в том, что вы можете попросить дополнительно выявить все виды перемещений кода. Если вы передадите <code>-C</code> в <code>git blame</code>, Git проанализирует аннотируемый файл и попытается выявить, откуда фрагменты кода в нём появились изначально, если они были скопированы откуда-то. Недавно я занимался разбиением файла <code>GITServerHandler.m</code> на несколько файлов, один из которых был <code>GITPackUpload.m</code>. Вызвав <code>blame</code> с опцией <code>-C</code> для <code>GITPackUpload.m</code>, я могу понять откуда части кода здесь появились:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git blame -C -L 141,153 GITPackUpload.m 
</span></span><span style=display:flex><span>f344f58d GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-04 141<span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>f344f58d GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-04 142<span style=color:#f92672>)</span> - <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> gatherObjectShasFromC
</span></span><span style=display:flex><span>f344f58d GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-04 143<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>70befddd GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-03-22 144<span style=color:#f92672>)</span>         //NSLog<span style=color:#f92672>(</span>@<span style=color:#e6db74>&#34;GATHER COMMI
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&#34;</span>GATHER COMMI
</span></span><span style=display:flex><span>ad11ac80 GITPackUpload.m    <span style=color:#f92672>(</span>Scott 2009-03-24 150<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>56ef2caf GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-05 151<span style=color:#f92672>)</span>         <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>commit<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>56ef2caf GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-05 152<span style=color:#f92672>)</span>                 <span style=color:#f92672>[</span>refDict setOb
</span></span><span style=display:flex><span>56ef2caf GITServerHandler.m <span style=color:#f92672>(</span>Scott 2009-01-05 153<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Это действительно удобно. Стандартно вам бы выдали в качестве начального коммита тот коммит, в котором вы скопировали код, так как это первый коммит, в котором вы поменяли эти строки в данном файле. А сейчас Git выдал вам изначальный коммит, в котором эти строки были написаны, несмотря на то, что это было в другом файле.</p><h3 id=бинарный-поиск class="relative group">Бинарный поиск <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d1%8b%d0%b9-%d0%bf%d0%be%d0%b8%d1%81%d0%ba aria-label=Якорь>#</a></span></h3><p>Аннотирование файла помогает, когда вы знаете, где у вас ошибка, и есть с чего начинать. Если вы не знаете, что у вас сломалось, и с тех пор, когда код работал, были сделаны десятки или сотни коммитов, вы наверняка обратитесь за помощью к <code>git bisect</code>. Команда <code>bisect</code> выполняет бинарный поиск по истории коммитов, и призвана помочь как можно быстрее определить, в каком коммите была внесена ошибка.</p><p>Положим, вы только что отправили новую версию вашего кода в производство, и теперь вы периодически получаете отчёты о какой-то ошибке, которая не проявлялась, пока вы работали над кодом, и вы не представляете, почему код ведёт себя так. Вы возвращаетесь к своему коду, и у вас получается воспроизвести ошибку, но вы не понимаете, что не так. Вы можете использовать <code>bisect</code>, чтобы выяснить это. Сначала выполните <code>git bisect start</code>, чтобы запустить процесс, а затем <code>git bisect bad</code>, чтобы сказать системе, что текущий коммит, на котором вы сейчас находитесь, сломан. Затем, необходимо сказать <code>bisect</code>, когда было последнее известное хорошее состояние с помощью <code>git bisect good [хороший_коммит]</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect start
</span></span><span style=display:flex><span>$ git bisect bad
</span></span><span style=display:flex><span>$ git bisect good v1.0
</span></span><span style=display:flex><span>Bisecting: <span style=color:#ae81ff>6</span> revisions left to test after this
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ecb6e1bc347ccecc5f9350d878ce677feb13d3b2<span style=color:#f92672>]</span> error handling on repo
</span></span></code></pre></div><p>Git выяснил, что между коммитом, который вы указали как последний хороший коммит (v1.0), и текущей плохой версией было сделано примерно 12 коммитов, и он выгрузил вам версию из середины. В этот момент вы можете провести свои тесты и посмотреть, проявляется ли проблема в этом коммите. Если да, то она была внесена где-то раньше этого среднего коммита; если нет, то проблема появилась где-то после коммита в середине. Положим, что оказывается, что проблема здесь не проявилась, и вы сообщаете об этом Git&rsquo;у, набрав <code>git bisect good</code>, и продолжаете свой путь:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect good
</span></span><span style=display:flex><span>Bisecting: <span style=color:#ae81ff>3</span> revisions left to test after this
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>b047b02ea83310a70fd603dc8cd7a6cd13d15c04<span style=color:#f92672>]</span> secure this thing
</span></span></code></pre></div><p>Теперь вы на другом коммите, посередине между тем, который только что был протестирован и вашим плохим коммитом. Вы снова проводите тесты и выясняете, что текущий коммит сломан. Так что вы говорите об этом Git&rsquo;у с помощью <code>git bisect bad</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect bad
</span></span><span style=display:flex><span>Bisecting: <span style=color:#ae81ff>1</span> revisions left to test after this
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>f71ce38690acf49c1f3c9bea38e09d82a5ce6014<span style=color:#f92672>]</span> drop exceptions table
</span></span></code></pre></div><p>Этот коммит хороший, и теперь у Git&rsquo;а есть вся необходимая информация, чтобы определить, где проблема была внесена впервые. Он выдаёт вам SHA-1 первого плохого коммита и некоторую информацию о нём, а также какие файлы были изменены в этом коммите, так что вы сможете понять, что случилось, что могло внести эту ошибку:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect good
</span></span><span style=display:flex><span>b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
</span></span><span style=display:flex><span>commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
</span></span><span style=display:flex><span>Author: PJ Hyett &lt;pjhyett@example.com&gt;
</span></span><span style=display:flex><span>Date:   Tue Jan <span style=color:#ae81ff>27</span> 14:48:32 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    secure this thing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>:040000 <span style=color:#ae81ff>040000</span> 40ee3e7821b895e52c1695092db9bdc4c61d1730
</span></span><span style=display:flex><span>f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config
</span></span></code></pre></div><p>Если вы закончили, необходимо выполнить <code>git bisect reset</code>, чтобы сбросить HEAD туда, где он был до начала бинарного поиска, иначе вы окажетесь в странном состоянии:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect reset
</span></span></code></pre></div><p>Это мощный инструмент, который поможет вам за считанные минуты проверить сотни коммитов в поисках появившейся ошибки. На самом деле, если у вас есть сценарий (script), который возвращает на выходе 0, если проект хороший и не 0, если проект плохой, то вы можете полностью автоматизировать <code>git bisect</code>. Для начала ему снова надо задать область бинарного поиска, задав известные хороший и плохой коммиты. Если хотите, можете сделать это, указав команде <code>bisect start</code> известный плохой коммит первым, а хороший вторым:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git bisect start HEAD v1.0
</span></span><span style=display:flex><span>$ git bisect run test-error.sh
</span></span></code></pre></div><p>Сделав так, вы получите, что <code>test-error.sh</code> будет автоматически запускаться на каждом выгруженном коммите, пока Git не найдёт первый сломанный коммит. Вы также можете запускать что-нибудь типа <code>make</code> или <code>make tests</code> или что-то там ещё, что запускает ваши автоматические тесты.</p><h2 id=подмодули class="relative group">Подмодули <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%be%d0%b4%d0%bc%d0%be%d0%b4%d1%83%d0%bb%d0%b8 aria-label=Якорь>#</a></span></h2><p>Зачастую случается так, что во время работы над некоторым проектом появляется необходимость использовать внутри него ещё какой-то проект. Возможно, библиотеку, разрабатываемую сторонними разработчиками или разрабатываемую вами обособленно и используемую в нескольких родительских проектах. Типичная проблема, возникающая при использовании подобного сценария, это, как сделать так, чтобы иметь возможность рассматривать эти два проекта как отдельные, всё же имея возможность использовать один проект внутри другого.</p><p>Вот пример. Предположим, вы разрабатываете веб-сайт и создаёте Atom-ленты. И вместо того, чтобы писать собственный код, генерирующий Atom, вы решили использовать библиотеку. Вы, вероятно, должны либо подключить нужный код с помощью разделяемой библиотеки, такой как устанавливаемый модуль CPAN или пакет RubyGem, либо скопировать исходный код в дерево собственного проекта. Проблема с подключением библиотеки в том, что библиотеку сложно хоть как-то модифицировать под свои нужды, и зачастую её сложнее распространять. Ведь вы вынуждены удостовериться в том, что эта библиотека доступна на каждом клиенте. Проблема с включением кода в ваш собственный проект в том, что любые изменения, вносимые вами, могут конфликтовать с изменениями, которые появятся в основном проекте, и эти изменения будет сложно слить.</p><p>Git решает эту задачу, используя подмодули (submodule). Подмодули позволяют содержать один Git-репозиторий как подкаталог другого Git-репозитория. Это даёт возможность клонировать ещё один репозиторий внутрь проекта, храня коммиты для этого репозитория отдельно.</p><h3 id=начало-использования-подмодулей class="relative group">Начало использования подмодулей <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bd%d0%b0%d1%87%d0%b0%d0%bb%d0%be-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%bf%d0%be%d0%b4%d0%bc%d0%be%d0%b4%d1%83%d0%bb%d0%b5%d0%b9 aria-label=Якорь>#</a></span></h3><p>Предположим, вы хотите добавить библиотеку Rack (интерфейс шлюза веб-сервера Ruby) в свой проект, возможно, внося свои собственные изменения в него, но продолжая сливать их с изменениями основного проекта. Первое, что вам требуется сделать, это клонировать внешний репозиторий в подкаталог. Добавление внешних проектов в качестве подмодулей делается командой <code>git submodule add</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git submodule add git://github.com/chneukirchen/rack.git rack
</span></span><span style=display:flex><span>Initialized empty Git repository in /opt/subtest/rack/.git/
</span></span><span style=display:flex><span>remote: Counting objects: 3181, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>1534/1534<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>3181</span> <span style=color:#f92672>(</span>delta 1951<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>2623</span> <span style=color:#f92672>(</span>delta 1603<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>3181/3181<span style=color:#f92672>)</span>, 675.42 KiB | <span style=color:#ae81ff>422</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>1951/1951<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span></code></pre></div><p>Теперь у вас внутри проекта в подкаталоге с именем <code>rack</code> находится проект Rack. Вы можете переходить в этот подкаталог, вносить изменения, добавить ваш собственный доступный для записи внешний репозиторий для отправки в него своих изменений, извлекать и сливать из исходного репозитория и многое другое. Если вы выполните <code>git status</code> сразу после добавления подмодуля, то увидите две вещи:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      new file:   .gitmodules</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      new file:   rack</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Вначале вы заметите файл <code>.gitmodules</code>. Это конфигурационный файл, который содержит соответствие между URL проекта и локальным подкаталогом, в который был загружен подмодуль:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .gitmodules 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>submodule <span style=color:#e6db74>&#34;rack&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      path <span style=color:#f92672>=</span> rack
</span></span><span style=display:flex><span>      url <span style=color:#f92672>=</span> git://github.com/chneukirchen/rack.git
</span></span></code></pre></div><p>Если у вас несколько подмодулей, то в этом файле будет несколько записей. Важно обратить внимание на то, что этот файл находится под версионным контролем вместе с другими вашими файлами, так же как и файл <code>.gitignore</code>. Он отправляется при выполнении <code>push</code> и загружается при выполнении <code>pull</code> вместе с остальными файлами проекта. Так другие люди, которые клонируют этот проект, узнают, откуда взять проекты-подмодули.</p><p>В следующем листинге вывода <code>git status</code> присутствует элемент <code>rack</code>. Если вы выполните <code>git diff</code> для него, то увидите кое-что интересное:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff --cached rack
</span></span><span style=display:flex><span>diff --git a/rack b/rack
</span></span><span style=display:flex><span>new file mode <span style=color:#ae81ff>160000</span>
</span></span><span style=display:flex><span>index 0000000..08d709f
</span></span><span style=display:flex><span>--- /dev/null
</span></span><span style=display:flex><span>+++ b/rack
</span></span><span style=display:flex><span>@@ -0,0 +1 @@
</span></span><span style=display:flex><span>+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
</span></span></code></pre></div><p>Хотя <code>rack</code> является подкаталогом в вашем рабочем каталоге, Git видит его как подмодуль и не отслеживает его содержимое, если вы не находитесь в нём. Вместо этого, Git записывает его как один конкретный коммит из этого репозитория. Если вы производите изменения в этом подкаталоге и делаете коммит, основной проект замечает, что HEAD в подмодуле был изменён, и регистрирует тот хеш коммита, над которым вы в данный момент завершили работу в подмодуле. Таким образом, если кто-то склонирует этот проект, он сможет воссоздать окружение в точности.</p><p>Это важная особенность подмодулей – вы запоминаете их как определенный коммит (состояние), в котором они находятся. Вы не можете записать подмодуль под ссылкой <code>master</code> или какой-либо другой символьной ссылкой.</p><p>Если вы создадите коммит, то увидите что-то вроде этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;first commit with submodule rack&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master 0550271<span style=color:#f92672>]</span> first commit with submodule rack
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span> files changed, <span style=color:#ae81ff>4</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>100644</span> .gitmodules
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>160000</span> rack
</span></span></code></pre></div><p>Обратите внимание на режим 160000 для элемента rack. Это специальный режим в Git&rsquo;е, который по существу означает, что в качестве записи в каталоге сохраняется коммит, а не подкаталог или файл.</p><p>Вы можете обращаться с каталогом <code>rack</code> как с отдельным проектом и время от времени обновлять свой &ldquo;надпроект&rdquo; с помощью указателя на самый последний коммит в этом подпроекте. Все команды Git&rsquo;а в этих двух каталогах работают независимо друг от друга:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -1
</span></span><span style=display:flex><span>commit 0550271328a0038865aad6331e620cd7238601bb
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Apr <span style=color:#ae81ff>9</span> 09:03:56 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    first commit with submodule rack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cd rack/
</span></span><span style=display:flex><span>$ git log -1
</span></span><span style=display:flex><span>commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
</span></span><span style=display:flex><span>Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Wed Mar <span style=color:#ae81ff>25</span> 14:49:04 <span style=color:#ae81ff>2009</span> +0100
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Document version change
</span></span></code></pre></div><h3 id=клонирование-проекта-с-подмодулями class="relative group">Клонирование проекта с подмодулями <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%ba%d0%bb%d0%be%d0%bd%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b0-%d1%81-%d0%bf%d0%be%d0%b4%d0%bc%d0%be%d0%b4%d1%83%d0%bb%d1%8f%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h3><p>Сейчас мы склонируем проект, содержащий подмодуль. После получения такого проекта в вашей копии будут каталоги, содержащие подмодули, но пока что без единого файла в них:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone git://github.com/schacon/myproject.git
</span></span><span style=display:flex><span>Initialized empty Git repository in /opt/myproject/.git/
</span></span><span style=display:flex><span>remote: Counting objects: 6, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>4/4<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>6</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>6/6<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>$ cd myproject
</span></span><span style=display:flex><span>$ ls -l
</span></span><span style=display:flex><span>total <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#ae81ff>1</span> schacon  admin   <span style=color:#ae81ff>3</span> Apr  <span style=color:#ae81ff>9</span> 09:11 README
</span></span><span style=display:flex><span>drwxr-xr-x  <span style=color:#ae81ff>2</span> schacon  admin  <span style=color:#ae81ff>68</span> Apr  <span style=color:#ae81ff>9</span> 09:11 rack
</span></span><span style=display:flex><span>$ ls rack/
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><p>Каталог <code>rack</code> присутствует, но он пустой. Необходимо выполнить две команды: <code>git submodule init</code> для инициализации вашего локального файла конфигурации и <code>git submodule update</code> для получения всех данных из подмодуля и перехода к соответствующему коммиту, указанному в вашем основном проекте:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git submodule init
</span></span><span style=display:flex><span>Submodule <span style=color:#e6db74>&#39;rack&#39;</span> <span style=color:#f92672>(</span>git://github.com/chneukirchen/rack.git<span style=color:#f92672>)</span> registered <span style=color:#66d9ef>for</span> path <span style=color:#e6db74>&#39;rack&#39;</span>
</span></span><span style=display:flex><span>$ git submodule update
</span></span><span style=display:flex><span>Initialized empty Git repository in /opt/myproject/rack/.git/
</span></span><span style=display:flex><span>remote: Counting objects: 3181, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>1534/1534<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>3181</span> <span style=color:#f92672>(</span>delta 1951<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>2623</span> <span style=color:#f92672>(</span>delta 1603<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>3181/3181<span style=color:#f92672>)</span>, 675.42 KiB | <span style=color:#ae81ff>173</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>1951/1951<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Submodule path <span style=color:#e6db74>&#39;rack&#39;</span>: checked out <span style=color:#e6db74>&#39;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&#39;</span>
</span></span></code></pre></div><p>Теперь ваш подкаталог <code>rack</code> точно в том состоянии, в котором он был, когда вы раньше делали коммит. Если другой разработчик внесёт изменения в код rack и затем сделает коммит, а вы потом обновите эту ссылку и сольёте её, то вы получите что-то странное:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git merge origin/master
</span></span><span style=display:flex><span>Updating 0550271..85a3eee
</span></span><span style=display:flex><span>Fast forward
</span></span><span style=display:flex><span> rack |    <span style=color:#ae81ff>2</span> +-
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>1</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master*<span style=color:#f92672>]</span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      modified:   rack</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Вы слили то, что по существу является изменением указателя на подмодуль. Но при этом обновления кода в каталоге подмодуля не произошло, так что всё выглядит так, как будто вы имеете грязное состояние в своём рабочем каталоге:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff
</span></span><span style=display:flex><span>diff --git a/rack b/rack
</span></span><span style=display:flex><span>index 6c5e70b..08d709f <span style=color:#ae81ff>160000</span>
</span></span><span style=display:flex><span>--- a/rack
</span></span><span style=display:flex><span>+++ b/rack
</span></span><span style=display:flex><span>@@ -1 +1 @@
</span></span><span style=display:flex><span>-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
</span></span><span style=display:flex><span>+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
</span></span></code></pre></div><p>Это всё из-за того, что ваш указатель на подмодуль не соответствует тому, что на самом деле находится в каталоге подмодуля. Чтобы исправить это, необходимо снова выполнить <code>git submodule update</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git submodule update
</span></span><span style=display:flex><span>remote: Counting objects: 5, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>3/3<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>3</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Unpacking objects: 100% <span style=color:#f92672>(</span>3/3<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>From git@github.com:schacon/rack
</span></span><span style=display:flex><span>   08d709f..6c5e70b  master     -&gt; origin/master
</span></span><span style=display:flex><span>Submodule path <span style=color:#e6db74>&#39;rack&#39;</span>: checked out <span style=color:#e6db74>&#39;6c5e70b984a60b3cecd395edd5b48a7575bf58e0&#39;</span>
</span></span></code></pre></div><p>Вы вынуждены делать так каждый раз, когда вы получаете изменения подмодуля в главном проекте. Это странно, но это работает.</p><p>Распространённая проблема возникает, когда разработчик делает изменения в своей локальной копии подмодуля, но не отправляет их на общий сервер. Затем он создаёт коммит содержащий указатель на это непубличное состояние и отправляет его в основной проект. Когда другие разработчики пытаются выполнить <code>git submodule update</code>, система работы с подмодулями не может найти указанный коммит, потому что он существует только в системе первого разработчика. Если такое случится, вы увидите ошибку вроде этой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git submodule update
</span></span><span style=display:flex><span>fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
</span></span><span style=display:flex><span>Unable to checkout <span style=color:#e6db74>&#39;6c5e70b984a60b3cecd395edd5ba7575bf58e0&#39;</span> in submodule path <span style=color:#e6db74>&#39;rack&#39;</span>
</span></span></code></pre></div><p>Вам надо посмотреть, кто последним менял подмодуль:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -1 rack
</span></span><span style=display:flex><span>commit 85a3eee996800fcfa91e2119372dd4172bf76678
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Thu Apr <span style=color:#ae81ff>9</span> 09:19:14 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    added a submodule reference I will never make public. hahahahaha!
</span></span></code></pre></div><p>А затем отправить этому человеку письмо со своими возмущениями.</p><h3 id=суперпроекты class="relative group">Суперпроекты <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%83%d0%bf%d0%b5%d1%80%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d1%8b aria-label=Якорь>#</a></span></h3><p>Иногда разработчики хотят объединить подкаталоги крупного проекта в нечто связанное в зависимости от того, в какой они команде. Это типично для людей, перешедших с CVS или Subversion, где они определяли модуль или набор подкаталогов, и они хотят сохранить данный тип рабочего процесса.</p><p>Хороший способ сделать такое в Git&rsquo;е — это сделать каждый из подкаталогов отдельным Git-репозиторием, и создать Git-репозиторий для суперпроекта, который будет содержать несколько подмодулей. Преимущество такого подхода в том, что вы можете более гибко определять отношения между проектами при помощи меток и ветвей в суперпроектах.</p><h3 id=проблемы-с-подмодулями class="relative group">Проблемы с подмодулями <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%be%d0%b1%d0%bb%d0%b5%d0%bc%d1%8b-%d1%81-%d0%bf%d0%be%d0%b4%d0%bc%d0%be%d0%b4%d1%83%d0%bb%d1%8f%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h3><p>Однако, использование подмодулей не обходится без загвоздок. Во-первых, вы должны быть относительно осторожны, работая в каталоге подмодуля. Когда вы выполняете команду <code>git submodule update</code>, она возвращает определённую версию проекта, но не внутри ветви. Это называется состоянием с отделённым HEAD (detached HEAD) — это означает, что файл HEAD указывает на конкретный коммит, а не на символическую ссылку. Проблема в том, что вы, скорее всего, не хотите работать в окружении с отделённым HEAD, потому что так легко потерять изменения. Если вы сделаете первоначальный <code>submodule update</code>, сделаете коммит в каталоге подмодуля, не создавая ветки для работы в ней, и затем вновь выполните <code>git submodule update</code> из основного проекта, без создания коммита в суперпроекте, Git затрёт ваши изменения без предупреждения. Технически вы не потеряете проделанную работу, но у вас не будет ветки, указывающей на неё, так что будет несколько сложновато её восстановить.</p><p>Для предотвращения этой проблемы создавайте ветвь, когда работаете в каталоге подмодуля с использованием команды <code>git checkout -b work</code> или какой-нибудь аналогичной. Когда вы сделаете обновление подмодуля командой <code>submodule update</code> в следующий раз, она всё же откатит вашу работу, но, по крайней мере, у вас будет указатель для возврата назад.</p><p>Переключение веток с подмодулями в них также может быть мудрёным. Если вы создадите новую ветку, добавите туда подмодуль и затем переключитесь обратно, туда где не было этого подмодуля, вы всё ещё будете иметь каталог подмодуля в виде неотслеживаемого каталога:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b rack
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;rack&#34;</span>
</span></span><span style=display:flex><span>$ git submodule add git@github.com:schacon/rack.git rack
</span></span><span style=display:flex><span>Initialized empty Git repository in /opt/myproj/rack/.git/
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>3184/3184<span style=color:#f92672>)</span>, 677.42 KiB | <span style=color:#ae81ff>34</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>1952/1952<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;added rack submodule&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>rack cc49a69<span style=color:#f92672>]</span> added rack submodule
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span> files changed, <span style=color:#ae81ff>4</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>100644</span> .gitmodules
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>160000</span> rack
</span></span><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>Switched to branch <span style=color:#e6db74>&#34;master&#34;</span>
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Untracked files:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      rack/</span>
</span></span></code></pre></div><p>Вы будете вынуждены либо переместить каталог подмодуля в другое место, либо удалить его. В случае удаления вам потребуется клонировать его снова при переключении обратно, и тогда вы можете потерять локальные изменения или ветки, которые не были отправлены в основной репозиторий.</p><p>Последняя проблема, которая возникает у многих, и о которой стоит предостеречь, возникает при переходе от подкаталогов к подмодулям. Если вы держали некоторые файлы под версионным контролем в своём проекте, а сейчас хотите перенести их в подмодуль, вам надо быть осторожным, иначе Git разозлится на вас. Допустим, вы держите файлы rack в подкаталоге проекта, и вы хотите вынести его в подмодуль. Если вы просто удалите подкаталог и затем выполните <code>submodule add</code>, Git наорёт на вас:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ rm -Rf rack/
</span></span><span style=display:flex><span>$ git submodule add git@github.com:schacon/rack.git rack
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;rack&#39;</span> already exists in the index
</span></span></code></pre></div><p>Вначале вам следует убрать каталог <code>rack</code> из индекса (убрать из-под версионного контроля). Потом можете добавить подмодуль:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm -r rack
</span></span><span style=display:flex><span>$ git submodule add git@github.com:schacon/rack.git rack
</span></span><span style=display:flex><span>Initialized empty Git repository in /opt/testsub/rack/.git/
</span></span><span style=display:flex><span>remote: Counting objects: 3184, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>1465/1465<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>3184</span> <span style=color:#f92672>(</span>delta 1952<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>2770</span> <span style=color:#f92672>(</span>delta 1675<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>3184/3184<span style=color:#f92672>)</span>, 677.42 KiB | <span style=color:#ae81ff>88</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>1952/1952<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span></code></pre></div><p>Теперь, предположим, вы сделали это в ветке. Если вы попытаетесь переключиться обратно на ту ветку, где эти файлы всё ещё в актуальном дереве, а не в подмодуле, то вы получите такую ошибку:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>error: Untracked working tree file <span style=color:#e6db74>&#39;rack/AUTHORS&#39;</span> would be overwritten by merge.
</span></span></code></pre></div><p>Вам следует переместить каталог подмодуля <code>rack</code>, перед тем, как вы сможете переключиться на ветку, которая не содержит его:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ mv rack /tmp/
</span></span><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>Switched to branch <span style=color:#e6db74>&#34;master&#34;</span>
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>README	rack
</span></span></code></pre></div><p>Затем, когда вы переключитесь обратно, вы получите пустой каталог <code>rack</code>. Вы сможете либо выполнить <code>git submodule update</code> для повторного клонирования, или вернуть содержимое вашего каталога <code>/tmp/rack</code> обратно в пустой каталог.</p><h2 id=слияние-поддеревьев class="relative group">Слияние поддеревьев <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%bb%d0%b8%d1%8f%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be%d0%b4%d0%b4%d0%b5%d1%80%d0%b5%d0%b2%d1%8c%d0%b5%d0%b2 aria-label=Якорь>#</a></span></h2><p>Теперь, когда вы увидели сложности системы подмодулей, давайте посмотрим на альтернативный путь решения той же проблемы. Когда Git выполняет слияние, он смотрит на то, что требуется слить воедино, и потом выбирает подходящую стратегию слияния. Если вы сливаете две ветви, Git использует <em>рекурсивную</em> (recursive) стратегию. Если вы объединяете более двух ветвей, Git выбирает стратегию <em>осьминога</em> (octopus). Эти стратегии выбираются за вас автоматически потому, что рекурсивная стратегия может обрабатывать сложные трёхсторонние ситуации слияния — например, более чем один общий предок — но она может сливать только две ветви. Слияние методом осьминога может справиться с множеством веток, но является более осторожным, чтобы предотвратить сложные конфликты, так что этот метод является стратегией по умолчанию при слиянии более двух веток.</p><p>Однако, существуют другие стратегии, которые вы также можете выбрать. Одна из них — слияние <em>поддеревьев</em> (subtree), и вы можете использовать его для решения задачи с подпроектами. Сейчас вы увидите, как выполнить то же встраивание rack, как и в предыдущем разделе, но с использованием стратегии слияния поддеревьев.</p><p>Идея слияния поддеревьев состоит в том, что у вас есть два проекта, и один из проектов отображается в подкаталог другого и наоборот. Если вы зададите в качестве стратегии слияния метод subtree, то Git будет достаточно умён, чтобы понять, что один из проектов является поддеревом другого и выполнит слияние в соответствии с этим. И это довольно удивительно.</p><p>Сначала добавим приложение Rack в проект. Добавим проект Rack как внешнюю ссылку в свой проект, и затем поместим его в отдельную ветку:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote add rack_remote git@github.com:schacon/rack.git
</span></span><span style=display:flex><span>$ git fetch rack_remote
</span></span><span style=display:flex><span>warning: no common commits
</span></span><span style=display:flex><span>remote: Counting objects: 3184, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>1465/1465<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>3184</span> <span style=color:#f92672>(</span>delta 1952<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>2770</span> <span style=color:#f92672>(</span>delta 1675<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>3184/3184<span style=color:#f92672>)</span>, 677.42 KiB | <span style=color:#ae81ff>4</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>1952/1952<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>From git@github.com:schacon/rack
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      build      -&gt; rack_remote/build
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      master     -&gt; rack_remote/master
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      rack-0.4   -&gt; rack_remote/rack-0.4
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      rack-0.9   -&gt; rack_remote/rack-0.9
</span></span><span style=display:flex><span>$ git checkout -b rack_branch rack_remote/master
</span></span><span style=display:flex><span>Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;rack_branch&#34;</span>
</span></span></code></pre></div><p>Теперь у нас есть корень проекта Rack в ветке <code>rack_branch</code> и наш проект в ветке <code>master</code>. Если вы переключитесь на одну ветку, а затем на другую, то увидите, что содержимое их корневых каталогов различно:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib
</span></span><span style=display:flex><span>COPYING	       README         bin           example	       test
</span></span><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>Switched to branch <span style=color:#e6db74>&#34;master&#34;</span>
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>README
</span></span></code></pre></div><p>Допустим, вы хотите поместить проект Rack в подкаталог своего проекта в ветке <code>master</code>. Вы можете сделать это в Git&rsquo;е командой <code>git read-tree</code>. Вы узнаете больше про команду <code>read-tree</code> и её друзей в главе 9, а пока достаточно знать, что она считывает корень дерева одной ветки в индекс и рабочий каталог. Вам достаточно переключиться обратно на ветку <code>master</code> и вытянуть ветку <code>rack</code> в подкаталог <code>rack</code> основного проекта из ветки <code>master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git read-tree --prefix<span style=color:#f92672>=</span>rack/ -u rack_branch
</span></span></code></pre></div><p>После того как вы сделаете коммит, все файлы проекта Rack будут находиться в этом подкаталоге — будто вы скопировали их туда из архива. Интересно то, что вы можете довольно легко слить изменения из одной ветки в другую. Так что если проект Rack изменится, вы сможете вытянуть изменения из основного проекта, переключившись в его ветку и выполнив <code>git pull</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout rack_branch
</span></span><span style=display:flex><span>$ git pull
</span></span></code></pre></div><p>Затем вы можете слить эти изменения обратно в свою главную ветку. Можно использовать <code>git merge -s subtree</code> — это сработает правильно, но тогда Git, кроме того, объединит вместе истории, чего вы, вероятно, не хотите. Чтобы получить изменения и заполнить сообщение коммита, используйте опции <code>--squash</code> и <code>--no-commit</code> вместе с опцией стратегии <code>-s subtree</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge --squash -s subtree --no-commit rack_branch
</span></span><span style=display:flex><span>Squash commit -- not updating HEAD
</span></span><span style=display:flex><span>Automatic merge went well; stopped before committing as requested
</span></span></code></pre></div><p>Все изменения из проекта Rack слиты и готовы для локальной фиксации. Вы также можете сделать наоборот — внести изменения в подкаталог <code>rack</code> вашей ветки <code>master</code>, и затем слить их в ветку <code>rack_branch</code>, чтобы позже представить их мейнтейнерам или отправить их в основной репозиторий проекта с помощью <code>git push</code>.</p><p>Для получения разности между тем, что у вас есть в подкаталоге <code>rack</code> и кодом в вашей ветке <code>rack_branch</code>, чтобы увидеть нужно ли вам объединять их, вы не можете использовать нормальную команду <code>diff</code>. Вместо этого вы должны выполнить <code>git diff-tree</code> с веткой, с которой вы хотите сравнить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff-tree -p rack_branch
</span></span></code></pre></div><p>Или, для сравнения того, что в вашем подкаталоге <code>rack</code> с тем, что было в ветке <code>master</code> на сервере во время последнего обновления, можно выполнить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff-tree -p rack_remote/master
</span></span></code></pre></div><h2 id=итоги class="relative group">Итоги <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%82%d0%be%d0%b3%d0%b8 aria-label=Якорь>#</a></span></h2><p>Вы познакомились с рядом продвинутых инструментов, которые позволяют вам манипулировать вашими коммитами и индексом более совершенно. Если вы заметите проблему, то без труда сможете определить, каким коммитом она внесена, когда и кем. Если вы хотите использовать подпроекты в своём проекте — вы узнали несколько путей, как приспособиться к этим нуждам. К этому моменту вы должны уметь делать в Git&rsquo;е большинство тех вещей, которые вам понадобятся для повседневной работы в командной строке, и при этом вы будете чувствовать себя комфортно.</p><h1 id=настройка-git class="relative group">Настройка Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0-git aria-label=Якорь>#</a></span></h1><p>До этого момента мы описывали основы того, как Git работает, и как его использовать. Также мы познакомились с несколькими предоставляемыми Git&rsquo;ом инструментами, которые делают его использование простым и эффективным. В этой главе мы пройдёмся по некоторым действиям, которые вы можете предпринять, чтобы заставить Git работать в нужной именно вам манере. Мы рассмотрим несколько важных настроек и систему перехватчиков (hook). С их помощью легко сделать так, чтобы Git работал именно так, как вам, вашей компании или вашей группе нужно.</p><h2 id=конфигурирование-git class="relative group">Конфигурирование Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-git aria-label=Якорь>#</a></span></h2><p>В первой главе вкратце было рассказано, как можно изменить настройки Git&rsquo;а с помощью команды <code>git config</code>. Одна из первых вещей, которую мы тогда сделали, это установили свои имя и e-mail адрес:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global user.name <span style=color:#e6db74>&#34;John Doe&#34;</span>
</span></span><span style=display:flex><span>$ git config --global user.email johndoe@example.com
</span></span></code></pre></div><p>Теперь мы разберём пару более интересных опций, которые вы можете задать тем же образом, чтобы настроить Git под себя.</p><p>Мы уже рассмотрели некоторые детали настройки Git&rsquo;а в первой главе, но давайте сейчас быстренько пройдёмся по ним снова. Git использует набор конфигурационных файлов для задания желаемого нестандартного поведения. Первым местом, в котором Git ищет заданные параметры, является файл <code>/etc/gitconfig</code>, содержащий значения, действующие для всех пользователей системы и всех их репозиториев. Когда вы передаёте <code>git config</code> опцию <code>--system</code>, происходит чтение или запись именно этого файла.</p><p>Следующее место, в которое Git заглядывает, это файл <code>~/.gitconfig</code>, который для каждого пользователя свой. Вы можете заставить Git читать или писать этот файл, передав опцию <code>--global</code>.</p><p>И наконец, Git ищет заданные настройки в конфигурационном файле в Git-каталоге (<code>.git/config</code>) того репозитория, который вы используете в данный момент. Значения оттуда относятся к данному конкретному репозиторию. Значения настроек на новом уровне переписывают значения, заданные на предыдущем уровне. Поэтому, например, значения из <code>.git/config</code> перебивают значения в <code>/etc/gitconfig</code>. Позволяется задавать настройки путём редактирования конфигурационного файла вручную, используя правильный синтаксис, но, как правило, проще воспользоваться командой <code>git config</code>.</p><h3 id=основные-настройки-клиента class="relative group">Основные настройки клиента <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d0%bd%d1%8b%d0%b5-%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b8-%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82%d0%b0 aria-label=Якорь>#</a></span></h3><p>Настройки конфигурации, поддерживаемые Git&rsquo;ом, можно разделить на две категории: клиентские и серверные. Большинство опций — клиентские, они задают предпочтения в вашей личной работе. Несмотря на то, что опций доступно великое множество, мы рассмотрим только некоторые из них — те, которые широко используются или значительно влияют на вашу работу. Многие опции полезны только в редких случаях, которые мы не будем здесь рассматривать. Если вы хотите посмотреть список всех опций, которые есть в вашем Git&rsquo;е, выполните:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --help
</span></span></code></pre></div><p>В странице руководства для <code>git config</code> все доступные опции описаны довольно подробно.</p><h4 id=coreeditor class="relative group">core.editor <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#coreeditor aria-label=Якорь>#</a></span></h4><p>Для создания и редактирования сообщений коммитов и меток Git по умолчанию использует тот редактор, который установлен текстовым редактором по умолчанию в вашей системе, или, как запасной вариант, редактор Vi. Чтобы сменить это умолчание на что-нибудь другое, используйте настройку <code>core.editor</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.editor emacs
</span></span></code></pre></div><p>Теперь неважно, что установлено в качестве вашего редактора по умолчанию в переменной оболочки, при редактировании сообщений Git будет запускать Emacs.</p><h4 id=committemplate class="relative group">commit.template <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#committemplate aria-label=Якорь>#</a></span></h4><p>Если установить в этой настройке путь к какому-нибудь файлу в вашей системе, Git будет использовать содержимое этого файла в качестве сообщения по умолчанию при коммите. Например, предположим, что вы создали шаблонный файл <code>$HOME/.gitmessage.txt</code>, который выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>заголовок
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>что произошло
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>карточка: X<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Чтобы попросить Git использовать это в качестве сообщения по умолчанию, которое будет появляться в вашем редакторе при выполнении <code>git commit</code>, задайте значение настройки <code>commit.template</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global commit.template $HOME/.gitmessage.txt
</span></span><span style=display:flex><span>$ git commit
</span></span></code></pre></div><p>После этого, когда во время создания коммита запустится ваш редактор, в нём в качестве сообщения-заглушки будет находиться что-то вроде такого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>заголовок
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>что произошло
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>карточка: X<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Please enter the commit message for your changes. Lines starting</span>
</span></span><span style=display:flex><span><span style=color:#75715e># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># modified:   lib/test.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>~
</span></span><span style=display:flex><span>~
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;.git/COMMIT_EDITMSG&#34;</span> 14L, 297C
</span></span></code></pre></div><p>Если у вас существует определённая политика для сообщений коммитов, то задание шаблона, соответствующего этой политике, и настройка Git&rsquo;а на использование его по умолчанию могут увеличить вероятность того, что этой политики будут придерживаться постоянно.</p><h4 id=corepager class="relative group">core.pager <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#corepager aria-label=Якорь>#</a></span></h4><p>Настройка core.pager определяет, какой пейджер использовать при постраничном отображении вывода таких команд, как <code>log</code> и <code>diff</code>. Вы можете указать здесь <code>more</code> или свой любимый пейджер (по умолчанию используется <code>less</code>), или можно отключить его, указав пустую строку:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.pager <span style=color:#e6db74>&#39;&#39;</span>
</span></span></code></pre></div><p>Если это выполнить, Git будет выдавать весь вывод полностью для всех команд вне зависимости от того, насколько он большой.</p><h4 id=usersigningkey class="relative group">user.signingkey <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#usersigningkey aria-label=Якорь>#</a></span></h4><p>Если вы делаете подписанные аннотированные метки (смотри главу 2), то, чтобы облегчить этот процесс, можно задать свой GPG-ключ для подписи в настройках. Задать ID своего ключа можно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global user.signingkey &lt;id-gpg-ключа&gt;
</span></span></code></pre></div><p>Теперь, чтобы подписать метку, не обязательно каждый раз указывать свой ключ команде <code>git tag</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -s &lt;имя-метки&gt;
</span></span></code></pre></div><h4 id=coreexcludesfile class="relative group">core.excludesfile <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#coreexcludesfile aria-label=Якорь>#</a></span></h4><p>Чтобы Git не видел определённые файлы проекта как неотслеживаемые и не пытался добавить их в индекс при выполнении <code>git add</code>, можно задать для них шаблоны в файл <code>.gitignore</code>, как это описано главе 2. Однако, если вам необходим другой файл, который будет хранить эти или дополнительные значения вне вашего проекта, то вы можете указать Git&rsquo;у расположение такого файла с помощью настройки <code>core.excludesfile</code>. Просто задайте там путь к файлу, в котором написано то же, что пишется в <code>.gitignore</code>.</p><h4 id=helpautocorrect class="relative group">help.autocorrect <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#helpautocorrect aria-label=Якорь>#</a></span></h4><p>Эта опция доступна только в Git 1.6.1 и более поздних. Если вы неправильно наберёте команду в Git&rsquo;е, он выдаст что-то вроде этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git com
</span></span><span style=display:flex><span>git: <span style=color:#e6db74>&#39;com&#39;</span> is not a git-command. See <span style=color:#e6db74>&#39;git --help&#39;</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Did you mean this?
</span></span><span style=display:flex><span>     commit
</span></span></code></pre></div><p>Если установить <code>help.autocorrect</code> в 1, Git автоматически запустит нужную команду, если она была единственным вариантом при этом сценарии.</p><h3 id=цвета-в-git class="relative group">Цвета в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%86%d0%b2%d0%b5%d1%82%d0%b0-%d0%b2-git aria-label=Якорь>#</a></span></h3><p>Git умеет раскрашивать свой вывод для терминала, что может помочь вам быстрее и легче визуально анализировать вывод. Множество опций в настройках помогут вам установить цвета в соответствии со своими предпочтениями.</p><h4 id=colorui class="relative group">color.ui <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#colorui aria-label=Якорь>#</a></span></h4><p>Git автоматически раскрасит большую часть своего вывода, если вы его об этом попросите. Вы можете очень тонко задать, что вы хотите раскрасить и как. Но, чтобы просто включить весь предустановленный цветной вывод для терминала, установите <code>color.ui</code> в true:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global color.ui true
</span></span></code></pre></div><p>Когда установлено это значение, Git раскрашивает свой вывод в случае, если вывод идёт на терминал. Другие доступные значения это: false, при котором вывод никогда не раскрашивается, и always, при котором цвета добавляются всегда, даже если вы перенаправляете вывод команд Git&rsquo;а в файл или через конвейер другой команде.</p><p>Вам вряд ли понадобится использовать <code>color.ui = always</code>. В большинстве случаев, если вам нужны коды цветов в перенаправленном выводе, то вы можете просто передать команде флаг <code>--color</code>, чтобы заставить её добавить коды цветов. Настройка <code>color.ui = true</code> — это почти всегда именно то, что вам нужно.</p><h4 id=color class="relative group"><code>color.*</code> <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#color aria-label=Якорь>#</a></span></h4><p>Если вам необходимо более точно задать какие команды и как должны быть раскрашены, то в Git&rsquo;е есть возможность задать настройки цветов для каждой команды отдельно. Каждая из этих настроек может быть установлена в <code>true</code>, <code>false</code> или <code>always</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>color.branch
</span></span><span style=display:flex><span>color.diff
</span></span><span style=display:flex><span>color.interactive
</span></span><span style=display:flex><span>color.status
</span></span></code></pre></div><p>Кроме того, каждая из этих настроек имеет свои поднастройки, которые можно использовать для задания определённого цвета для какой-то части вывода, если вы хотите перезадать цвета. Например, чтобы получить метаинформацию в выводе команды diff в синем цвете с чёрным фоном и жирным шрифтом, выполните</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global color.diff.meta “blue black bold”
</span></span></code></pre></div><p>Цвет может принимать любое из следующих значений: normal, black, red, green, yellow, blue, magenta, cyan и white. Если вы хотите задать атрибут вроде bold, как мы делали в предыдущем примере, то на выбор представлены: bold, dim, ul, blink и reverse.</p><p>Если вам это интересно, загляните в страницу руководства для <code>git config</code>, чтобы узнать обо всех доступных для конфигурации настройках.</p><h3 id=внешние-утилиты-merge-и-diff class="relative group">Внешние утилиты merge и diff <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d0%bd%d0%b5%d1%88%d0%bd%d0%b8%d0%b5-%d1%83%d1%82%d0%b8%d0%bb%d0%b8%d1%82%d1%8b-merge-%d0%b8-diff aria-label=Якорь>#</a></span></h3><p>Хоть в Git&rsquo;е и есть внутренняя реализация diff, которой мы и пользовались до этого момента, вы можете заменить её внешней утилитой. И ещё вы можете установить графическую утилиту для разрешения конфликтов слияния, вместо того, чтобы разрешать конфликты вручную. Мы рассмотрим настройку Perforce Visual Merge Tool (P4Merge) в качестве замены diff и для разрешения конфликтов слияния, потому что это удобная графическая утилита и к тому же бесплатная.</p><p>Если вам захотелось её попробовать, то P4Merge работает на всех основных платформах, поэтому проблем с ней быть не должно. В примерах мы будем использовать пути к файлам, которые используются на Mac&rsquo;е и Linux&rsquo;е; для Windows вам надо заменить <code>/usr/local/bin</code> на тот путь к исполняемым файлам, который используется в вашей среде.</p><p>Скачать P4Merge можно здесь:</p><p><a href=http://www.perforce.com/perforce/downloads/component.html target=_blank rel=noreferrer>http://www.perforce.com/perforce/downloads/component.html</a></p><p>Для начала сделаем внешние сценарии-обёртки для запуска нужных команд. Я буду использовать Mac&rsquo;овский путь к исполняемым файлам; для других систем это будет тот путь, куда установлен ваш файл <code>p4merge</code>. Сделайте для слияния сценарий-обёртку с именем <code>extMerge</code>, он будет вызывать бинарник со всеми переданными аргументами:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /usr/local/bin/extMerge
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/sh</span>
</span></span><span style=display:flex><span>/Applications/p4merge.app/Contents/MacOS/p4merge $*
</span></span></code></pre></div><p>Обёртка для команды <code>diff</code> проверяет, что ей было передано семь аргументов, и передаёт два из них вашему сценарию для слияния. По умолчанию Git передаёт следующие аргументы программе, выполняющей <code>diff</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>путь старый-файл старый-хеш старые-права новый-файл новый-хеш новые-права
</span></span></code></pre></div><p>Так как нам нужны только <code>старый-файл</code> и <code>новый-файл</code>, воспользуемся сценарием-обёрткой, чтобы передать только те аргументы, которые нам нужны:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /usr/local/bin/extDiff 
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/sh</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> $# -eq <span style=color:#ae81ff>7</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> /usr/local/bin/extMerge <span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$5<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>Ещё следует убедиться, что наши сценарии имеют права на исполнение:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo chmod +x /usr/local/bin/extMerge 
</span></span><span style=display:flex><span>$ sudo chmod +x /usr/local/bin/extDiff
</span></span></code></pre></div><p>Теперь мы можем настроить свой конфигурационный файл на использование наших собственных утилит для разрешения слияний и diff&rsquo;а. Для этого нам потребуется поменять несколько настроек: <code>merge.tool</code>, чтобы указать Git&rsquo;у на то, какую стратегию использовать; <code>mergetool.*.cmd</code>, чтобы указать, как запустить команду; <code>mergetool.trustExitCode</code>, чтобы указать Git&rsquo;у, можно ли по коду возврата определить, было разрешение конфликта слияния успешным или нет; и <code>diff.external</code> для того, чтобы задать команду, используемую для diff. Таким образом, вам надо либо выполнить четыре команды <code>git config</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global merge.tool extMerge
</span></span><span style=display:flex><span>$ git config --global mergetool.extMerge.cmd <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;extMerge &#34;$BASE&#34; &#34;$LOCAL&#34; &#34;$REMOTE&#34; &#34;$MERGED&#34;&#39;</span>
</span></span><span style=display:flex><span>$ git config --global mergetool.trustExitCode false
</span></span><span style=display:flex><span>$ git config --global diff.external extDiff
</span></span></code></pre></div><p>либо отредактировать свой файл <code>~/.gitconfig</code> и добавить туда следующие строки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>merge<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  tool <span style=color:#f92672>=</span> extMerge
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>mergetool <span style=color:#e6db74>&#34;extMerge&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  cmd <span style=color:#f92672>=</span> extMerge <span style=color:#ae81ff>\&#34;</span>$BASE<span style=color:#ae81ff>\&#34;</span> <span style=color:#ae81ff>\&#34;</span>$LOCAL<span style=color:#ae81ff>\&#34;</span> <span style=color:#ae81ff>\&#34;</span>$REMOTE<span style=color:#ae81ff>\&#34;</span> <span style=color:#ae81ff>\&#34;</span>$MERGED<span style=color:#ae81ff>\&#34;</span>
</span></span><span style=display:flex><span>  trustExitCode <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>diff<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  external <span style=color:#f92672>=</span> extDiff
</span></span></code></pre></div><p>Если после того, как всё это настроено, вы выполните команду <code>diff</code> следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff 32d1776b1^ 32d1776b1
</span></span></code></pre></div><p>то вместо того, чтобы получить вывод команды <code>diff</code> в терминал, Git запустит P4Merge, как это показано на рисунке 3-2.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0701-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-2. P4Merge.</p></blockquote><p>Если при попытке слияния двух веток вы получите конфликт, запустите команду <code>git mergetool</code> — она запустит графическую утилиту P4Merge, с помощью которой вы сможете разрешить свои конфликты.</p><p>Что удобно в нашей настройке с обёртками, так это то, что вы с лёгкостью можете поменять утилиты для слияния и diff&rsquo;а. Например, чтобы изменить свои утилиты <code>extDiff</code> и <code>extMerge</code> так, чтобы они использовали утилиту KDiff3, всё, что вам надо сделать, это отредактировать свой файл <code>extMerge</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /usr/local/bin/extMerge
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/sh	</span>
</span></span><span style=display:flex><span>/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
</span></span></code></pre></div><p>Теперь Git будет использовать утилиту KDiff3 для просмотра diff&rsquo;ов и разрешения конфликтов слияния.</p><p>В Git&rsquo;е уже есть предустановленные настройки для множества других утилит для разрешения слияний, для которых вам не надо полностью прописывать команду для запуска, а достаточно просто указать имя утилиты. К таким утилитам относятся: kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff и gvimdiff. Например, если вам неинтересно использовать KDiff3 для diff&rsquo;ов, а хочется использовать его только для разрешения слияний, и команда <code>kdiff3</code> находится в пути, то вы можете выполнить</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global merge.tool kdiff3
</span></span></code></pre></div><p>Если вместо настройки файлов <code>extMerge</code> и <code>extDiff</code> вы выполните эту команду, Git будет использовать KDiff3 для разрешения слияний и обычный свой инструмент diff для diff&rsquo;ов.</p><h3 id=форматирование-и-пробельные-символы class="relative group">Форматирование и пробельные символы <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b8-%d0%bf%d1%80%d0%be%d0%b1%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%81%d0%b8%d0%bc%d0%b2%d0%be%d0%bb%d1%8b aria-label=Якорь>#</a></span></h3><p>Проблемы с форматированием и пробельными символами — одни из самых дурацких и трудноуловимых проблем из тех, с которыми сталкиваются многие разработчики при совместной работе над проектами, особенно если разработка ведётся на разных платформах. Очень просто внести малозаметные изменения с помощью пробельных символов при, например, подготовке патчей из-за того, что текстовые редакторы добавляют их без предупреждения, или в кросс-платформенных проектах Windows-программисты добавляют символы возврата каретки в конце изменяемых ими строк. В Git&rsquo;е есть несколько опций для того, чтобы помочь с решением подобных проблем.</p><h4 id=coreautocrlf class="relative group">core.autocrlf <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#coreautocrlf aria-label=Якорь>#</a></span></h4><p>Если вы пишете код на Windows или пользуетесь другой системой, но работаете с людьми, которые пишут на Windows, то наверняка рано или поздно столкнётесь с проблемой конца строк. Она возникает из-за того, что Windows использует для переноса строк и символ возврата каретки, и символ перехода на новую строку, в то время как в системах Mac и Linux используется только символ перехода на новую строку. Это незначительное, но невероятно раздражающее обстоятельство при кросс-платформенной работе.</p><p>Git может справиться с этим, автоматически конвертируя CRLF-концы строк в LF при коммите и в обратную сторону при выгрузке кода из репозитория на файловую систему. Данную функциональность можно включить с помощью настройки <code>core.autocrlf</code>. Если вы используете Windows, установите настройку в <code>true</code>, тогда концы строк из LF будут сконвертированы в CRLF при выгрузке кода:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.autocrlf true
</span></span></code></pre></div><p>Если вы сидите на Linux&rsquo;е или Mac&rsquo;е, где используются LF-концы строк, вам не надо, чтобы Git автоматически конвертировал их при выгрузке файлов из репозитория. Однако, если вдруг случайно кто-то добавил файл с CRLF-концами строк, то хотелось бы, чтобы Git исправил это. Можно указать Git&rsquo;у, чтобы он конвертировал CRLF в LF только при коммитах, установив настройку <code>core.autocrlf</code> в <code>input</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.autocrlf input
</span></span></code></pre></div><p>Такая настройка даст вам CRLF-концы в выгруженном коде на Windows-системах и LF-концы на Mac&rsquo;ах и Linux&rsquo;е, и в репозитории.</p><p>Если вы Windows-программист, пишущий проект, предназначенный только для Windows, то можете отключить данную функциональность и записывать символы возврата каретки в репозиторий, установив значение настройки в <code>false</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.autocrlf false
</span></span></code></pre></div><h4 id=corewhitespace class="relative group">core.whitespace <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#corewhitespace aria-label=Якорь>#</a></span></h4><p>Git заранее настроен на обнаружение и исправление некоторых проблем, связанных с пробелами. Он может находить четыре основные проблемы с пробелами — две из них по умолчанию отслеживаются, но могут быть выключены, и две по умолчанию не отслеживаются, но их можно включить.</p><p>Те две настройки, которые включены по умолчанию — это <code>trailing-space</code>, которая ищет пробелы в конце строк, и <code>space-before-tab</code>, которая ищет пробелы перед символами табуляции в начале строк.</p><p>Те две, которые по умолчанию выключены, но могут быть включены — это <code>indent-with-non-tab</code>, которая ищет строки, начинающиеся с восьми или более пробелов вместо символов табуляции, и <code>cr-at-eol</code>, которая сообщает Git&rsquo;у, что символы возврата каретки в конце строк допустимы.</p><p>Вы можете указать Git&rsquo;у, какие из этих настроек вы хотите включить, задав их в <code>core.whitespace</code> через запятую. Отключить настройку можно либо опустив её в списке, либо дописав знак <code>-</code> перед соответствующим значением. Например, если вы хотите установить все проверки, кроме <code>cr-at-eol</code>, то это можно сделать так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global core.whitespace <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>    trailing-space,space-before-tab,indent-with-non-tab
</span></span></code></pre></div><p>Git будет выявлять эти проблемы при запуске команды <code>git diff</code> и пытаться выделить их цветом так, чтобы можно было их исправить ещё до коммита. Кроме того, эти значения будут использоваться, чтобы помочь с применением патчей с помощью <code>git apply</code>. Когда будете принимать патч, можете попросить Git предупредить вас о наличии в патче заданных проблем с пробельными символами:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git apply --whitespace<span style=color:#f92672>=</span>warn &lt;патч&gt;
</span></span></code></pre></div><p>Или же Git может попытаться автоматически исправить проблему перед применением патча:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git apply --whitespace<span style=color:#f92672>=</span>fix &lt;патч&gt;
</span></span></code></pre></div><p>Данные настройки также относятся и к команде <code>git rebase</code>. Если вы вдруг сделали коммиты, в которых есть проблемы с пробельными символами, но ещё не отправили их на сервер, запустите <code>rebase</code> с опцией <code>--whitespace=fix</code>, чтобы Git автоматически исправил ошибки во время переписывания патчей.</p><h3 id=настройка-сервера class="relative group">Настройка сервера <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b0 aria-label=Якорь>#</a></span></h3><p>Для серверной части Git&rsquo;а доступно не так уж много настроек, но среди них есть несколько интересных, на которые следует обратить внимание.</p><h4 id=receivefsckobjects class="relative group">receive.fsckObjects <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#receivefsckobjects aria-label=Якорь>#</a></span></h4><p>По умолчанию Git не проверяет все отправленные на сервер объекты на целостность. Хотя Git и может проверять, что каждый объект всё ещё совпадает со своей контрольной суммой SHA-1 и указывает на допустимые объекты, по умолчанию Git не делает этого при каждом запуске команды <code>push</code>. Эта операция довольно затратна и может значительно увеличить время выполнения <code>git push</code> в зависимости от размера репозитория и количества отправляемых данных. Если вы хотите, чтобы Git проверял целостность объектов при каждой отправке данных, сделать это можно, установив <code>receive.fsckObjects</code> в true:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --system receive.fsckObjects true
</span></span></code></pre></div><p>Теперь Git, перед тем как принять новые данные от клиента, будет проверять целостность вашего репозитория, чтобы убедиться, что какой-нибудь неисправный клиент не внёс повреждённые данные.</p><h4 id=receivedenynonfastforwards class="relative group">receive.denyNonFastForwards <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#receivedenynonfastforwards aria-label=Якорь>#</a></span></h4><p>Если вы переместили с помощью команды <code>rebase</code> уже отправленные на сервер коммиты и затем пытаетесь отправить их снова или, иначе, пытаетесь отправить коммит в такую удалённую ветку, которая не содержит коммит, на который на текущий момент указывает удалённая ветка — вам будет в этом отказано. Обычно это хорошая стратегия. Но в случае если вы переместили коммиты, хорошо понимая, зачем это вам нужно, вы можете вынудить Git обновить удалённую ветку, передав команде <code>push</code> флаг <code>-f</code>.</p><p>Чтобы отключить возможность принудительного обновления веток, задайте <code>receive.denyNonFastForwards</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --system receive.denyNonFastForwards true
</span></span></code></pre></div><p>Есть ещё один способ сделать это — с помощью перехватчиков, работающих на приём (receive hooks), на стороне сервера, которые мы рассмотрим вкратце позднее. Такой подход позволит сделать более сложные вещи, такие как, например, запрет принудительных обновлений только для определённой группы пользователей.</p><h4 id=receivedenydeletes class="relative group">receive.denyDeletes <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#receivedenydeletes aria-label=Якорь>#</a></span></h4><p>Один из способов обойти политику <code>denyNonFastForwards</code> — это удалить ветку, а затем отправить новую ссылку на её место. В новых версиях Git&rsquo;а (начиная с версии 1.6.1) вы можете установить <code>receive.denyDeletes</code> в true:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --system receive.denyDeletes true
</span></span></code></pre></div><p>Этим вы запретите удаление веток и меток с помощью команды <code>push</code> для всех сразу — ни один из пользователей не сможет этого сделать. Чтобы удалить ветку на сервере, вам придётся удалить файлы ссылок с сервера вручную. Также есть и другие более интересные способы добиться этого, но уже для отдельных пользователей с помощью ACL (списков контроля доступа), как мы увидим в конце этой главы.</p><h2 id=git-атрибуты class="relative group">Git-атрибуты <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#git-%d0%b0%d1%82%d1%80%d0%b8%d0%b1%d1%83%d1%82%d1%8b aria-label=Якорь>#</a></span></h2><p>Некоторые настройки могут быть заданы для отдельных путей, и тогда Git будет применять их только для некоторых подкаталогов или набора файлов. Такие настройки, специфичные по отношению к путям, называются атрибутами и задаются либо в файле <code>.gitattributes</code> в одном из каталогов проекта (обычно в корне), либо в файле <code>.git/info/attributes</code>, если вы не хотите, чтобы файл с атрибутами попал в коммит вместе с остальными файлами проекта.</p><p>Использование атрибутов позволяет, например, задать разные стратегии слияния для отдельных файлов или каталогов проекта, или объяснить Git&rsquo;у, как сравнивать нетекстовые файлы, или сделать так, чтобы Git пропускал данные через фильтр перед тем, как выгрузить или записать данные в репозиторий. В этом разделе мы рассмотрим некоторые из доступных в Git&rsquo;е атрибутов и рассмотрим несколько практических примеров их использования.</p><h3 id=бинарные-файлы class="relative group">Бинарные файлы <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d1%8b%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d1%8b aria-label=Якорь>#</a></span></h3><p>Есть один клёвый трюк, для которого можно использовать атрибуты — можно указать Git&rsquo;у, какие файлы являются бинарными (в случае если по-другому определить это не получается), и дать ему специальные инструкции о том, как с этими файлами работать. Например, некоторые текстовые файлы могут быть машинными — генерируемыми программой — для них нет смысла вычислять дельты, в то время как для некоторых бинарных файлов получение дельт может быть полезным. Дальше мы увидим, как сказать Git&rsquo;у, какие файлы какие.</p><h4 id=определение-бинарных-файлов class="relative group">Определение бинарных файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d1%8b%d1%85-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h4><p>Некоторые файлы выглядят как текстовые, но по существу должны рассматриваться как бинарные данные. Например, проекты Xcode на Mac&rsquo;ах содержат файл, оканчивающийся на <code>.pbxproj</code>, который, по сути, является набором JSON-данных (текстовый формат данных для javascript), записываемым IDE, в котором сохраняются ваши настройки сборки и прочее. Хоть технически это и текстовый файл, потому что содержит только ASCII-символы, но нет смысла рассматривать его как таковой, потому что на самом деле это легковесная база данных — вы не сможете слить её содержимое, если два человека внесут в неё изменение, получение дельт тоже, как правило, ничем вам не поможет. Этот файл предназначается для обработки программой. По сути, лучше рассматривать этот файл как бинарный.</p><p>Чтобы заставить Git обращаться со всеми <code>pbxproj</code>-файлами как с бинарными, добавьте следующую строку в файл <code>.gitattributes</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*.pbxproj -crlf -diff
</span></span></code></pre></div><p>Теперь Git не будет пытаться конвертировать CRLF-концы строк или исправлять проблемы с ними. Также он не будет пытаться получить дельту для изменений в этом файле при запуске <code>git show</code> или <code>git diff</code> в вашем проекте. В Git&rsquo;е есть предустановленный макрос <code>binary</code>, который означает то же, что и <code>-crlf -diff</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*.pbxproj binary
</span></span></code></pre></div><h4 id=получение-дельты-для-бинарных-файлов class="relative group">Получение дельты для бинарных файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b5%d0%bb%d1%8c%d1%82%d1%8b-%d0%b4%d0%bb%d1%8f-%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d1%8b%d1%85-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h4><p>Функциональность атрибутов Git&rsquo;а может быть использована для эффективного получения дельт бинарных файлов. Сделать это можно, объяснив Git&rsquo;у, как сконвертировать ваши бинарные данные в текстовый формат, для которого можно выполнить сравнение с помощью обычного diff. Осталось только понять, как получить текстовое представление для <em>бинарных</em> данных. Идеальный вариант — найти подходящую утилиту для конвертирования нужного формата в текстовый вид. Но, к сожалению, получить хорошее текстовое представление можно только для весьма ограниченного набора бинарных форматов. Для большинства же бинарных форматов, например, для графических или аудио данных, получить читаемый текстовый вид не представляется возможным. Но если мы не можем получить текстовое представление содержимого, мы зачастую можем получить читаемое описание содержимого или метаданные. Метаданные не дают полное представление о содержимом файле, но, во всяком случае, это лучше чем ничего.</p><p>Далее мы рассмотрим оба подхода на примерах популярных бинарных форматов.</p><p>Замечание: Существуют разные виды бинарных файлов с текстовым содержимым, для которых вам, может быть, не удастся найти подходящий конвёртер. В данном случае вы можете попробовать вытащить текст с помощью утилиты <code>strings</code>. Некоторые из таких файлов могут использовать кодировку UTF-16 или могут быть написаны не в латинице, в таких файлах <code>strings</code> не найдёт ничего хорошего. Полезность <code>strings</code> может сильно варьироваться. Тем не менее, <code>strings</code> доступен на большинстве Mac- и Linux-систем, так что он может быть хорошим первым вариантом для того, чтобы сделать подобное со многими бинарными форматами.</p><h5 id=документы-ms-word class="relative group">Документы MS Word <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%be%d0%ba%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b-ms-word aria-label=Якорь>#</a></span></h5><p>Для начала мы используем описанный подход, чтобы решить одну из самых раздражающих проблем, известных человечеству: версионный контроль документов Word. Всем известно, что Word — это самый ужасающий из всех существующих редакторов, но, как ни странно, все им пользуются. Если вы хотите поместить документы Word под версионный контроль, вы можете запихнуть их в Git-репозиторий и время от времени делать коммиты. Но что в этом хорошего? Если вы запустите <code>git diff</code> как обычно, то увидите только что-то наподобие этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff 
</span></span><span style=display:flex><span>diff --git a/chapter1.doc b/chapter1.doc
</span></span><span style=display:flex><span>index 88839c4..4afcb7c <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>Binary files a/chapter1.doc and b/chapter1.doc differ
</span></span></code></pre></div><p>У вас не получится сравнить две версии между собой, только если вы не выгрузите их обе и просмотрите их вручную, так? Оказывается, можно сделать это достаточно успешно, используя атрибуты Git&rsquo;а. Поместите следующую строку в свой файл <code>.gitattributes</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*.doc diff<span style=color:#f92672>=</span>word
</span></span></code></pre></div><p>Она говорит Git&rsquo;у, что все файлы, соответствующие указанному шаблону (.doc) должны использовать фильтр &ldquo;word&rdquo; при попытке посмотреть дельту с изменениями. Что такое фильтр &ldquo;word&rdquo;? Нам нужно его изготовить. Сейчас мы настроим Git на использование программы <code>catdoc</code>, специально написанной для того, чтобы вытаскивать текстовую информацию из бинарных документов MS Word (скачать её можно по адресу <code>http://www.45.free.net/~vitus/software/catdoc/</code>), для конвертирования документов Word в читаемые текстовые файлы, которые Git затем правильно сравнит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config diff.word.textconv catdoc
</span></span></code></pre></div><p>Этой командой в свой <code>.git/config</code> вы добавите следующую секцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>diff <span style=color:#e6db74>&#34;word&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>	textconv <span style=color:#f92672>=</span> catdoc
</span></span></code></pre></div><p>Теперь Git знает, что если ему надо найти дельту между двумя снимками состояния, и какие-то их файлы заканчиваются на <code>.doc</code>, он должен прогнать эти файлы через фильтр &ldquo;word&rdquo;, который определён как программа <code>catdoc</code>. Так вы фактически сделаете текстовые версии своих Word-файлов перед тем, как получить для них дельту.</p><p>Рассмотрим пример. Я поместил главу 1 настоящей книги в Git, добавил немного текста в один параграф и сохранил документ. Затем я выполнил <code>git diff</code>, чтобы увидеть, что изменилось:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff
</span></span><span style=display:flex><span>diff --git a/chapter1.doc b/chapter1.doc
</span></span><span style=display:flex><span>index c1c8a0a..b93c9e4 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/chapter1.doc
</span></span><span style=display:flex><span>+++ b/chapter1.doc
</span></span><span style=display:flex><span>@@ -128,7 +128,7 @@ and data size<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> Since its birth in 2005, Git has evolved and matured to be easy to use
</span></span><span style=display:flex><span> and yet retain these initial qualities. It’s incredibly fast, it’s
</span></span><span style=display:flex><span> very efficient with large projects, and it has an incredible branching
</span></span><span style=display:flex><span>-system <span style=color:#66d9ef>for</span> non-linear development.
</span></span><span style=display:flex><span>+system <span style=color:#66d9ef>for</span> non-linear development <span style=color:#f92672>(</span>See Chapter 3<span style=color:#f92672>)</span>.
</span></span></code></pre></div><p>Git коротко и ясно дал мне знать, что я добавил строку &ldquo;(See Chapter 3)&rdquo;, так оно и есть. Работает идеально.</p><h5 id=текстовые-файлы-в-формате-opendocument class="relative group">Текстовые файлы в формате OpenDocument <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%82%d0%b5%d0%ba%d1%81%d1%82%d0%be%d0%b2%d1%8b%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d1%8b-%d0%b2-%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82%d0%b5-opendocument aria-label=Якорь>#</a></span></h5><p>Тот же подход, который мы использовали для файлов MS Word (<code>*.doc</code>), может быть использован и для текстовых файлов в формате OpenDocument, созданных в OpenOffice.org.</p><p>Добавим следующую строку в файл <code>.gitattributes</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*.odt diff<span style=color:#f92672>=</span>odt
</span></span></code></pre></div><p>Теперь настроим фильтр <code>odt</code> в <code>.git/config</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>diff <span style=color:#e6db74>&#34;odt&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>	binary <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>	textconv <span style=color:#f92672>=</span> /usr/local/bin/odt-to-txt
</span></span></code></pre></div><p>Файлы в формате OpenDocument на самом деле являются запакованными zip&rsquo;ом каталогами с множеством файлов (содержимое в XML-формате, таблицы стилей, изображения и т.д.). Мы напишем свой сценарий для извлечения содержимого и вывода его в виде обычного текста. Создайте файл <code>/usr/local/bin/odt-to-txt</code> (можете создать его в любом другом каталоге) со следующим содержимым:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#! /usr/bin/env perl
</span></span></span><span style=display:flex><span><span style=color:#75715e># Сценарий для конвертации OpenDocument Text (.odt) в обычный текст.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Автор: Philipp Kempgen</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>! defined<span style=color:#f92672>(</span>$ARGV<span style=color:#f92672>[</span>0<span style=color:#f92672>]))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	print STDERR <span style=color:#e6db74>&#34;Не задано имя файла!\n&#34;</span>;
</span></span><span style=display:flex><span>	print STDERR <span style=color:#e6db74>&#34;Использование: </span>$0<span style=color:#e6db74> имя файла\n&#34;</span>;
</span></span><span style=display:flex><span>	exit 1;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>my $content <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>open my $fh, <span style=color:#e6db74>&#39;-|&#39;</span>, <span style=color:#e6db74>&#39;unzip&#39;</span>, <span style=color:#e6db74>&#39;-qq&#39;</span>, <span style=color:#e6db74>&#39;-p&#39;</span>, $ARGV<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>, <span style=color:#e6db74>&#39;content.xml&#39;</span> or die $!;
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	local $/ <span style=color:#f92672>=</span> undef;  <span style=color:#75715e># считываем файл целиком</span>
</span></span><span style=display:flex><span>	$content <span style=color:#f92672>=</span> &lt;$fh&gt;;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>close $fh;
</span></span><span style=display:flex><span>$_ <span style=color:#f92672>=</span> $content;
</span></span><span style=display:flex><span>s/&lt;text:span<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;//g;           <span style=color:#75715e># удаляем span&#39;ы</span>
</span></span><span style=display:flex><span>s/&lt;text:h<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;/<span style=color:#ae81ff>\n\n</span>*****  /g;   <span style=color:#75715e># заголовки</span>
</span></span><span style=display:flex><span>s/&lt;text:list-item<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;<span style=color:#ae81ff>\s</span>*&lt;text:p<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;/<span style=color:#ae81ff>\n</span>    --  /g;  <span style=color:#75715e># элементы списков</span>
</span></span><span style=display:flex><span>s/&lt;text:list<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;/<span style=color:#ae81ff>\n\n</span>/g;       <span style=color:#75715e># списки</span>
</span></span><span style=display:flex><span>s/&lt;text:p<span style=color:#ae81ff>\b</span><span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>*&gt;/<span style=color:#ae81ff>\n</span>  /g;          <span style=color:#75715e># параграфы</span>
</span></span><span style=display:flex><span>s/&lt;<span style=color:#f92672>[</span>^&gt;<span style=color:#f92672>]</span>+&gt;//g;                      <span style=color:#75715e># удаляем все XML-теги</span>
</span></span><span style=display:flex><span>s/<span style=color:#ae81ff>\n</span><span style=color:#f92672>{</span>2,<span style=color:#f92672>}</span>/<span style=color:#ae81ff>\n\n</span>/g;                   <span style=color:#75715e># удаляем подряд идущие пустые строки</span>
</span></span><span style=display:flex><span>s/<span style=color:#ae81ff>\A\n</span>+//;                         <span style=color:#75715e># удаляем пустые строки в начале</span>
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#34;\n&#34;</span>, $_, <span style=color:#e6db74>&#34;\n\n&#34;</span>;
</span></span></code></pre></div><p>Сделайте его исполняемым</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x /usr/local/bin/odt-to-txt
</span></span></code></pre></div><p>Теперь <code>git diff</code> сможет сказать вам, что изменилось в <code>.odt</code> файлах.</p><h5 id=изображения class="relative group">Изображения <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b7%d0%be%d0%b1%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h5><p>Ещё одна интересная проблема, которую можно решить таким способом, это сравнение файлов изображений. Один из способов сделать это — прогнать PNG-файлы через фильтр, извлекающий их EXIF-информацию — метаданные, которые дописываются в большинство форматов изображений. Если скачаете и установите программу <code>exiftool</code>, то сможете воспользоваться ею, чтобы извлечь из изображений текстовую информацию о метаданных, так чтобы diff хоть как-то показал вам текстовое представление произошедших изменений:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;*.png diff=exif&#39;</span> &gt;&gt; .gitattributes
</span></span><span style=display:flex><span>$ git config diff.exif.textconv exiftool
</span></span></code></pre></div><p>Если вы замените в проекте изображение и запустите <code>git diff</code>, то получите что-то вроде такого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>diff --git a/image.png b/image.png
</span></span><span style=display:flex><span>index 88839c4..4afcb7c <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/image.png
</span></span><span style=display:flex><span>+++ b/image.png
</span></span><span style=display:flex><span>@@ -1,12 +1,12 @@
</span></span><span style=display:flex><span> ExifTool Version Number         : 7.74
</span></span><span style=display:flex><span>-File Size                       : <span style=color:#ae81ff>70</span> kB
</span></span><span style=display:flex><span>-File Modification Date/Time     : 2009:04:17 10:12:35-07:00
</span></span><span style=display:flex><span>+File Size                       : <span style=color:#ae81ff>94</span> kB
</span></span><span style=display:flex><span>+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
</span></span><span style=display:flex><span> File Type                       : PNG
</span></span><span style=display:flex><span> MIME Type                       : image/png
</span></span><span style=display:flex><span>-Image Width                     : <span style=color:#ae81ff>1058</span>
</span></span><span style=display:flex><span>-Image Height                    : <span style=color:#ae81ff>889</span>
</span></span><span style=display:flex><span>+Image Width                     : <span style=color:#ae81ff>1056</span>
</span></span><span style=display:flex><span>+Image Height                    : <span style=color:#ae81ff>827</span>
</span></span><span style=display:flex><span> Bit Depth                       : <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span> Color Type                      : RGB with Alpha
</span></span></code></pre></div><p>Легко можно заметить, что размер файла, а также высота и ширина изображения поменялись.</p><h3 id=развёртывание-ключа class="relative group">Развёртывание ключа <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%80%d0%b0%d0%b7%d0%b2%d1%91%d1%80%d1%82%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0 aria-label=Якорь>#</a></span></h3><p>Разработчики, привыкшие к SVN или CVS, часто хотят получить в Git&rsquo;е возможность развёртывания ключа в стиле этих систем. Основная проблема с реализацией этой функциональности в Git&rsquo;е это то, что нельзя записать в файл информацию о коммите после того, как коммит был сделан, так как Git сначала считает контрольную сумму для файла. Несмотря на это, вы можете вставлять текст в файл во время его выгрузки и удалять его перед добавлением в коммит. Атрибуты Git&rsquo;а предлагают два варианта сделать это.</p><p>Во-первых, вы можете внедрять SHA-1-сумму блоба в поле <code>$Id$</code> в файл автоматически. Если установить соответствующий атрибут для одного или нескольких файлов, то в следующий раз, когда вы будете выгружать данные из этой ветки, Git будет заменять это поле SHA-суммой блоба. Обратите внимание, что это SHA-1 не коммита, а самого блоба.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;*.txt ident&#39;</span> &gt;&gt; .gitattributes
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;$Id$&#39;</span> &gt; test.txt
</span></span><span style=display:flex><span>$ git add test.txt
</span></span></code></pre></div><p>В следующий раз, когда вы будете выгружать этот файл, Git автоматически вставит в него SHA его блоба:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ rm test.txt
</span></span><span style=display:flex><span>$ git checkout -- test.txt
</span></span><span style=display:flex><span>$ cat test.txt 
</span></span><span style=display:flex><span>$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
</span></span></code></pre></div><p>Однако, такой результат мало применим. Если вы раньше пользовались развёртыванием ключа в CVS или Subversion, можете добавлять метку даты — SHA не особенно полезен, так как он довольно случаен, и к тому же, глядя на две SHA-суммы, никак не определить какая из них новее.</p><p>Как оказывается, можно написать свои собственные фильтры, которые будут делать подстановки в файлах при коммитах и выгрузке файлов. Для этого надо задать фильтры &ldquo;clean&rdquo; и &ldquo;smudge&rdquo;. В файле <code>.gitattributes</code> можно задать фильтр для определённых путей и затем установить сценарии, которые будут обрабатывать файлы непосредственно перед выгрузкой (&ldquo;smudge&rdquo;, см. рис. 3-3) и прямо перед коммитом (&ldquo;clean&rdquo;, см. рис. 3-4). Эти фильтры можно настроить на совершение абсолютно любых действий.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0702-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-3. Фильтр “smudge” выполняется при checkout.</p></blockquote><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0703-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-4. Фильтр “clean” выполняется при помещении файлов в индекс.</p></blockquote><p>В сообщении первоначального коммита, добавляющего эту функциональность, дан простой пример того, как можно пропустить весь свой исходный код на C через программу <code>indent</code> перед коммитом. Сделать это можно, задав атрибут filter в файле <code>.gitattributes</code> так, чтобы он пропускал файлы <code>*.c</code> через фильтр &ldquo;indent&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>*.c     filter<span style=color:#f92672>=</span>indent
</span></span></code></pre></div><p>Затем укажите Git&rsquo;у, что должен делать фильтр &ldquo;indent&rdquo; при smudge и clean:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global filter.indent.clean indent
</span></span><span style=display:flex><span>$ git config --global filter.indent.smudge cat
</span></span></code></pre></div><p>В нашем случае, когда вы будете делать коммит, содержащий файлы, соответствующие шаблону <code>*.c</code>, Git прогонит их через программу <code>indent</code> перед коммитом, а потом через программу <code>cat</code> перед тем как выгрузить их на диск. Программа <code>cat</code>, по сути, является холостой — она выдаёт те же данные, которые получила. Фактически эта комбинация профильтровывает все файлы с исходным кодом на C через <code>indent</code> перед тем, как сделать коммит.</p><p>Ещё один интересный пример — это развёртывание ключа <code>$Date$</code> в стиле RCS. Чтобы сделать его правильно, нам понадобится небольшой сценарий, который принимает на вход имя файла, определяет дату последнего коммита в проекте и вставляет эту дату в наш файл. Вот небольшой сценарий на Ruby, который делает именно это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#! /usr/bin/env ruby
</span></span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> STDIN.read
</span></span><span style=display:flex><span>last_date <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git log --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#34;%ad&#34;</span> -1<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>puts data.gsub<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;$Date$&#39;</span>, <span style=color:#e6db74>&#39;$Date: &#39;</span> + last_date.to_s + <span style=color:#e6db74>&#39;$&#39;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Всё, что делает этот сценарий, это получает дату последнего коммита с помощью команды <code>git log</code>, засовывает её во все строки <code>$Date$</code>, которые видит в stdin, и выводит результат — такое должно быть несложно реализовать на любом удобном вам языке. Давайте назовём этот файл <code>expand_date</code> и поместим в путь. Теперь в Git&rsquo;е необходимо настроить фильтр (назовём его <code>dater</code>) и указать, что надо использовать фильтр <code>expand_date</code> при выполнении smudge во время выгрузки файлов. Воспользуемся регулярным выражением Perl, чтобы убрать изменения при коммите:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config filter.dater.smudge expand_date
</span></span><span style=display:flex><span>$ git config filter.dater.clean <span style=color:#e6db74>&#39;perl -pe &#34;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&#34;&#39;</span>
</span></span></code></pre></div><p>Этот фрагмент кода на Perl&rsquo;е вырезает всё, что находит в строке <code>$Date$</code> так, чтобы вернуть всё в начальное состояние. Теперь, когда наш фильтр готов, можете протестировать его, создав файл с ключом <code>$Date$</code> и установив для этого файла Git-атрибут, который задействует для него новый фильтр:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;# $Date$&#39;</span> &gt; date_test.txt
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;date*.txt filter=dater&#39;</span> &gt;&gt; .gitattributes
</span></span></code></pre></div><p>Если мы сейчас добавим эти изменения в коммит и снова выгрузим файл, то мы увидим, что ключевое слово было заменено правильно:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add date_test.txt .gitattributes
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#34;Testing date expansion in Git&#34;</span>
</span></span><span style=display:flex><span>$ rm date_test.txt
</span></span><span style=display:flex><span>$ git checkout date_test.txt
</span></span><span style=display:flex><span>$ cat date_test.txt
</span></span><span style=display:flex><span><span style=color:#75715e># $Date: Tue Apr 21 07:26:52 2009 -0700$</span>
</span></span></code></pre></div><p>Как видите, такая техника может быть весьма мощной для настройки проекта под свои нужды. Но вы должны быть осторожны, ибо файл <code>.gitattributes</code> вы добавите в коммит и будете его распространять вместе с проектом, а драйвер (в нашем случае <code>dater</code>) — нет. Так что не везде оно будет работать. Когда будете проектировать свои фильтры, постарайтесь сделать так, чтобы при возникновении в них ошибки проект не переставал работать правильно.</p><h3 id=экспорт-репозитория class="relative group">Экспорт репозитория <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%8d%d0%ba%d1%81%d0%bf%d0%be%d1%80%d1%82-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Ещё атрибуты в Git&rsquo;е позволяют делать некоторые интересные вещи при экспортировании архива с проектом.</p><h4 id=export-ignore class="relative group">export-ignore <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#export-ignore aria-label=Якорь>#</a></span></h4><p>Вы можете попросить Git не экспортировать определённые файлы и каталоги при создании архива. Если у вас есть подкаталог или файл, который вы не желаете включать в архив, но хотите, чтобы в проекте он был, можете установить для такого файла атрибут <code>export-ignore</code>.</p><p>Например, скажем, у вас в подкаталоге <code>test/</code> имеются некоторые тестовые файлы, и нет никакого смысла добавлять их в тарбол при экспорте проекта. Тогда добавим следующую строку в файл с Git-атрибутами:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>test/ export-ignore
</span></span></code></pre></div><p>Теперь, если вы запустите <code>git archive</code>, чтобы создать тарбол с проектом, этот каталог в архив включён не будет.</p><h4 id=export-subst class="relative group">export-subst <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#export-subst aria-label=Якорь>#</a></span></h4><p>Ещё одна вещь, которую можно сделать с архивами, — это сделать какую-нибудь простую подстановку ключевых слов. Git позволяет добавить в любой файл строку вида <code>$Format:$</code> с любыми кодами форматирования, доступными в <code>--pretty=format</code> (многие из этих кодов мы рассматривали в главе 2). Например, если вам захотелось добавить в проект файл с именем <code>LAST_COMMIT</code>, в который при запуске <code>git archive</code> будет автоматически помещаться дата последнего коммита, то такой файл вы можете сделать следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;Last commit date: $Format:%cd$&#39;</span> &gt; LAST_COMMIT
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#34;LAST_COMMIT export-subst&#34;</span> &gt;&gt; .gitattributes
</span></span><span style=display:flex><span>$ git add LAST_COMMIT .gitattributes
</span></span><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;adding LAST_COMMIT file for archives&#39;</span>
</span></span></code></pre></div><p>После запуска <code>git archive</code> этот файл у вас в архиве будет иметь содержимое следующего вида:</p><pre><code>$ cat LAST_COMMIT
Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$
</code></pre><h3 id=стратегии-слияния class="relative group">Стратегии слияния <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%82%d1%80%d0%b0%d1%82%d0%b5%d0%b3%d0%b8%d0%b8-%d1%81%d0%bb%d0%b8%d1%8f%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Атрибуты Git&rsquo;а могут также быть использованы для того, чтобы попросить Git использовать другие стратегии слияния для определённых файлов в проекте. Одна очень полезная возможность — это сказать Git&rsquo;у, чтобы он не пытался слить некоторые файлы, если для них есть конфликт, а просто выбрал ваш вариант, предпочтя его чужому.</p><p>Это полезно в том случае, если ветка в вашем проекте разошлась с исходной, но вам всё же хотелось бы иметь возможность слить изменения из неё обратно, проигнорировав некоторые файлы. Скажем, у вас есть файл с настройками базы данных, который называется database.xml, и в двух ветках он разный, и вы хотите влить другую свою ветку, не трогая файл с настройками базы данных. Задайте атрибут следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>database.xml merge<span style=color:#f92672>=</span>ours
</span></span></code></pre></div><p>При вливании другой ветки, вместо конфликтов слияния для файла database.xml, вы увидите следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git merge topic
</span></span><span style=display:flex><span>Auto-merging database.xml
</span></span><span style=display:flex><span>Merge made by recursive.
</span></span></code></pre></div><p>В данном случае database.xml остался в том варианте, в каком и был изначально.</p><h2 id=перехватчики-в-git class="relative group">Перехватчики в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%b2-git aria-label=Якорь>#</a></span></h2><p>Как и во многих других системах контроля версий, в Git&rsquo;е есть возможность запускать собственные сценарии в те моменты, когда происходят некоторые важные действия. Существуют две группы подобных перехватчиков (hook): на стороне клиента и на стороне сервера. Перехватчики на стороне клиента предназначены для клиентских операций, таких как создание коммита и слияние. Перехватчики на стороне сервера нужны для серверных операций, таких как приём отправленных коммитов. Перехватчики могут быть использованы для выполнения самых различных задач. О некоторых из таких задач мы и поговорим.</p><h3 id=установка-перехватчика class="relative group">Установка перехватчика <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b0 aria-label=Якорь>#</a></span></h3><p>Все перехватчики хранятся в подкаталоге <code>hooks</code> в Git-каталоге. В большинстве проектов это <code>.git/hooks</code>. По умолчанию Git заполняет этот каталог кучей примеров сценариев, многие из которых полезны сами по себе, но кроме того в них задокументированы входные значения для каждого из сценариев. Все эти примеры являются сценариями для командной оболочки с вкраплениями Perl&rsquo;а, но вообще-то будет работать любой исполняемый сценарий с правильным именем — вы можете писать их на Ruby или Python или на чём-то ещё, что вам нравится. Эти файлы с примерами перехватчиков оканчиваются на .sample; вам надо их переименовать.</p><p>Чтобы активировать сценарий-перехватчик, положите файл в подкаталог <code>hooks</code> в Git-каталоге, дайте ему правильное имя и права на исполнение. С этого момента он будет вызываться. Основные имена перехватчиков мы сейчас рассмотрим.</p><h3 id=перехватчики-на-стороне-клиента class="relative group">Перехватчики на стороне клиента <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%bd%d0%b0-%d1%81%d1%82%d0%be%d1%80%d0%be%d0%bd%d0%b5-%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82%d0%b0 aria-label=Якорь>#</a></span></h3><p>Существует множество перехватчиков, работающих на стороне клиента. В этом разделе они поделены на перехватчики, используемые при работе над коммитами, сценарии, используемые в процессе работы с электронными письмами, и все остальные, работающие на стороне клиента.</p><h4 id=перехватчики-для-работы-с-коммитами class="relative group">Перехватчики для работы с коммитами <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%b4%d0%bb%d1%8f-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b-%d1%81-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%b0%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h4><p>Первые четыре перехватчика относятся к процессу создания коммита. Перехватчик <code>pre-commit</code> запускается первым, ещё до того, как вы наберёте сообщение коммита. Его используют для проверки снимка состояния перед тем, как сделать коммит, чтобы проверить, не забыли ли вы что-нибудь, чтобы убедиться, что вы запустили тесты, или проверить в коде ещё что-нибудь, что вам нужно. Завершение перехватчика с ненулевым кодом прерывает создание коммита, хотя вы можете обойти это с помощью <code>git commit --no-verify</code>. Можно, например, проверить стиль кодирования (запускать lint или что-нибудь аналогичное), проверить наличие пробельных символов в конце строк (перехватчик по умолчанию занимается именно этим) или проверить наличие необходимой документации для новых методов.</p><p>Перехватчик <code>prepare-commit-msg</code> запускается до появления редактора с сообщением коммита, но после создания сообщения по умолчанию. Он позволяет отредактировать сообщение по умолчанию перед тем, как автор коммита его увидит. У этого перехватчика есть несколько опций: путь к файлу, в котором сейчас хранится сообщение коммита, тип коммита и SHA-1 коммита (если в коммит вносится правка с помощью <code>git commit --amend</code>). Как правило, данный перехватчик не представляет пользы для обычных коммитов; он скорее хорош для коммитов с автогенерируемыми сообщениями, такими как шаблонные сообщения коммитов, коммиты-слияния, уплотнённые коммиты (squashed commits) и коммиты c исправлениями (amended commits). Данный перехватчик можно использовать в связке с шаблоном для коммита, чтобы программно добавлять в него информацию.</p><p>Перехватчик <code>commit-msg</code> принимает один параметр, и снова это путь к временному файлу, содержащему текущее сообщение коммита. Когда сценарий завершается с ненулевым кодом, Git прерывает процесс создания коммита. Так что можно использовать его для проверки состояния проекта или сообщений коммита перед тем, как его одобрить. В последнем разделе главы я продемонстрирую, как использовать данный перехватчик, чтобы проверить, что сообщение коммита соответствует требуемому шаблону.</p><p>После того, как весь процесс создания коммита завершён, запускается перехватчик <code>post-commit</code>. Он не принимает никаких параметров, но вы с лёгкостью можете получить последний коммит, выполнив <code>git log -1 HEAD</code>. Как правило, этот сценарий используется для уведомлений или чего-то в этом роде.</p><p>Сценарии на стороне клиента, предназначенные для запуска во время работы над коммитами, могут быть использованы при осуществлении практически любого типа рабочего процесса. Их часто используют, чтобы обеспечить соблюдение определённых стандартов, хотя важно отметить, что данные сценарии не передаются при клонировании. Вы можете принудить к соблюдению правил на стороне сервера, отвергая присланные коммиты, если они не подчиняются некоторым правилам, но использование данных сценариев на клиентской стороне полностью зависит только от разработчика. Итак, эти сценарии призваны помочь разработчикам, и это обязанность разработчиков установить и сопровождать их, хотя разработчики и имеют возможность в любой момент подменить их или модифицировать.</p><h4 id=перехватчики-для-работы-с-e-mail class="relative group">Перехватчики для работы с e-mail <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%b4%d0%bb%d1%8f-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b-%d1%81-e-mail aria-label=Якорь>#</a></span></h4><p>Для рабочих процессов, основанных на электронной почте, есть три специальных клиентских перехватчика. Все они вызываются командой <code>git am</code>, так что, если вы не пользуетесь этой командой в процессе своей работы, то можете смело переходить к следующему разделу. Если вы принимаете патчи, отправленные по e-mail и подготовленные с помощью <code>git format-patch</code>, то некоторые из них могут оказаться для вас полезными.</p><p>Первый запускаемый перехватчик — это <code>applypatch-msg</code>. Он принимает один аргумент — имя временного файла, содержащего предлагаемое сообщение коммита. Git прерывает наложение патча, если сценарий завершается с ненулевым кодом. Это может быть использовано для того, чтобы убедиться, что сообщение коммита правильно отформатировано или, чтобы нормализовать сообщение, отредактировав его на месте из сценария.</p><p>Следующий перехватчик, запускаемый во время наложения патчей с помощью <code>git am</code> — это <code>pre-applypatch</code>. У него нет аргументов, и он запускается после того, как патч наложен, поэтому его можно использовать для проверки снимка состояния перед созданием коммита. Можно запустить тесты или как-то ещё проверить рабочее дерево с помощью этого сценария. Если чего-то не хватает, или тесты не пройдены, выход с ненулевым кодом так же завершает сценарий <code>git am</code> без применения патча.</p><p>Последний перехватчик, запускаемый во время работы <code>git am</code> — это <code>post-applypatch</code>. Его можно использовать для уведомления группы или автора патча о том, что вы его применили. Этим сценарием процесс наложения патча остановить уже нельзя.</p><h4 id=другие-клиентские-перехватчики class="relative group">Другие клиентские перехватчики <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d1%80%d1%83%d0%b3%d0%b8%d0%b5-%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82%d1%81%d0%ba%d0%b8%d0%b5-%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h4><p>Перехватчик <code>pre-rebase</code> запускается перед перемещением чего-либо, и может остановить процесс перемещения, если завершится с ненулевым кодом. Этот перехватчик можно использовать, чтобы запретить перемещение любых уже отправленных коммитов. Пример перехватчика <code>pre-rebase</code>, устанавливаемый Git&rsquo;ом, это и делает, хотя он предполагает, что ветка, в которой вы публикуете свои изменения, называется next. Вам, скорее всего, нужно будет заменить это имя на имя своей публичной стабильной ветки.</p><p>После успешного выполнения команды <code>git checkout</code>, запускается перехватчик <code>post-checkout</code>. Его можно использовать для того, чтобы правильно настроить рабочий каталог для своей проектной среды. Под этим может подразумеваться, например, перемещение в каталог больших бинарных файлов, которые вам не хочется включать под версионный контроль, автоматическое генерирование документации или что-то ещё в таком же духе.</p><p>И наконец, перехватчик <code>post-merge</code> запускается после успешного выполнения команды <code>merge</code>. Его можно использовать для восстановления в рабочем дереве данных, которые Git не может отследить, таких как информация о правах. Этот перехватчик может также проверить наличие внешних по отношению к контролируемым Git&rsquo;ом файлов, которые вам нужно скопировать в каталог при изменениях рабочего дерева.</p><h3 id=перехватчики-на-стороне-сервера class="relative group">Перехватчики на стороне сервера <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%bd%d0%b0-%d1%81%d1%82%d0%be%d1%80%d0%be%d0%bd%d0%b5-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b0 aria-label=Якорь>#</a></span></h3><p>В дополнение к перехватчикам на стороне клиента вы как системный администратор можете задействовать пару важных перехватчиков на стороне сервера, чтобы навязать в своём проекте правила практически любого вида. Эти сценарии выполняются до и после отправки данных на сервер. Pre-перехватчики могут быть в любое время завершены с ненулевым кодом, чтобы отклонить присланные данные, а также вывести клиенту обратно сообщение об ошибке. Вы можете установить настолько сложные правила приёма данных, насколько захотите.</p><h4 id=pre-receive-и-post-receive class="relative group">pre-receive и post-receive <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pre-receive-%d0%b8-post-receive aria-label=Якорь>#</a></span></h4><p>Первый сценарий, который выполняется при обработке отправленных клиентом данных, — это <code>pre-receive</code>. Он принимает на вход из stdin список отправленных ссылок; если он завершается с ненулевым кодом, ни одна из них не будет принята. Этот перехватчик можно использовать, чтобы, например, убедиться, что ни одна из обновлённых ссылок не выполняет ничего кроме перемотки, или, чтобы убедиться, что пользователь, запустивший <code>git push</code>, имеет права на создание, удаление или изменение для всех файлов, модифицируемых этим push&rsquo;ем.</p><p>Перехватчик <code>post-receive</code> запускается после того, как весь процесс завершился, и может быть использован для обновления других сервисов или уведомления пользователей. Он получает на вход из stdin те же данные, что и перехватчик <code>pre-receive</code>. Примерами использования могут быть: отправка писем в рассылку, уведомление сервера непрерывной интеграции или обновление карточки (ticket) в системе отслеживания ошибок — вы можете даже анализировать сообщения коммитов, чтобы выяснить, нужно ли открыть, изменить или закрыть какие-то карточки. Этот сценарий не сможет остановить процесс приёма данных, но клиент не будет отключён до тех пор, пока процесс не завершится; так что будьте осторожны, если хотите сделать что-то, что может занять много времени.</p><h4 id=update class="relative group">update <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#update aria-label=Якорь>#</a></span></h4><p>Сценарий <code>update</code> очень похож на сценарий <code>pre-receive</code>, за исключением того, что он выполняется для каждой ветки, которую отправитель данных пытается обновить. Если отправитель пытается обновить несколько веток, то <code>pre-receive</code> выполнится только один раз, в то время как <code>update</code> выполнится по разу для каждой обновляемой ветки. Сценарий не считывает параметры из stdin, а принимает на вход три аргумента: имя ссылки (ветки), SHA-1, на которую ссылка указывала до запуска <code>push</code>, и тот SHA-1, который пользователь пытается отправить. Если сценарий <code>update</code> завершится с ненулевым кодом, то только одна ссылка будет отклонена, остальные ссылки всё ещё смогут быть обновлены.</p><h2 id=пример-навязывания-политики-с-помощью-git class="relative group">Пример навязывания политики с помощью Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80-%d0%bd%d0%b0%d0%b2%d1%8f%d0%b7%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%bf%d0%be%d0%bb%d0%b8%d1%82%d0%b8%d0%ba%d0%b8-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-git aria-label=Якорь>#</a></span></h2><p>В этом разделе мы используем ранее полученные знания для организации в Git&rsquo;е такого рабочего процесса, который проверяет сообщения коммитов на соответствие заданному формату, из обновлений разрешает только перемотки и позволяет только определённым пользователям изменять определённые подкаталоги внутри проекта. Мы создадим клиентские сценарии, которые помогут разработчикам узнать, будет ли их push отклонён, и серверные сценарии, которые будут действительно вынуждать следовать установленным правилам.</p><p>Для их написания я использовал Ruby, и потому что это мой любимый язык сценариев, и потому что из всех языков сценариев он больше всего похож на псевдокод; таким образом, код должен быть вам понятен в общих чертах, даже если вы не пользуетесь Ruby. Однако любой язык сгодится. Все примеры перехватчиков, распространяемые вместе с Git&rsquo;ом, написаны либо на Perl, либо на Bash, так что вы сможете просмотреть достаточно примеров перехватчиков на этих языках, заглянув в примеры.</p><h3 id=перехватчик-на-стороне-сервера class="relative group">Перехватчик на стороне сервера <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba-%d0%bd%d0%b0-%d1%81%d1%82%d0%be%d1%80%d0%be%d0%bd%d0%b5-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b0 aria-label=Якорь>#</a></span></h3><p>Вся работа для сервера будет осуществляться в файле <code>update</code> из каталога <code>hooks</code>. Файл <code>update</code> запускается по разу для каждой отправленной ветки и принимает на вход ссылку, в которую сделано отправление, старую версию, на которой ветка находилась раньше, и новую присланную версию. Кроме того, вам будет доступно имя пользователя, приславшего данные, если <code>push</code> был выполнен по SSH. Если вы позволили подключаться всем под одним пользователем (например, &ldquo;git&rdquo;) с аутентификацией по открытому ключу, то вам может понадобиться создать для этого пользователя обёртку командной оболочки, которая на основе открытого ключа будет определять, какой пользователь осуществил подключение, и записывать этого пользователя в какой-нибудь переменной окружения. Тут я буду предполагать, что имя подключившегося пользователя находится в переменной окружения <code>$USER</code>, так что начнём наш сценарий со сбора всей необходимой информации:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env ruby
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$refname <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$oldrev  <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$newrev  <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$user    <span style=color:#f92672>=</span> ENV<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;USER&#39;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>puts <span style=color:#e6db74>&#34;Enforcing Policies... \n(#{</span>$refname<span style=color:#e6db74>}) (#{</span>$oldrev<span style=color:#e6db74>[0,6]}) (#{</span>$newrev<span style=color:#e6db74>[0,6]})&#34;</span>
</span></span></code></pre></div><p>Да, я использую глобальные переменные. Не судите строго — в таком виде получается нагляднее.</p><h4 id=установка-особого-формата-сообщений-коммитов class="relative group">Установка особого формата сообщений коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%be%d1%81%d0%be%d0%b1%d0%be%d0%b3%d0%be-%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82%d0%b0-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d0%b9-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h4><p>Первая наша задача — это заставить все сообщения коммитов обязательно придерживаться определённого формата. Просто чтобы было чем заняться, предположим, что каждое сообщение должно содержать строку вида &ldquo;ref: 1234&rdquo;, так как мы хотим, чтобы каждый коммит был связан с некоторым элементом в нашей системе с карточками. Нам необходимо просмотреть все присланные коммиты, выяснить, есть ли такая строка в сообщении коммита, и, если строка отсутствует в каком-либо из этих коммитов, то завершить сценарий с ненулевым кодом, чтобы <code>push</code> был отклонён.</p><p>Список значений SHA-1 для всех присланных коммитов можно получить, взяв значения <code>$newrev</code> и <code>$oldrev</code> и передав их служебной команде <code>git rev-list</code>. По сути, это команда <code>git log</code>, но по умолчанию она выводит только SHA-1 значения и больше ничего. Таким образом, чтобы получить список SHA для всех коммитов, сделанных между одним SHA коммита и другим, достаточно выполнить следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rev-list 538c33..d14fc7
</span></span><span style=display:flex><span>d14fc7c847ab946ec39590d87783c69b031bdfb7
</span></span><span style=display:flex><span>9f585da4401b0a3999e84113824d15245c13f0be
</span></span><span style=display:flex><span>234071a1be950e2a8d078e6141f5cd20c1e61ad3
</span></span><span style=display:flex><span>dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
</span></span><span style=display:flex><span>17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
</span></span></code></pre></div><p>Можно взять этот вывод, пройти в цикле по SHA-хешам всех этих коммитов, беря их сообщения и проверяя с помощью регулярного выражения, совпадает ли сообщение с шаблоном.</p><p>Нам нужно выяснить, как из всех этих коммитов получить их сообщения, для того, чтобы их протестировать. Чтобы получить данные коммита в сыром виде, можно воспользоваться ещё одной служебной командой, которая называется <code>git cat-file</code>. Мы рассмотрим все эти служебные команды более подробно в главе 9, но пока что, вот, что эта команда нам выдала:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file commit ca82a6
</span></span><span style=display:flex><span>tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
</span></span><span style=display:flex><span>parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>author Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1205815931</span> -0700
</span></span><span style=display:flex><span>committer Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1240030591</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>changed the version number
</span></span></code></pre></div><p>Простой способ получить сообщение коммита для коммита, чьё значение SHA-1 известно, — это дойти в выводе команды <code>git cat-file</code> до первой пустой строки и взять всё, что идёт после неё. В Unix-системах это можно сделать с помощью команды <code>sed</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file commit ca82a6 | sed <span style=color:#e6db74>&#39;1,/^$/d&#39;</span>
</span></span><span style=display:flex><span>changed the version number
</span></span></code></pre></div><p>Используйте приведённую ниже абракадабру, чтобы получить для каждого отправленного коммита его сообщение и выйти, если обнаружится, что что-то не соответствует требованиям. Если хотим отклонить отправленные данные, выходим с ненулевым кодом. Весь метод целиком выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$regex <span style=color:#f92672>=</span> /<span style=color:#ae81ff>\[</span>ref: <span style=color:#f92672>(</span><span style=color:#ae81ff>\d</span>+<span style=color:#f92672>)</span><span style=color:#ae81ff>\]</span>/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># принуждает использовать особый формат сообщений</span>
</span></span><span style=display:flex><span>def check_message_format
</span></span><span style=display:flex><span>  missed_revs <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git rev-list <span style=color:#75715e>#{$oldrev}..#{$newrev}`.split(&#34;\n&#34;)</span>
</span></span><span style=display:flex><span>  missed_revs.each <span style=color:#66d9ef>do</span> |rev|
</span></span><span style=display:flex><span>    message <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git cat-file commit <span style=color:#75715e>#{rev} | sed &#39;1,/^$/d&#39;`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !$regex.match<span style=color:#f92672>(</span>message<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      puts <span style=color:#e6db74>&#34;[POLICY] Your message is not formatted correctly&#34;</span>
</span></span><span style=display:flex><span>      exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>check_message_format
</span></span></code></pre></div><p>Добавив это в свой сценарий <code>update</code>, мы запретим обновления, содержащие коммиты, сообщения которых не соблюдают наше правило.</p><h4 id=настройка-системы-контроля-доступа-для-пользователей class="relative group">Настройка системы контроля доступа для пользователей <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d1%8b-%d0%ba%d0%be%d0%bd%d1%82%d1%80%d0%be%d0%bb%d1%8f-%d0%b4%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%b0-%d0%b4%d0%bb%d1%8f-%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d0%b5%d0%bb%d0%b5%d0%b9 aria-label=Якорь>#</a></span></h4><p>Предположим, что нам хотелось бы добавить какой-нибудь механизм для использования списков контроля доступа (ACL), где указано, какие пользователи могут отправлять изменения и в какие части проекта. Несколько людей будут иметь полный доступ, а остальные будут иметь доступ на изменение только некоторых подкаталогов или отдельных файлов. Чтобы обеспечить выполнение такой политики, мы запишем правила в файл <code>acl</code>, который будет находиться в нашем &ldquo;голом&rdquo; репозитории на сервере. Нам нужно будет, чтобы перехватчик <code>update</code> брал эти правила, смотрел на то, какие файлы были изменены присланными коммитами, и определял, имеет ли пользователь, выполнивший <code>push</code>, право на обновление всех этих файлов.</p><p>Первое, что мы сделаем, — это напишем свой ACL. Мы сейчас будем использовать формат, очень похожий на механизм ACL в CVS. В нём используется последовательность строк, где первое поле — это <code>avail</code> или <code>unavail</code>, следующее поле — это разделённый запятыми список пользователей, для которых применяется правило, и последнее поле — это путь, к которому применяется правило (пропуск здесь означает открытый доступ). Все эти поля разделяются вертикальной чертой (<code>|</code>).</p><p>В нашем примере будет несколько администраторов, сколько-то занимающихся написанием документации с доступом к каталогу <code>doc</code> и один разработчик, который имеет доступ только к каталогам <code>lib</code> и <code>tests</code>, и наш файл <code>acl</code> будет выглядеть так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>avail|nickh,pjhyett,defunkt,tpw
</span></span><span style=display:flex><span>avail|usinclair,cdickens,ebronte|doc
</span></span><span style=display:flex><span>avail|schacon|lib
</span></span><span style=display:flex><span>avail|schacon|tests
</span></span></code></pre></div><p>Начнём со считывания этих данных в какую-нибудь пригодную для использования структуру. В нашем случае, чтобы не усложнять пример, мы будем применять только директивы <code>avail</code>. Вот метод, который даёт нам ассоциативный массив, где ключом является имя пользователя, а значением — массив путей, для которых пользователь имеет доступ на запись:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>def get_acl_access_data<span style=color:#f92672>(</span>acl_file<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># считывание данных ACL</span>
</span></span><span style=display:flex><span>  acl_file <span style=color:#f92672>=</span> File.read<span style=color:#f92672>(</span>acl_file<span style=color:#f92672>)</span>.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span><span style=color:#f92672>)</span>.reject <span style=color:#f92672>{</span> |line| line <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  access <span style=color:#f92672>=</span> <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>  acl_file.each <span style=color:#66d9ef>do</span> |line|
</span></span><span style=display:flex><span>    avail, users, path <span style=color:#f92672>=</span> line.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;|&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    next unless avail <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;avail&#39;</span>
</span></span><span style=display:flex><span>    users.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;,&#39;</span><span style=color:#f92672>)</span>.each <span style=color:#66d9ef>do</span> |user|
</span></span><span style=display:flex><span>      access<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span> <span style=color:#f92672>||=</span> <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>      access<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span> &lt;&lt; path
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>  access
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><p>Для рассмотренного ранее ACL-файла, метод <code>get_acl_access_data</code> вернёт структуру данных следующего вида:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;defunkt&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span>nil<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;tpw&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span>nil<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;nickh&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span>nil<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;pjhyett&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span>nil<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;schacon&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;lib&#34;</span>, <span style=color:#e6db74>&#34;tests&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;cdickens&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;doc&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;usinclair&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;doc&#34;</span><span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;ebronte&#34;</span><span style=color:#f92672>=</span>&gt;<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;doc&#34;</span><span style=color:#f92672>]}</span>
</span></span></code></pre></div><p>Теперь, когда мы разобрались с правами, нам нужно выяснить, какие пути изменяются присланными коммитами, чтобы можно было убедиться, что пользователь, выполнивший <code>push</code>, имеет ко всем ним доступ.</p><p>Мы довольно легко можем определить, какие файлы были изменены в одном коммите, с помощью опции <code>--name-only</code> для команды <code>git log</code> (мы упоминали о ней в главе 2):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -1 --name-only --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#39;&#39;</span> 9f585d
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>README
</span></span><span style=display:flex><span>lib/test.rb
</span></span></code></pre></div><p>Если мы воспользуемся ACL-структурой, полученной из метода <code>get_acl_access_data</code>, и сверим её со списком файлов для каждого коммита, то мы сможем определить, имеет ли пользователь право на отправку своих коммитов:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># некоторые подкаталоги в проекте разрешено модифицировать только определённым пользователям</span>
</span></span><span style=display:flex><span>def check_directory_perms
</span></span><span style=display:flex><span>  access <span style=color:#f92672>=</span> get_acl_access_data<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;acl&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># проверим, что никто не пытается прислать чего-то, что ему нельзя</span>
</span></span><span style=display:flex><span>  new_commits <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git rev-list <span style=color:#75715e>#{$oldrev}..#{$newrev}`.split(&#34;\n&#34;)</span>
</span></span><span style=display:flex><span>  new_commits.each <span style=color:#66d9ef>do</span> |rev|
</span></span><span style=display:flex><span>    files_modified <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git log -1 --name-only --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#39;&#39;</span> <span style=color:#75715e>#{rev}`.split(&#34;\n&#34;)</span>
</span></span><span style=display:flex><span>    files_modified.each <span style=color:#66d9ef>do</span> |path|
</span></span><span style=display:flex><span>      next <span style=color:#66d9ef>if</span> path.size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>      has_file_access <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>      access<span style=color:#f92672>[</span>$user<span style=color:#f92672>]</span>.each <span style=color:#66d9ef>do</span> |access_path|
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !access_path <span style=color:#f92672>||</span> <span style=color:#75715e># пользователь имеет полный доступ</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>(</span>path.index<span style=color:#f92672>(</span>access_path<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#75715e># доступ к этому пути</span>
</span></span><span style=display:flex><span>          has_file_access <span style=color:#f92672>=</span> true 
</span></span><span style=display:flex><span>        end
</span></span><span style=display:flex><span>      end
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> !has_file_access
</span></span><span style=display:flex><span>        puts <span style=color:#e6db74>&#34;[POLICY] You do not have access to push to #{path}&#34;</span>
</span></span><span style=display:flex><span>        exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      end
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>  end  
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>check_directory_perms
</span></span></code></pre></div><p>Большую часть этого кода должно быть не сложно понять. Мы получаем список присланных на сервер коммитов с помощью <code>git rev-list</code>. Затем для каждого из них мы узнаём, какие файлы были изменены, и убеждаемся, что пользователь, сделавший <code>push</code>, имеет доступ ко всем изменённым путям. Один Ruby&rsquo;изм, который может быть непонятен — это <code>path.index(access_path) == 0</code>. Это условие верно, если <code>path</code> начинается с <code>access_path</code> — оно гарантирует, что <code>access_path</code> — это не просто один из разрешённых путей, а что каждый путь, к которому запрашивается доступ, начинается с одного из разрешённых путей.</p><p>Теперь наши пользователи не смогут отправить никаких коммитов с плохо отформатированными сообщениями и не смогут изменить файлы вне предназначенных для них путей.</p><h4 id=разрешение-только-обновлений-перемоток class="relative group">Разрешение только обновлений-перемоток <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%80%d0%b0%d0%b7%d1%80%d0%b5%d1%88%d0%b5%d0%bd%d0%b8%d0%b5-%d1%82%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d0%be%d0%b1%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b9-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%be%d1%82%d0%be%d0%ba aria-label=Якорь>#</a></span></h4><p>Единственное, что нам осталось — это оставить доступными только обновления-перемотки. Чтобы добиться этого, можно просто задать настройки <code>receive.denyDeletes</code> и <code>receive.denyNonFastForwards</code>. Но осуществление этого с помощью перехватчика также будет работать, и к тому же вы сможете изменить его так, чтобы запрет действовал только для определённых пользователей, или ещё как-то, как вам захочется.</p><p>Логика здесь такая — мы проверяем, есть ли такие коммиты, которые достижимы из старой версии и не достижимы из новой. Если таких нет, то сделанный <code>push</code> был перемоткой; в противном случае мы его запрещаем:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># разрешаем только обновления-перемотки</span>
</span></span><span style=display:flex><span>def check_fast_forward
</span></span><span style=display:flex><span>  missed_refs <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git rev-list <span style=color:#75715e>#{$newrev}..#{$oldrev}`</span>
</span></span><span style=display:flex><span>  missed_ref_count <span style=color:#f92672>=</span> missed_refs.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span><span style=color:#f92672>)</span>.size
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> missed_ref_count &gt; <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    puts <span style=color:#e6db74>&#34;[POLICY] Cannot push a non fast-forward reference&#34;</span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>check_fast_forward
</span></span></code></pre></div><p>Всё готово. Если вы выполните <code>chmod u+x .git/hooks/update</code> (а это тот файл, в который вы должны были поместить весь наш код) и затем попытаетесь отправить ссылку, для которой нельзя выполнить перемотку, то вы получите что-то типа такого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push -f origin master
</span></span><span style=display:flex><span>Counting objects: 5, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>3/3<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>3/3<span style=color:#f92672>)</span>, <span style=color:#ae81ff>323</span> bytes, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>3</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Unpacking objects: 100% <span style=color:#f92672>(</span>3/3<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Enforcing Policies... 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>refs/heads/master<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>8338c5<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>c5b616<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>POLICY<span style=color:#f92672>]</span> Cannot push a non fast-forward reference
</span></span><span style=display:flex><span>error: hooks/update exited with error code <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>error: hook declined to update refs/heads/master
</span></span><span style=display:flex><span>To git@gitserver:project.git
</span></span><span style=display:flex><span> ! <span style=color:#f92672>[</span>remote rejected<span style=color:#f92672>]</span> master -&gt; master <span style=color:#f92672>(</span>hook declined<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error: failed to push some refs to <span style=color:#e6db74>&#39;git@gitserver:project.git&#39;</span>
</span></span></code></pre></div><p>Тут есть пара интересных моментов. Во-первых, когда перехватчик начинает свою работу, мы видим это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Enforcing Policies... 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>refs/heads/master<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>8338c5<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>c56860<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Обратите внимание, что мы выводили это в stdout в самом начале нашего сценария <code>update</code>. Важно отметить, что всё, что сценарий выводит в stdout, будет передано клиенту.</p><p>Следующая вещь, которую мы видим, это сообщение об ошибке:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>POLICY<span style=color:#f92672>]</span> Cannot push a non fast-forward reference
</span></span><span style=display:flex><span>error: hooks/update exited with error code <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>error: hook declined to update refs/heads/master
</span></span></code></pre></div><p>Первую строку напечатали мы, а в остальных двух Git сообщает, что сценарий <code>update</code> завершился с ненулевым кодом, и это именно то, что отклонило ваш <code>push</code>. И, наконец, мы видим это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>To git@gitserver:project.git
</span></span><span style=display:flex><span> ! <span style=color:#f92672>[</span>remote rejected<span style=color:#f92672>]</span> master -&gt; master <span style=color:#f92672>(</span>hook declined<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error: failed to push some refs to <span style=color:#e6db74>&#39;git@gitserver:project.git&#39;</span>
</span></span></code></pre></div><p>Сообщение &ldquo;remote rejected&rdquo; будет появляться для каждой отклонённой перехватчиком ссылки. Оно сообщает нам, что ссылка была отклонена именно из-за сбоя в перехватчике.</p><p>Кроме того, при отсутствии отметки &ldquo;ref&rdquo; в каком-либо из коммитов, вы увидите сообщение об ошибке, которое мы для этого напечатали.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>POLICY<span style=color:#f92672>]</span> Your message is not formatted correctly
</span></span></code></pre></div><p>Или если кто-то попытается отредактировать файл, не имея к нему доступа, то, отправив коммит с этими изменениями, он получит похожее сообщение. Например, если человек, пишущий документацию, попытается отправить коммит, вносящий изменения в файлы каталога <code>lib</code>, то увидит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>POLICY<span style=color:#f92672>]</span> You <span style=color:#66d9ef>do</span> not have access to push to lib/test.rb
</span></span></code></pre></div><p>Вот и всё. С этого момента, до тех пор пока сценарий <code>update</code> находится на своём месте и имеет права на исполнение, репозиторий никогда не будет откатан назад, в нём никогда не будет коммитов с сообщениями без вашего паттерна, и пользователи будут ограничены в доступе к файлам.</p><h3 id=перехватчики-на-стороне-клиента-1 class="relative group">Перехватчики на стороне клиента <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d1%85%d0%b2%d0%b0%d1%82%d1%87%d0%b8%d0%ba%d0%b8-%d0%bd%d0%b0-%d1%81%d1%82%d0%be%d1%80%d0%be%d0%bd%d0%b5-%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82%d0%b0-1 aria-label=Якорь>#</a></span></h3><p>Обратная сторона такого подхода — это многочисленные жалобы, которые неизбежно появятся, когда отправленные пользователями коммиты будут отклонены. Когда чью-то тщательно оформленную работу отклоняют в последний момент, этот человек может быть сильно расстроен и смущён. Мало того, ему придётся отредактировать свою историю, чтобы откорректировать её, а это обычно не для слабонервных.</p><p>Решение данной проблемы — предоставить пользователям какие-нибудь перехватчики, которые будут работать на стороне пользователя и будут сообщать ему, если он делает что-то, что, скорее всего, будет отклонено. При таком подходе, пользователи смогут исправить любые проблемы до создания коммита и до того, как эти проблемы станет сложно исправить. Так как перехватчики не пересылаются при клонировании проекта, вам придётся распространять эти сценарии каким-то другим способом и потом сделать так, чтобы ваши пользователи скопировали их в свой каталог <code>.git/hooks</code> и сделали их исполняемыми. Эти перехватчики можно поместить в свой проект или даже в отдельный проект, но способа установить их автоматически не существует.</p><p>Для начала, перед записью каждого коммита нам надо проверить его сообщение, чтобы быть уверенным, что сервер не отклонит изменения из-за плохо отформатированного сообщения коммита. Чтобы сделать это, добавим перехватчик <code>commit-msg</code>. Если мы сможем прочитать сообщение из файла, переданного в качестве первого аргумента, и сравнить его с шаблоном, то можно заставить Git прервать создание коммита при обнаружении несовпадения:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env ruby
</span></span></span><span style=display:flex><span>message_file <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>message <span style=color:#f92672>=</span> File.read<span style=color:#f92672>(</span>message_file<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$regex <span style=color:#f92672>=</span> /<span style=color:#ae81ff>\[</span>ref: <span style=color:#f92672>(</span><span style=color:#ae81ff>\d</span>+<span style=color:#f92672>)</span><span style=color:#ae81ff>\]</span>/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> !$regex.match<span style=color:#f92672>(</span>message<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  puts <span style=color:#e6db74>&#34;[POLICY] Your message is not formatted correctly&#34;</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><p>Если этот сценарий находится на своём месте (в <code>.git/hooks/commit-msg</code>) и имеет права на исполнение, то при создании коммита с неправильно оформленным сообщением вы увидите это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;test&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>POLICY<span style=color:#f92672>]</span> Your message is not formatted correctly
</span></span></code></pre></div><p>В этом случае коммит не был завершён. Однако, когда сообщение содержит правильный шаблон, Git позволяет создать коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;test [ref: 132]&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master e05c914<span style=color:#f92672>]</span> test <span style=color:#f92672>[</span>ref: 132<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Далее мы хотим убедиться, что пользователь не модифицирует файлы вне своей области, заданной в ACL. Если в проекте в каталоге <code>.git</code> уже есть копия файла <code>acl</code>, который мы использовали ранее, то сценарий <code>pre-commit</code> следующего вида применит эти ограничения:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env ruby
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$user    <span style=color:#f92672>=</span> ENV<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;USER&#39;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># [ insert acl_access_data method from above ]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># некоторые подкаталоги в проекте разрешено модифицировать только определённым пользователям</span>
</span></span><span style=display:flex><span>def check_directory_perms
</span></span><span style=display:flex><span>  access <span style=color:#f92672>=</span> get_acl_access_data<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;.git/acl&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  files_modified <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git diff-index --cached --name-only HEAD<span style=color:#e6db74>`</span>.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  files_modified.each <span style=color:#66d9ef>do</span> |path|
</span></span><span style=display:flex><span>    next <span style=color:#66d9ef>if</span> path.size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    has_file_access <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>    access<span style=color:#f92672>[</span>$user<span style=color:#f92672>]</span>.each <span style=color:#66d9ef>do</span> |access_path|
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !access_path <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>path.index<span style=color:#f92672>(</span>access_path<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      has_file_access <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !has_file_access
</span></span><span style=display:flex><span>      puts <span style=color:#e6db74>&#34;[POLICY] You do not have access to push to #{path}&#34;</span>
</span></span><span style=display:flex><span>      exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>check_directory_perms
</span></span></code></pre></div><p>Это примерно тот же сценарий, что и на стороне сервера, но с двумя важными отличиями. Первое — файл <code>acl</code> находится в другом месте, так как этот сценарий теперь запускается из рабочего каталога, а не из Git-каталога. Нужно изменить путь к ACL-файлу с этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>access <span style=color:#f92672>=</span> get_acl_access_data<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;acl&#39;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>на этот:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>access <span style=color:#f92672>=</span> get_acl_access_data<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;.git/acl&#39;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Другое важное отличие — это способ получения списка изменённых файлов. Так как метод, действующий на стороне сервера, смотрит в лог коммитов, а сейчас коммит ещё не был записан, нам надо получить список файлов из индекса. Вместо</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>files_modified <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git log -1 --name-only --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#39;&#39;</span> <span style=color:#75715e>#{ref}`</span>
</span></span></code></pre></div><p>мы должны использовать</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>files_modified <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git diff-index --cached --name-only HEAD<span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>Но это единственные два отличия — во всём остальном этот сценарий работает точно так же. Но надо предупредить, что он предполагает, что локально вы работаете под тем же пользователем, от имени которого отправляете изменения на удалённый сервер. Если это не так, то вам необходимо задать переменную <code>$user</code> вручную.</p><p>Последнее, что нам нужно сделать, — это проверить, что пользователь не пытается отправить ссылки не с перемоткой, но это случается не так часто. Чтобы получились ссылки, не являющиеся перемоткой, надо либо переместить ветку за уже отправленный коммит, либо попытаться отправить другую локальную ветку в ту же самую удалённую ветку.</p><p>Так как сервер в любом случае сообщит вам о том, что нельзя отправлять обновления, не являющиеся перемоткой, а перехватчик запрещает принудительные <code>push</code>&lsquo;и, единственная оплошность, которую вы можете попробовать предотвратить, это перемещение коммитов, которые уже были отправлены на сервер.</p><p>Вот пример сценария <code>pre-rebase</code>, который это проверяет. Он принимает на вход список всех коммитов, которые вы собираетесь переписать, и проверяет, нет ли их в какой-нибудь из ваших удалённых веток. Если найдётся такой коммит, который достижим из одной из удалённых веток, сценарий прервёт выполнение перемещения:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env ruby
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>base_branch <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ARGV<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  topic_branch <span style=color:#f92672>=</span> ARGV<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  topic_branch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HEAD&#34;</span>
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target_shas <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git rev-list <span style=color:#75715e>#{base_branch}..#{topic_branch}`.split(&#34;\n&#34;)</span>
</span></span><span style=display:flex><span>remote_refs <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git branch -r<span style=color:#e6db74>`</span>.split<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span><span style=color:#f92672>)</span>.map <span style=color:#f92672>{</span> |r| r.strip <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target_shas.each <span style=color:#66d9ef>do</span> |sha|
</span></span><span style=display:flex><span>  remote_refs.each <span style=color:#66d9ef>do</span> |remote_ref|
</span></span><span style=display:flex><span>    shas_pushed <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span>git rev-list ^#<span style=color:#f92672>{</span>sha<span style=color:#f92672>}</span>^@ refs/remotes/#<span style=color:#f92672>{</span>remote_ref<span style=color:#f92672>}</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> shas_pushed.split<span style=color:#f92672>(</span>“<span style=color:#ae81ff>\n</span>”<span style=color:#f92672>)</span>.include?<span style=color:#f92672>(</span>sha<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      puts <span style=color:#e6db74>&#34;[POLICY] Commit #{sha} has already been pushed to #{remote_ref}&#34;</span>
</span></span><span style=display:flex><span>      exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    end
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><p>Этот сценарий использует синтаксис, который мы не рассматривали в разделе &ldquo;Выбор ревизии&rdquo; в главе 6. Мы получили список коммитов, которые уже были отправлены на сервер, выполнив это:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git rev-list ^#<span style=color:#f92672>{</span>sha<span style=color:#f92672>}</span>^@ refs/remotes/#<span style=color:#f92672>{</span>remote_ref<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Запись <code>SHA^@</code> означает всех родителей указанного коммита. Мы ищем какой-нибудь коммит, который достижим из последнего коммита в удалённой ветке и не достижим ни из одного из родителей какого-либо SHA, который вы пытаетесь отправить на сервер — это значит, что это перемотка.</p><p>Главный недостаток такого подхода — это то, что проверка может быть очень медленной и зачастую избыточной — если вы не пытаетесь отправить данные принудительно с помощью <code>-f</code>, сервер и так выдаст предупреждение и не примет данные. Однако, это интересное упражнение и теоретически может помочь вам избежать перемещения, к которому потом придётся вернуться, чтобы исправить.</p><h2 id=итоги-1 class="relative group">Итоги <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%82%d0%be%d0%b3%d0%b8-1 aria-label=Якорь>#</a></span></h2><p>Мы рассмотрели большинство основных способов настройки клиента и сервера Git&rsquo;а с тем, чтобы он был максимально удобен для ваших проектов и при вашей организации рабочего процесса. Мы узнали о всевозможных настройках, атрибутах файлов и о перехватчиках событий, а также рассмотрели пример настройки сервера с соблюдением политики. Теперь вам должно быть по плечу заставить Git подстроиться под практически любой тип рабочего процесса, который можно вообразить.</p></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=400 height=400 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt="Андрей Куманяев" loading=lazy decoding=async src=https://zzet.org/img/author.jpeg></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Автор</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Андрей Куманяев</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://twitter.com/username target=_blank aria-label=Twitter rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/zzet target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://x.com/zzetorg target=_blank aria-label=X rel="me noopener noreferrer"></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.reddit.com/user/zzet/ target=_blank aria-label=Reddit rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.linkedin.com/in/andrey-kumanyaev/ target=_blank aria-label=Linkedin rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></span></a></div></div></div></div><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.facebook.com/sharer/sharer.php?u=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;quote=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Поделиться на Facebook" aria-label="Поделиться на Facebook" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://x.com/intent/tweet/?url=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;text=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Post on X" aria-label="Post on X" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://tootpick.org/#text=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Поделиться на Mastodon" aria-label="Поделиться на Mastodon" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://reddit.com/submit/?url=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;resubmit=true&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Опубликовать на Reddit" aria-label="Опубликовать на Reddit" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Поделиться на LinkedIn" aria-label="Поделиться на LinkedIn" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;subject=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Послать через email" aria-label="Послать через email" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.threads.net/intent/post?text=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Post on Threads" aria-label="Post on Threads" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M331.5 235.7c2.2.9 4.2 1.9 6.3 2.8 29.2 14.1 50.6 35.2 61.8 61.4 15.7 36.5 17.2 95.8-30.3 143.2-36.2 36.2-80.3 52.5-142.6 53h-.3c-70.2-.5-124.1-24.1-160.4-70.2-32.3-41-48.9-98.1-49.5-169.6V256v-.2C17 184.3 33.6 127.2 65.9 86.2 102.2 40.1 156.2 16.5 226.4 16h.3c70.3.5 124.9 24 162.3 69.9 18.4 22.7 32 50 40.6 81.7l-40.4 10.8c-7.1-25.8-17.8-47.8-32.2-65.4-29.2-35.8-73-54.2-130.5-54.6-57 .5-100.1 18.8-128.2 54.4C72.1 146.1 58.5 194.3 58 256c.5 61.7 14.1 109.9 40.3 143.3 28 35.6 71.2 53.9 128.2 54.4 51.4-.4 85.4-12.6 113.7-40.9 32.3-32.2 31.7-71.8 21.4-95.9-6.1-14.2-17.1-26-31.9-34.9-3.7 26.9-11.8 48.3-24.7 64.8-17.1 21.8-41.4 33.6-72.7 35.3-23.6 1.3-46.3-4.4-63.9-16-20.8-13.8-33-34.8-34.3-59.3-2.5-48.3 35.7-83 95.2-86.4 21.1-1.2 40.9-.3 59.2 2.8-2.4-14.8-7.3-26.6-14.6-35.2-10-11.7-25.6-17.7-46.2-17.8H227c-16.6.0-39 4.6-53.3 26.3l-34.4-23.6c19.2-29.1 50.3-45.1 87.8-45.1h.8c62.6.4 99.9 39.5 103.7 107.7l-.2.2zm-156 68.8c1.3 25.1 28.4 36.8 54.6 35.3 25.6-1.4 54.6-11.4 59.5-73.2-13.2-2.9-27.8-4.4-43.4-4.4-4.8.0-9.6.1-14.4.4-42.9 2.4-57.2 23.2-56.2 41.8l-.1.1z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://telegram.me/share/url?text=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/&amp;url=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%203.%20%d0%98%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b%20Git." title="Поделиться на Telegram" aria-label="Поделиться на Telegram" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111.033 8 0 119.033.0 256S111.033 504 248 504 496 392.967 496 256 384.967 8 248 8zM362.952 176.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452.0 013.53 6.716A43.765 43.765.0 01362.952 176.66z"/></svg></span></a></section><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=https://zzet.org/ru/archive/2014-01-27-unix-shell-initialization/><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Unix shell initialization</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-01-27 00:00:00 +0000 UTC">27 января 2014 г.</time>
</span></span></a></span><span><a class="group flex text-right" href=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Git. Просто Git. Лекция 2. Основы Git, Ветвление.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=Вверх title=Вверх>&uarr;</a></div><footer class="py-10 print:hidden"><nav class="pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="group mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a href=/ru/archive/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Архив</span></a></li></ul></nav><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2026
Андрей Куманяев</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Работает на <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer></div></body></html>