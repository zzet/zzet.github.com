<!doctype html><html lang=ru dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>Git. Просто Git. Лекция 5. Git изнутри. &#183; Андрей Куманяев</title><meta name=title content="Git. Просто Git. Лекция 5. Git изнутри. &#183; Андрей Куманяев"><script type=text/javascript src=https://zzet.org/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=https://zzet.org/css/main.bundle.min.100caa677b4bc416cdd884107b203b4869f9b413a19aa57d12069fb826f1abe9.css integrity="sha256-EAyqZ3tLxBbN2IQQeyA7SGn5tBOhmqV9EgafuCbxq+k="><meta name=description content="
      
        
      
    "><meta name=robots content="all"><link rel=canonical href=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/"><meta property="og:site_name" content="Андрей Куманяев"><meta property="og:title" content="Git. Просто Git. Лекция 5. Git изнутри."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2014-03-28T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git. Просто Git. Лекция 5. Git изнутри."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"","name":"Git. Просто Git. Лекция 5. Git изнутри.","headline":"Git. Просто Git. Лекция 5. Git изнутри.","inLanguage":"ru","url":"https:\/\/zzet.org\/ru\/archive\/2014-04-04-lection-5-git-course-undev\/","author":{"@type":"Person","name":"Андрей Куманяев"},"copyrightYear":"2014","dateCreated":"2014-03-28T00:00:00\u002b00:00","datePublished":"2014-03-28T00:00:00\u002b00:00","dateModified":"2014-03-28T00:00:00\u002b00:00","mainEntityOfPage":"true","wordCount":"7886"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zzet.org/ru/","name":"Андрей Куманяев","position":1},{"@type":"ListItem","item":"https://zzet.org/ru/archive/","name":"","position":2},{"@type":"ListItem","name":"Git. Просто Git. Лекция 5. Git Изнутри.","position":3}]}</script><meta name=author content="Андрей Куманяев"><link href=https://twitter.com/username rel=me><link href=https://github.com/zzet rel=me><link href=https://x.com/zzetorg rel=me><link href=https://www.reddit.com/user/zzet/ rel=me><link href=https://www.linkedin.com/in/andrey-kumanyaev/ rel=me><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGXR3BQCTQ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VGXR3BQCTQ")}</script></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Перейти к содержанию</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/ru/>Андрей Куманяев</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/about/ title="Обо мне"><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Обо мне</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Блог</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://github.com/zzet title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://x.com/zzetorg title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/>Андрей Куманяев</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/>archive</a><span class="px-1 text-primary-500">/</span></li><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/>Git. Просто Git. Лекция 5. Git изнутри.</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Git. Просто Git. Лекция 5. Git изнутри.</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2014-03-28 00:00:00 +0000 UTC">28 марта 2014 г.</time><span class="px-2 text-primary-500">&#183;</span><span title="Время чтения">38 минут</span><span class="px-2 text-primary-500">&#183;</span>
<span class=mb-[2px]><a href=https://github.com/zzet.github.com/content/archive/2014-04-04-lection-5-git-course-undev.ru.md class="text-lg hover:text-primary-500" rel="noopener noreferrer" target=_blank title=Редактировать><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M490.3 40.4c21.9 21.87 21.9 57.33.0 79.2l-30 30.1-98-97.98 30.1-30.06C414.3-.2135 449.7-.2135 471.6 21.66L490.3 40.4zM172.4 241.7 339.7 74.34l98 97.96L270.3 339.6C264.2 345.8 256.7 350.4 248.4 353.2l-88.8 29.6C150.1 385.6 141.5 383.4 135 376.1 128.6 370.5 126.4 361 129.2 352.4l29.6-88.8C161.6 255.3 166.2 247.8 172.4 241.7v0zM192 63.1c17.7.0 32 15.23 32 32 0 18.6-14.3 32-32 32H96c-17.67.0-32 15.2-32 32V416c0 17.7 14.33 32 32 32H352c17.7.0 32-14.3 32-32V319.1c0-16.8 14.3-32 32-32s32 15.2 32 32V416c0 53-43 96-96 96H96c-53.02.0-96-43-96-96V159.1c0-53 42.98-96 96-96h96z"/></svg></span></a></span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><h1 id=git-изнутри class="relative group">Git изнутри <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#git-%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8 aria-label=Якорь>#</a></span></h1><p>В данной лекции рассматриваются внутренние процессы Git&rsquo;а и особенности его реализации. На мой взгляд, изучение этих вещей — это основа понимания того, насколько Git полезный и мощный инструмент. Хотя некоторые утверждают, что изложение этого материала может сбить новичков с толку и оказаться для них неоправданно сложным. Именно поэтому эта лекция отнесена в конец, давая возможность заинтересованным освоить её раньше, а сомневающимся — позже.</p><p>Итак, приступим. Во-первых, напомню, что Git — это, по сути, контентно-адресуемая файловая система с пользовательским СКВ-интерфейсом поверх неё. Довольно скоро станет понятнее, что это значит.</p><p>На заре развития Git&rsquo;а (примерно до версии 1.5), интерфейс был значительно сложнее, поскольку был более похож на интерфейс доступа к файловой системе, чем на законченную СКВ. За последние годы, интерфейс значительно улучшился и по удобству не уступает аналогам; у некоторых, тем не менее, с тех пор сохранился стереотип о том, что интерфейс у Git&rsquo;а чересчур сложный и труден для изучения.</p><p>Контентно-адресуемая файловая система — основа Git&rsquo;а, очень интересна, именно её мы сначала рассмотрим в этой лекции; далее будут рассмотрены транспортные механизмы и инструменты обслуживания репозитория, с которыми вам в своё время, возможно, придётся столкнуться.</p><h2 id=сантехника-и-фарфор class="relative group">Сантехника и фарфор <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%b0%d0%bd%d1%82%d0%b5%d1%85%d0%bd%d0%b8%d0%ba%d0%b0-%d0%b8-%d1%84%d0%b0%d1%80%d1%84%d0%be%d1%80 aria-label=Якорь>#</a></span></h2><p>В этой книге было описано, как пользоваться Git&rsquo;ом, применяя примерно три десятка команд, например, <code>checkout</code>, <code>branch</code>, <code>remote</code> и т.п. Но так как сначала Git был скорее инструментарием для создания СКВ, чем СКВ, удобной для пользователей, в нём полно команд, выполняющих низкоуровневые операции, которые спроектированы так, чтобы их можно было использовать в цепочку в стиле UNIX, а также использовать в сценариях. Эти команды, как правило, называют служебными (&ldquo;plumbing&rdquo; — трубопровод), а ориентированные на пользователя называют пользовательскими (&ldquo;porcelain&rdquo; — фарфор).</p><p>В данной лекции же рассматриваются именно низкоуровневые служебные команды, дающие контроль над внутренними процессами Git&rsquo;а и показывающие, как он работает и почему он работает так, а не иначе. Предполагается, что данные команды не будут использоваться напрямую из командной строки, а будут служить в качестве строительных блоков для новых команд и пользовательских сценариев.</p><p>Когда вы выполняете <code>git init</code> в новом или существовавшем ранее каталоге, Git создаёт подкаталог <code>.git</code>, в котором располагается почти всё, чем он заправляет. Если требуется выполнить резервное копирование или клонирование репозитория, достаточно скопировать всего лишь один этот каталог, чтобы получить почти всё необходимое. И данная лекция почти полностью посвящена его содержимому. Вот так он выглядит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls 
</span></span><span style=display:flex><span>HEAD
</span></span><span style=display:flex><span>branches/
</span></span><span style=display:flex><span>config
</span></span><span style=display:flex><span>description
</span></span><span style=display:flex><span>hooks/
</span></span><span style=display:flex><span>index
</span></span><span style=display:flex><span>info/
</span></span><span style=display:flex><span>objects/
</span></span><span style=display:flex><span>refs/
</span></span></code></pre></div><p>Там могут быть и другие файлы, но непосредственно после <code>git init</code> вы увидите именно это. Каталог <code>branches</code> не используется новыми версиями Git&rsquo;а, а файл <code>description</code> требуется только программе GitWeb, на них не стоит обращать особого внимания. Файл <code>config</code> содержит настройки проекта, а каталог <code>info</code> — файл с глобальным фильтром, игнорирующим те файлы, которые вы не хотите поместить в .gitignore. В каталоге <code>hooks</code> располагаются клиентские и серверные перехватчики.</p><p>Итак, осталось четыре важных элемента: файлы <code>HEAD</code>, <code>index</code> и каталоги <code>objects</code>, <code>refs</code>. Это ключевые элементы хранилища Git&rsquo;а. В каталоге <code>objects</code> находится, собственно, база данных, в <code>refs</code> — ссылки на объекты коммитов в этой базе (ветки). Файл <code>HEAD</code> указывает на текущую ветку, и в файле <code>index</code> хранится информация индекса. В последующих разделах данные элементы будут рассмотрены более подробно.</p><h2 id=объекты-в-git class="relative group">Объекты в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d1%8b-%d0%b2-git aria-label=Якорь>#</a></span></h2><p>Git — контентно-адресуемая файловая система. Здорово. Но что это означает?
А означает это, что в своей основе Git — простое хранилище ключ-значение. Можно добавить туда любое содержимое, в ответ будет выдан ключ, по которому это содержимое можно извлечь. Для примера, можно воспользоваться служебной командой <code>hash-object</code>, которая добавляет данные в каталог <code>.git</code> и возвращает ключ. Для начала создадим новый Git-репозиторий и убедимся, что каталог <code>objects</code> пуст:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ mkdir test
</span></span><span style=display:flex><span>$ cd test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git init
</span></span><span style=display:flex><span>Initialized empty Git repository in /tmp/test/.git/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ find .git/objects
</span></span><span style=display:flex><span>.git/objects
</span></span><span style=display:flex><span>.git/objects/info
</span></span><span style=display:flex><span>.git/objects/pack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ find .git/objects -type f
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><p>Git проинициализировал каталог <code>objects</code> и создал в нём подкаталоги <code>pack</code> и <code>info</code>, пока без файлов. Теперь добавим кое-какое текстовое содержимое в базу Git&rsquo;а:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;test content&#39;</span> | git hash-object -w --stdin
</span></span><span style=display:flex><span>d670460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span></code></pre></div><p>Ключ <code>-w</code> команды <code>hash-object</code> указывает, что объект необходимо сохранить, иначе команда просто выведет ключ и всё. Флаг <code>--stdin</code> указывает, что данные необходимо считать со стандартного ввода, в противном случае <code>hash-object</code> ожидает имя файла. Вывод команды — 40-символьная контрольная сумма. Это хеш SHA-1 — контрольная сумма содержимого и заголовка, который будет рассмотрен позднее. Теперь можно увидеть, в каком виде будут сохранены ваши данные:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/objects -type f 
</span></span><span style=display:flex><span>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span></code></pre></div><p>В каталоге <code>objects</code> появился файл. Это и есть начальное внутреннее представление данных в Git&rsquo;е — один файл на единицу хранения с именем, являющимся контрольной суммой содержимого и заголовка. Первые два символа SHA определяют подкаталог файла, остальные 38 — собственно, имя.</p><p>Получить обратно содержимое объекта можно командой <code>cat-file</code>. Это своеобразный швейцарский армейский нож для проверки объектов в Git&rsquo;е. Ключ <code>-p</code> означает автоматическое определение типа содержимого и вывод содержимого на печать в удобном виде:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span><span style=display:flex><span>test content
</span></span></code></pre></div><p>Теперь вы умеете добавлять данные в Git и извлекать их обратно. То же самое можно делать и с файлами. Рассмотрим пример. Наиболее простой контроль версий файла можно осуществить, создав его и сохранив в базе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;version 1&#39;</span> &gt; test.txt
</span></span><span style=display:flex><span>$ git hash-object -w test.txt 
</span></span><span style=display:flex><span>83baae61804e65cc73a7201a7252750c76066a30
</span></span></code></pre></div><p>Теперь изменим файл и сохраним его в базе ещё раз:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;version 2&#39;</span> &gt; test.txt
</span></span><span style=display:flex><span>$ git hash-object -w test.txt 
</span></span><span style=display:flex><span>1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
</span></span></code></pre></div><p>Теперь в базе содержатся две версии файла test.txt, а также самый первый сохранённый объект:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/objects -type f 
</span></span><span style=display:flex><span>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
</span></span><span style=display:flex><span>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
</span></span><span style=display:flex><span>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span></code></pre></div><p>Теперь можно откатить файл к его первой версии:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt 
</span></span><span style=display:flex><span>$ cat test.txt 
</span></span><span style=display:flex><span>version <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>или второй:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt 
</span></span><span style=display:flex><span>$ cat test.txt 
</span></span><span style=display:flex><span>version <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Однако запоминать хеш для каждой версии неудобно, к тому же теряется само имя файла, сохраняется лишь содержимое. Объекты такого типа называют блобами (англ. binary large object). Имея SHA-1 объекта, можно попросить Git показать нам его тип с помощью команды <code>cat-file -t</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
</span></span><span style=display:flex><span>blob
</span></span></code></pre></div><h3 id=объекты-деревья class="relative group">Объекты-деревья <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d1%8b-%d0%b4%d0%b5%d1%80%d0%b5%d0%b2%d1%8c%d1%8f aria-label=Якорь>#</a></span></h3><p>Рассмотрим другой тип объектов Git&rsquo;а — деревья. Они решают проблему хранения имён файлов, а также позволяют хранить группы файлов вместе. Git хранит данные сходным с файловыми системами UNIX способом, но в немного упрощённом виде. Содержимое хранится в объектах-деревьях и блобах, дерево соответствует записи каталога в ФС, а блоб более или менее соответствует inode или содержимому файла. Объект-дерево может содержать одну и более записей, каждая из которых представляет собой набор из SHA-1 хеша, соответствующего блобу или поддереву, режима доступа к файлу, типа и имени файла. Например, в проекте simplegit последнее дерево выглядит так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p master^<span style=color:#f92672>{</span>tree<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob a906cb2a4a904a152e80877d4088654daad0c859      README
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
</span></span><span style=display:flex><span><span style=color:#ae81ff>040000</span> tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
</span></span></code></pre></div><p>Запись <code>master^{tree}</code> означает объект-дерево, на который указывает последний коммит ветки <code>master</code>. Заметьте, что подкаталог <code>lib</code> — не блоб, а указатель на другое дерево:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
</span></span></code></pre></div><p>Схематически, данные, хранящиеся в Git&rsquo;е, выглядят примерно так, как это изображено на рисунке 9-1.</p><p>Insert 18333fig0901.png
Рисунок 9-1. Упрощённая модель данных Git&rsquo;а.</p><p>Вручную можно создавать не только блобы, но и деревья. Git обычно создаёт дерево, исходя из состояния индекса, и затем сохраняет соответствующий объект-дерево. Поэтому для создания объекта-дерева необходимо проиндексировать какие-нибудь файлы. Для создания индекса из одной записи — первой версии файла test.txt, воспользуемся командой <code>update-index</code>. Данная команда может искусственно добавить более раннюю версию test.txt в новый индекс. Необходимо передать опции <code>--add</code>, т.к. файл ещё не существует в индексе (да и самого индекса ещё нет), и <code>--cacheinfo</code>, т.к. добавляемого файла нет в рабочем каталоге, но он есть в базе данных. Также необходимо передать режим доступа, хеш и имя файла:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git update-index --add --cacheinfo <span style=color:#ae81ff>100644</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  83baae61804e65cc73a7201a7252750c76066a30 test.txt
</span></span></code></pre></div><p>В данном случае режим доступа — <code>100644</code>, что означает обычный файл. Другие возможные варианты: <code>100755</code> — исполняемый файл, <code>120000</code> — символическая ссылка. Режимы доступа в Git&rsquo;е сделаны по аналогии с режимами доступа в UNIX, но они гораздо менее гибки: данные три режима — единственные доступные для файлов (блобов) в Git&rsquo;е (хотя существуют и другие режимы, используемые для каталогов и подмодулей).</p><p>Теперь можно воспользоваться командой <code>write-tree</code> для сохранения индекса в объект-дерево. Здесь опция <code>-w</code> не требуется — вызов <code>write-tree</code> автоматически создаст объект-дерево по состоянию индекса, если такого дерева ещё не существует:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git write-tree
</span></span><span style=display:flex><span>d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
</span></span></code></pre></div><p>Также можно проверить, что мы действительно создали объект-дерево:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span></span><span style=display:flex><span>tree
</span></span></code></pre></div><p>Создадим новое дерево со второй версией файла test.txt и ещё одним файлом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;new file&#39;</span> &gt; new.txt
</span></span><span style=display:flex><span>$ git update-index test.txt 
</span></span><span style=display:flex><span>$ git update-index --add new.txt 
</span></span></code></pre></div><p>Теперь в индексе содержится новая версия файла test.txt и новый файл new.txt. Запишем это дерево (сохранив состояние индекса в объект-дерево) и посмотрим, что из этого получилось:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git write-tree
</span></span><span style=display:flex><span>0155eb4229851634a0f03eb265b69f5a2d56f341
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</span></span></code></pre></div><p>Заметьте, что в данном дереве находятся записи для обоих файлов, а также, что хеш файла test.txt это хеш &ldquo;второй версии&rdquo; этого файла (<code>1f7a7a</code>). Для интереса, добавим первое дерево как подкаталог для текущего. Зачитать дерево в индекс можно командой <code>read-tree</code>. В нашем случае, чтобы прочитать уже существующее дерево в индекс и сделать его поддеревом, необходимо использовать опцию <code>--prefix</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git read-tree --prefix<span style=color:#f92672>=</span>bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span></span><span style=display:flex><span>$ git write-tree
</span></span><span style=display:flex><span>3c4e9cd789d88d8d89c1073707c3585e41b0e614
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
</span></span><span style=display:flex><span><span style=color:#ae81ff>040000</span> tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</span></span></code></pre></div><p>Если бы вы создали рабочий каталог, соответствующий только что созданному дереву, вы бы получили два файла в корне и подкаталог <code>bak</code> со старой версией файла test.txt. Данные, хранящиеся в Git&rsquo;е для такой структуры, могут быть представлены так, как показано на рисунке 9-2.</p><p>Insert 18333fig0902.png
Рисунок 9-2. Структура данных Git&rsquo;а для текущего дерева.</p><h3 id=объекты-коммиты class="relative group">Объекты-коммиты <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d1%8b-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d1%8b aria-label=Якорь>#</a></span></h3><p>У нас есть три дерева, соответствующих разным состояниям проекта, но предыдущая проблема с необходимостью запоминать все три значения SHA-1, чтобы иметь возможность восстановить какое-либо из этих состояний, ещё не решена. К тому же у нас нет никакой информации о том, кто, когда и почему сохранил их. Такие данные — основная информация, которая хранится в объекте-коммите.</p><p>Для создания объекта-коммита необходимо вызвать <code>commit-tree</code> и задать SHA-1 нужного дерева и, если необходимо, родительские объекты-коммиты. Для начала создадим коммит для самого первого дерева:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;first commit&#39;</span> | git commit-tree d8329f
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</span></span></code></pre></div><p>Просмотреть вновь созданный объект-коммит можно командой <code>cat-file</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p fdf4fc3
</span></span><span style=display:flex><span>tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span></span><span style=display:flex><span>author Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1243040974</span> -0700
</span></span><span style=display:flex><span>committer Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1243040974</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>first commit
</span></span></code></pre></div><p>Формат объекта-коммита прост: в нём указано дерево верхнего уровня, соответствующее состоянию проекта на некоторый момент; имена автора и коммитера берутся из полей конфигурации <code>user.name</code> и <code>user.email</code>; также добавляется текущая временная метка, пустая строка и затем сообщение коммита.</p><p>Далее, создадим ещё два объекта-коммита, каждый из которых будет ссылаться на предыдущий коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;second commit&#39;</span> | git commit-tree 0155eb -p fdf4fc3
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;third commit&#39;</span>  | git commit-tree 3c4e9c -p cac0cab
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span></code></pre></div><p>Каждый из трёх объектов-коммитов указывает на одно из состояний проекта. Может показаться странным, но теперь у нас есть полноценная Git-история, которую можно посмотреть командой <code>git log</code>, указав хеш последнего коммита:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --stat 1a410e
</span></span><span style=display:flex><span>commit 1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri May <span style=color:#ae81ff>22</span> 18:15:24 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    third commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> bak/test.txt |    <span style=color:#ae81ff>1</span> +
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit cac0cab538b970a37ea1e769cbbde608743bc96d
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri May <span style=color:#ae81ff>22</span> 18:14:29 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    second commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> new.txt  |    <span style=color:#ae81ff>1</span> +
</span></span><span style=display:flex><span> test.txt |    <span style=color:#ae81ff>2</span> +-
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span> files changed, <span style=color:#ae81ff>2</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>1</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri May <span style=color:#ae81ff>22</span> 18:09:34 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    first commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> test.txt |    <span style=color:#ae81ff>1</span> +
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Поразительно. Мы только что выполнили низкоуровневые операции для построения истории без использования высокоуровневых интерфейсов. По существу, именно это делает Git, когда выполняются команды <code>git add</code> и <code>git commit</code> — сохраняет блобы для изменённых файлов, обновляет индекс, записывает объекты-деревья и коммит-объекты, ссылающиеся на объекты-деревья верхнего уровня и предшествующие коммиты. Эти три основных вида объектов Git&rsquo;а: блоб, дерево и коммит — первоначально сохраняются как отдельные файлы в каталоге <code>.git/objects</code>. Вот все объекты, которые сейчас лежат в каталоге с примером (в комментариях написано чему объекты соответствует):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/objects -type f
</span></span><span style=display:flex><span>.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 <span style=color:#75715e># tree 2</span>
</span></span><span style=display:flex><span>.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 <span style=color:#75715e># commit 3</span>
</span></span><span style=display:flex><span>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a <span style=color:#75715e># test.txt v2</span>
</span></span><span style=display:flex><span>.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 <span style=color:#75715e># tree 3</span>
</span></span><span style=display:flex><span>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 <span style=color:#75715e># test.txt v1</span>
</span></span><span style=display:flex><span>.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d <span style=color:#75715e># commit 2</span>
</span></span><span style=display:flex><span>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 <span style=color:#75715e># &#39;test content&#39;</span>
</span></span><span style=display:flex><span>.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 <span style=color:#75715e># tree 1</span>
</span></span><span style=display:flex><span>.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 <span style=color:#75715e># new.txt</span>
</span></span><span style=display:flex><span>.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d <span style=color:#75715e># commit 1</span>
</span></span></code></pre></div><p>Если пройти по всем внутренним ссылкам, получится граф объектов такой, как на рисунке 9-3.</p><p>Insert 18333fig0903.png
Рисунок 9-3. Все объекты в каталоге Git&rsquo;а.</p><h3 id=хранение-объектов class="relative group">Хранение объектов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%85%d1%80%d0%b0%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Ранее я упоминал, что заголовок сохраняется вместе с содержимым. Давайте посмотрим, как сохраняются объекты Git&rsquo;а на диске. Мы рассмотрим сохранение блоб-объекта, в данном случае это будет строка &ldquo;есть проблемы, шеф?&rdquo;. Пример будет выполнен на языке Ruby. Для запуска интерактивного интерпретатора воспользуйтесь командой <code>irb</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> irb
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> content <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;есть проблемы, шеф?&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;есть проблемы, шеф?&#34;</span>
</span></span></code></pre></div><p>Git создаёт заголовок, начинающийся с типа объекта, в данном случае это блоб. Далее добавляется пробел, размер содержимого и в конце нулевой байт:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> header <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;blob </span><span style=color:#e6db74>#{</span>content<span style=color:#f92672>.</span>length<span style=color:#e6db74>}</span><span style=color:#ae81ff>\0</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;blob 34</span><span style=color:#ae81ff>\000</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>Git дописывает содержимое после заголовка и вычисляет SHA-1 сумму для полученного результата. В Ruby значение SHA-1 для строки можно получить, подключив соответствующую библиотеку командой <code>require</code> и затем воспользовавшись вызовом <code>Digest::SHA1.hexdigest()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> store <span style=color:#f92672>=</span> header <span style=color:#f92672>+</span> content
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;blob 34</span><span style=color:#ae81ff>\000\320\225\321\201\321\202\321\214</span><span style=color:#e6db74> </span><span style=color:#ae81ff>\320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213</span><span style=color:#e6db74>, </span><span style=color:#ae81ff>\321\210\320\265\321\204</span><span style=color:#e6db74>?&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> require <span style=color:#e6db74>&#39;digest/sha1&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> sha1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>Digest</span><span style=color:#f92672>::</span><span style=color:#66d9ef>SHA1</span><span style=color:#f92672>.</span>hexdigest(store)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;d8a734f44240bdf766c8df342664fde23d421d64&#34;</span>
</span></span></code></pre></div><p>Git сжимает новые данные при помощи zlib. В Ruby это можно сделать с помощью одноимённой библиотеки. Сперва необходимо подключить её, а после вызвать <code>Zlib::Deflate.deflate()</code> с данными в качестве параметра:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> require <span style=color:#e6db74>&#39;zlib&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> zlib_content <span style=color:#f92672>=</span> <span style=color:#66d9ef>Zlib</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Deflate</span><span style=color:#f92672>.</span>deflate(store)
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;x</span><span style=color:#ae81ff>\234\001</span><span style=color:#e6db74>*</span><span style=color:#ae81ff>\000\325\377</span><span style=color:#e6db74>blob 34</span><span style=color:#ae81ff>\000\320\225\321\201\321\202\321\214</span><span style=color:#e6db74> </span><span style=color:#ae81ff>\320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213</span><span style=color:#e6db74>, </span><span style=color:#ae81ff>\321\210\320\265\321\204</span><span style=color:#e6db74>?</span><span style=color:#ae81ff>\345</span><span style=color:#e6db74>3</span><span style=color:#ae81ff>\030</span><span style=color:#e6db74>S&#34;</span>
</span></span></code></pre></div><p>После этого запишем сжатую zlib&rsquo;ом строку в объект на диск. Определим путь к файлу, который будет записан (первые два символа хеша используются в качестве названия подкаталога, оставшиеся 38 — в качестве имени файла в этом каталоге). В Ruby для этой задачи можно использовать функцию <code>FileUtils.mkdir_p()</code> для создания подкаталога, если он не существует. Далее, откроем файл вызовом <code>File.open()</code> и запишем наши сжатые данные вызовом <code>write()</code> для полученного файлового дескриптора:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.git/objects/&#39;</span> <span style=color:#f92672>+</span> sha1<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>2</span><span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>+</span> sha1<span style=color:#f92672>[</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>38</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;.git/objects/d8/a734f44240bdf766c8df342664fde23d421d64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> require <span style=color:#e6db74>&#39;fileutils&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>FileUtils</span><span style=color:#f92672>.</span>mkdir_p(<span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>dirname(path))
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;.git/objects/bd&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>open(path, <span style=color:#e6db74>&#39;w&#39;</span>) { <span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> f<span style=color:#f92672>.</span>write zlib_content }
</span></span><span style=display:flex><span><span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>32</span>
</span></span></code></pre></div><p>Вот и всё, мы создали корректный объект-блоб для Git&rsquo;а. Все другие объекты создаются аналогично, меняется только запись о типе в заголовке (blob, commit, tree). Стоит добавить, что хотя в блобе может храниться почти любое содержимое, содержимое объектов-деревьев и объектов-коммитов записывается в очень строгом формате.</p><h2 id=ссылки-в-git class="relative group">Ссылки в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b8-%d0%b2-git aria-label=Якорь>#</a></span></h2><p>Для просмотра всей истории можно выполнить команду вроде <code>git log 1a410e</code>, но, опять же, требуется помнить, что именно коммит <code>1a410e</code> является последним, чтобы иметь возможность найти все наши объекты. Нам нужен файл-указатель с простым именем, который бы содержал это значение хеша SHA-1, чтобы можно было пользоваться этим файлом вместо хеша.</p><p>В Git&rsquo;е такие файлы, содержащие SHA-1, называются ссылками (&ldquo;refs&rdquo;) и располагаются в каталоге <code>.git/refs</code>. В нашем проекте этот каталог пока пуст, но в нём уже существует некоторая структура каталогов:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/refs
</span></span><span style=display:flex><span>.git/refs
</span></span><span style=display:flex><span>.git/refs/heads
</span></span><span style=display:flex><span>.git/refs/tags
</span></span><span style=display:flex><span>$ find .git/refs -type f
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><p>Чтобы создать новую ссылку, которая поможет вам вспомнить, какой коммит последний, по сути, необходимо сделать всего лишь следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#34;1a410efbd13591db07496601ebc7a059dd55cfe9&#34;</span> &gt; .git/refs/heads/master
</span></span></code></pre></div><p>Теперь в командах Git&rsquo;а вместо хеша можно использовать ссылку, только что созданную в каталоге heads:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline  master
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d second commit
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></span></code></pre></div><p>Тем не менее, редактировать данные файлы напрямую не рекомендуется. Git предоставляет безопасную команду <code>update-ref</code> для изменения ссылок:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span></code></pre></div><p>Вот что такое, по сути, ветка в Git&rsquo;е — простой указатель или ссылка на последнюю версию в работе. Для создания ветки, соответствующей состоянию второго коммита, можно выполнить следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git update-ref refs/heads/test cac0ca
</span></span></code></pre></div><p>Данная ветка будет содержать только коммиты, предшествующие выбранному:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline test
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d second commit
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></span></code></pre></div><p>Теперь наша база данных Git&rsquo;а схематично выглядит так, как показано на рисунке 9.4.</p><p>Insert 18333fig0904.png
Рисунок 9-4. Объекты в каталоге .git, а также указатели на вершины веток.</p><p>Когда выполняется команда <code>git branch (имя ветки)</code>, Git, по сути, выполняет <code>update-ref</code> для добавления хеша последнего коммита текущей ветки под указанным именем в виде новой ссылки.</p><h3 id=head class="relative group">HEAD <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#head aria-label=Якорь>#</a></span></h3><p>Вопрос в том, как же Git получает хеш последнего коммита при выполнении <code>git branch (имя ветки)</code>? Ответ содержится в файле HEAD. Данный файл является символической ссылкой на текущую ветку. Символическая ссылка отличается от обычной тем, что она содержит не сам хеш SHA-1, а указатель на другую ссылку. Если вы заглянете в этот файл, то увидите что-то такое:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .git/HEAD 
</span></span><span style=display:flex><span>ref: refs/heads/master
</span></span></code></pre></div><p>Если выполнить <code>git checkout test</code>, то содержимое файла изменится:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .git/HEAD 
</span></span><span style=display:flex><span>ref: refs/heads/test
</span></span></code></pre></div><p>При выполнении <code>git commit</code> Git создаёт объект-коммит, указывая его родителем тот объект, SHA-1 которого содержится в файле, на который ссылается HEAD.</p><p>Данный файл, конечно, можно редактировать вручную, но безопаснее использовать команду <code>symbolic-ref</code>. Получить значение HEAD данной командой можно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git symbolic-ref HEAD
</span></span><span style=display:flex><span>refs/heads/master
</span></span></code></pre></div><p>Изменить значение HEAD можно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git symbolic-ref HEAD refs/heads/test
</span></span><span style=display:flex><span>$ cat .git/HEAD 
</span></span><span style=display:flex><span>ref: refs/heads/test
</span></span></code></pre></div><p>Символическую ссылку на файл вне refs поставить нельзя:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git symbolic-ref HEAD test
</span></span><span style=display:flex><span>fatal: Refusing to point HEAD outside of refs/
</span></span></code></pre></div><h3 id=метки class="relative group">Метки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bc%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Мы рассмотрели три основных типа объектов Git&rsquo;а, но есть и четвёртый. Объект-метка очень похож на объект-коммит: он содержит имя поставившего метку, дату, сообщение и указатель. Разница же в том, что метка указывает на коммит, а не на дерево. Она похожа на ветку, которая никогда не перемещается — она всегда указывает на один и тот же коммит, она просто даёт ему понятное имя.</p><p>Как было сказано, метки бывают двух типов: аннотированные и легковесные. Легковесную метку можно сделать следующей командой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
</span></span></code></pre></div><p>Вот и всё! Легковесная метка — это ветка, которая никогда не перемещается. Аннотированная метка имеет более сложную структуру. При создании аннотированной метки Git создаёт специальный объект, на который будет указывать ссылка, а не просто указатель на коммит. Мы можем увидеть это, создав аннотированную метку (<code>-a</code> задаёт аннотированные метки):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span style=color:#e6db74>&#39;test tag&#39;</span>
</span></span></code></pre></div><p>Вот значение SHA-1 созданного объекта:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .git/refs/tags/v1.1 
</span></span><span style=display:flex><span>9585191f37f7b0fb9444f35a9bf50de191beadc2
</span></span></code></pre></div><p>Теперь выполним <code>cat-file</code> для этого хеша:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
</span></span><span style=display:flex><span>object 1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span><span style=display:flex><span>type commit
</span></span><span style=display:flex><span>tag v1.1
</span></span><span style=display:flex><span>tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May <span style=color:#ae81ff>23</span> 16:48:58 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test tag
</span></span></code></pre></div><p>Заметьте, в поле object записан SHA-1 коммита, для которого мы делали метку. Также стоит отметить, что это поле не обязательно указывает на коммит, но на любой объект в Git&rsquo;е. Например, в исходный код Git&rsquo;а мейнтейнер добавил свой открытый GPG-ключ в качестве блоба и поставил для него метку. Увидеть этот ключ можно, выполнив команду</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file blob junio-gpg-pub
</span></span></code></pre></div><p>в репозитории с исходным кодом Git&rsquo;а. В репозитории ядра Linux также есть метка, указывающая не на коммит — первая метка указывает на дерево первичного импорта.</p><h3 id=ссылки-на-удалённые-ветки class="relative group">Ссылки на удалённые ветки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b8-%d0%bd%d0%b0-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Третий тип ссылок, который мы рассмотрим — ссылка на удалённую ветку. Если вы добавили удалённый репозиторий и отправили (push) на него изменения, Git сохранит последнее отправленное значение SHA-1 в каталоге <code>refs/remotes</code> для всех отправленных веток. Например, можно добавить удалённый репозиторий <code>origin</code> и отправить туда ветку <code>master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote add origin git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>$ git push origin master
</span></span><span style=display:flex><span>Counting objects: 11, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>5/5<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>7/7<span style=color:#f92672>)</span>, <span style=color:#ae81ff>716</span> bytes, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>7</span> <span style=color:#f92672>(</span>delta 2<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>4</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>To git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>   a11bef0..ca82a6d  master -&gt; master
</span></span></code></pre></div><p>Позже вы сможете посмотреть, где находилась ветка <code>master</code> с сервера <code>origin</code> во время последнего соединения с сервером, заглянув в файл <code>refs/remotes/origin/master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .git/refs/remotes/origin/master 
</span></span><span style=display:flex><span>ca82a6dff817ec66f44342007202690a93763949
</span></span></code></pre></div><p>Ссылки на удалённые ветки отличаются от обычных веток (ссылки в <code>refs/heads</code>) тем, что на них нельзя переключиться с помощью <code>git checkout</code>. Git работает с ними как с закладками, указывающими на последнее состояние соответствующих веток на ваших серверах.</p><h2 id=pack-файлы class="relative group">Pack-файлы <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pack-%d1%84%d0%b0%d0%b9%d0%bb%d1%8b aria-label=Якорь>#</a></span></h2><p>Вернёмся к базе объектов в нашем тестовом репозитории. К этому моменту их должно быть 11 штук: 4 блоба, 3 дерева, 3 коммита и одна метка:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/objects -type f
</span></span><span style=display:flex><span>.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 <span style=color:#75715e># tree 2</span>
</span></span><span style=display:flex><span>.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 <span style=color:#75715e># commit 3</span>
</span></span><span style=display:flex><span>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a <span style=color:#75715e># test.txt v2</span>
</span></span><span style=display:flex><span>.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 <span style=color:#75715e># tree 3</span>
</span></span><span style=display:flex><span>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 <span style=color:#75715e># test.txt v1</span>
</span></span><span style=display:flex><span>.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 <span style=color:#75715e># tag</span>
</span></span><span style=display:flex><span>.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d <span style=color:#75715e># commit 2</span>
</span></span><span style=display:flex><span>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 <span style=color:#75715e># &#39;test content&#39;</span>
</span></span><span style=display:flex><span>.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 <span style=color:#75715e># tree 1</span>
</span></span><span style=display:flex><span>.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 <span style=color:#75715e># new.txt</span>
</span></span><span style=display:flex><span>.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d <span style=color:#75715e># commit 1</span>
</span></span></code></pre></div><p>Git сжал содержимое этих файлов при помощи zlib, к тому же мы не записывали много данных, поэтому все эти файлы вместе занимают всего 925 байт. Для того чтобы продемонстрировать одну интересную возможность Git&rsquo;а, добавим файл побольше. Добавим файл repo.rb из библиотеки Grit, с которой мы работали ранее, он занимает примерно 12 Кбайт:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl https://raw.github.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb
</span></span><span style=display:flex><span>$ git add repo.rb 
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;added repo.rb&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master 484a592<span style=color:#f92672>]</span> added repo.rb
</span></span><span style=display:flex><span> <span style=color:#ae81ff>3</span> files changed, <span style=color:#ae81ff>459</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>2</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> delete mode <span style=color:#ae81ff>100644</span> bak/test.txt
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>100644</span> repo.rb
</span></span><span style=display:flex><span> rewrite test.txt <span style=color:#f92672>(</span>100%<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Если мы посмотрим на полученное дерево, мы увидим значение SHA-1, которое получил блоб для файла repo.rb:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p master^<span style=color:#f92672>{</span>tree<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</span></span></code></pre></div><p>Посмотрим, сколько этот объект занимает места на диске:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ du -b .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e
</span></span><span style=display:flex><span>4102	.git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e
</span></span></code></pre></div><p>Теперь изменим немного данный файл и посмотрим на результат:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;# testing&#39;</span> &gt;&gt; repo.rb 
</span></span><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;modified repo a bit&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master ab1afef<span style=color:#f92672>]</span> modified repo a bit
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Взглянув на дерево, полученное в результате коммита, мы увидим любопытную вещь:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p master^<span style=color:#f92672>{</span>tree<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob 05408d195263d853f09dca71d55116663690c27c      repo.rb
</span></span><span style=display:flex><span><span style=color:#ae81ff>100644</span> blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</span></span></code></pre></div><p>Теперь файлу repo.rb соответствует другой объект-блоб. Это означает, что даже одна единственная строка, добавленная в конец 400-строчного файла, требует создания абсолютно нового объекта:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ du -b .git/objects/05/408d195263d853f09dca71d55116663690c27c
</span></span><span style=display:flex><span>4109	.git/objects/05/408d195263d853f09dca71d55116663690c27c
</span></span></code></pre></div><p>Итак, мы имеем два почти одинаковых объекта занимающих по 4 Кбайта на диске. Было бы неплохо, если бы Git сохранял только один объект целиком, а другой как разницу между ним и первым объектом.</p><p>Оказывается, что Git так и делает. Первоначальный формат для сохранения объектов в Git&rsquo;е называется рыхлым форматом (loose format) объектов. Однако, время от времени Git упаковывает несколько таких объектов в один pack-файл (pack в пер. с англ. — упаковывать, уплотнять) для сохранения места на диске и повышения эффективности. Это происходит, когда &ldquo;рыхлых&rdquo; объектов становится слишком много, а также при вызове <code>git gc</code> вручную, и при отправке изменений на удалённый сервер. Чтобы посмотреть, как происходит упаковка, можно выполнить команду <code>git gc</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git gc
</span></span><span style=display:flex><span>Counting objects: 17, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Delta compression using <span style=color:#ae81ff>2</span> threads.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>13/13<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>17/17<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>17</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>10</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Если вы загляните в каталог с объектами, вы обнаружите, что большая часть объектов исчезла, зато появились два новых файла:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/objects -type f
</span></span><span style=display:flex><span>.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293
</span></span><span style=display:flex><span>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span><span style=display:flex><span>.git/objects/info/packs
</span></span><span style=display:flex><span>.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
</span></span><span style=display:flex><span>.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack
</span></span></code></pre></div><p>Оставшиеся объекты — блобы, на которые не указывает ни один коммит. В нашем случае это созданные ранее объекты: содержащий строку &ldquo;есть проблемы, шеф?&rdquo;, и блоб содержащий &ldquo;test content&rdquo;. В силу того, что ни в одном коммите данные файлы не присутствуют, они считаются &ldquo;висячими&rdquo; и не упаковываются.</p><p>Остальные файлы — это pack-файл и его индекс. Pack-файл — это файл, который теперь содержит все объекты, которые были удалены. А индекс — это файл, в котором записаны их смещения в pack-файле, что даёт возможность быстро найти нужный объект. Упаковка данных положительно повлияла на общий размер файлов, если до вызова <code>gc</code> они занимали примерно 8 Кбайт, то pack-файл занимает всего 4 Кбайт. Упаковкой объектов мы смогли сократить место, занятое на диске, в два раза.</p><p>Как Git это делает? При упаковке Git ищет файлы, которые похожи по имени и размеру, и сохраняет только разницу между двумя версиями файла. Можно рассмотреть pack-файл подробнее и понять, какие действия были выполнены для сжатия. Для просмотра содержимого упакованного файла существует служебная команда <code>git verify-pack</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git verify-pack -v <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
</span></span><span style=display:flex><span>0155eb4229851634a0f03eb265b69f5a2d56f341 tree   <span style=color:#ae81ff>71</span> <span style=color:#ae81ff>76</span> <span style=color:#ae81ff>5400</span>
</span></span><span style=display:flex><span>05408d195263d853f09dca71d55116663690c27c blob   <span style=color:#ae81ff>12908</span> <span style=color:#ae81ff>3478</span> <span style=color:#ae81ff>874</span>
</span></span><span style=display:flex><span>09f01cea547666f58d6a8d809583841a7c6f0130 tree   <span style=color:#ae81ff>106</span> <span style=color:#ae81ff>107</span> <span style=color:#ae81ff>5086</span>
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9 commit <span style=color:#ae81ff>225</span> <span style=color:#ae81ff>151</span> <span style=color:#ae81ff>322</span>
</span></span><span style=display:flex><span>1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>19</span> <span style=color:#ae81ff>5381</span>
</span></span><span style=display:flex><span>3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   <span style=color:#ae81ff>101</span> <span style=color:#ae81ff>105</span> <span style=color:#ae81ff>5211</span>
</span></span><span style=display:flex><span>484a59275031909e19aadb7c92262719cfcdf19a commit <span style=color:#ae81ff>226</span> <span style=color:#ae81ff>153</span> <span style=color:#ae81ff>169</span>
</span></span><span style=display:flex><span>83baae61804e65cc73a7201a7252750c76066a30 blob   <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>19</span> <span style=color:#ae81ff>5362</span>
</span></span><span style=display:flex><span>9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    <span style=color:#ae81ff>136</span> <span style=color:#ae81ff>127</span> <span style=color:#ae81ff>5476</span>
</span></span><span style=display:flex><span>9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>5193</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>05408d195263d853f09dca71d55116663690c27c
</span></span><span style=display:flex><span>ab1afef80fac8e34258ff41fc1b867c702daa24b commit <span style=color:#ae81ff>232</span> <span style=color:#ae81ff>157</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d commit <span style=color:#ae81ff>226</span> <span style=color:#ae81ff>154</span> <span style=color:#ae81ff>473</span>
</span></span><span style=display:flex><span>d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   <span style=color:#ae81ff>36</span> <span style=color:#ae81ff>46</span> <span style=color:#ae81ff>5316</span>
</span></span><span style=display:flex><span>e3f094f522629ae358806b17daf78246c27c007b blob   <span style=color:#ae81ff>1486</span> <span style=color:#ae81ff>734</span> <span style=color:#ae81ff>4352</span>
</span></span><span style=display:flex><span>f8f51d7d8a1760462eca26eebafde32087499533 tree   <span style=color:#ae81ff>106</span> <span style=color:#ae81ff>107</span> <span style=color:#ae81ff>749</span>
</span></span><span style=display:flex><span>fa49b077972391ad58037050f2a75f74e3671e92 blob   <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>856</span>
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit <span style=color:#ae81ff>177</span> <span style=color:#ae81ff>122</span> <span style=color:#ae81ff>627</span>
</span></span><span style=display:flex><span>chain length <span style=color:#f92672>=</span> 1: <span style=color:#ae81ff>1</span> object
</span></span><span style=display:flex><span>pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok
</span></span></code></pre></div><p>Здесь блоб <code>9bc1d</code>, который, как мы помним, был первой версией файла repo.rb, ссылается на блоб <code>05408</code>, который был второй его версией. Третья колонка в выводе — это размер содержимого объекта. Как видите, содержимое <code>05408</code> занимает 12 Кбайт, при этом содержимое <code>9bc1d</code> занимает всего лишь 7 байт. Что интересно, вторая версия сохраняется &ldquo;как есть&rdquo;, а исходная — в виде дельты. Это из-за того, что необходимость получения доступа к последней версии файла является более вероятной.</p><p>Также здорово, что переупаковку можно выполнять в любое время. Время от времени Git будет выполнять её автоматически, чтобы сэкономить место на диске. Если вдруг этого недостаточно, всегда можно выполнить <code>git gc</code> вручную.</p><h2 id=спецификации-ссылок class="relative group">Спецификации ссылок <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d0%b8-%d1%81%d1%81%d1%8b%d0%bb%d0%be%d0%ba aria-label=Якорь>#</a></span></h2><p>Во всей книге использовались простые связи между ветками в удалённых репозиториях и локальными ветками, но они могут быть и более сложными.
Предположим, мы добавили следующий удалённый репозиторий:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote add origin git@github.com:schacon/simplegit-progit.git
</span></span></code></pre></div><p>Данный вызов добавляет секцию в файл <code>.git/config</code>, в которой заданы имя удалённого репозитория (<code>origin</code>), его URL и спецификация ссылок для извлечения данных:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>remote <span style=color:#e6db74>&#34;origin&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>       url <span style=color:#f92672>=</span> git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/*:refs/remotes/origin/*
</span></span></code></pre></div><p>Формат спецификации следующий: опциональный <code>+</code>, далее пара <code>&lt;src>:&lt;dst></code>, где <code>&lt;src></code> — шаблон ссылок в удалённом репозитории, а <code>&lt;dst></code> — соответствующий шаблон локальных ссылок. Символ <code>+</code> сообщает Git&rsquo;у, что обновление необходимо выполнять даже в том случае, если оно не является перемоткой.</p><p>В случае настроек по умолчанию, которые записываются во время выполнения <code>git remote add</code>, Git выбирает все ссылки из <code>refs/heads/</code> на стороне сервера, и записывает их в локальный каталог <code>refs/remotes/origin/</code>. Таким образом, если на сервере есть ветка <code>master</code>, журнал данной ветки можно получить, вызвав:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log origin/master
</span></span><span style=display:flex><span>$ git log remotes/origin/master
</span></span><span style=display:flex><span>$ git log refs/remotes/origin/master
</span></span></code></pre></div><p>Все эти команды эквивалентны, так как Git развернёт каждую запись до <code>refs/remotes/origin/master</code>.</p><p>Если хочется, чтобы Git забирал при обновлении только ветку <code>master</code>, а не все доступные на сервере, можно изменить соответствующую строку в файле конфигурации на следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fetch <span style=color:#f92672>=</span> +refs/heads/master:refs/remotes/origin/master
</span></span></code></pre></div><p>Данный refspec будет использоваться по умолчанию при вызове <code>git fetch</code> для данного удалённого репозитория. Если же вам нужно изменить спецификацию всего раз, можно задать refspec в командной строке. Например, чтобы получить данные из ветки <code>master</code> из удалённого репозитория в локальную <code>origin/mymaster</code>, можно выполнить</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fetch origin master:refs/remotes/origin/mymaster
</span></span></code></pre></div><p>Конечно, можно задать несколько спецификаций. Получить данные нескольких веток из командной строки можно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fetch origin master:refs/remotes/origin/mymaster <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>   topic:refs/remotes/origin/topic
</span></span><span style=display:flex><span>From git@github.com:schacon/simplegit
</span></span><span style=display:flex><span> ! <span style=color:#f92672>[</span>rejected<span style=color:#f92672>]</span>        master     -&gt; origin/mymaster  <span style=color:#f92672>(</span>non fast forward<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      topic      -&gt; origin/topic
</span></span></code></pre></div><p>В данном случае слияние ветки master выполнить не удалось, поскольку слияние не было просто перемоткой. Такое поведение можно изменить, добавив перед спецификацией знак <code>+</code>.</p><p>В конфигурационном файле также можно задавать несколько спецификаций для получения обновлений. Чтобы каждый раз получать обновления веток master и experiment, добавьте две такие строки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>remote <span style=color:#e6db74>&#34;origin&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>       url <span style=color:#f92672>=</span> git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/master:refs/remotes/origin/master
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/experiment:refs/remotes/origin/experiment
</span></span></code></pre></div><p>Задавать частичные регулярные выражения в спецификации нельзя, следующая запись неверна:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fetch <span style=color:#f92672>=</span> +refs/heads/qa*:refs/remotes/origin/qa*
</span></span></code></pre></div><p>Тем не менее, можно использовать пространства имён для получения похожего результата. Если имеется команда QA (сокр. от quality assurance — контроль качества), которая использует свои несколько веток, и вы хотите получать только ветку master и все ветки команды QA, а остальные — нет, то можно добавить в конфигурацию следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>remote <span style=color:#e6db74>&#34;origin&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>       url <span style=color:#f92672>=</span> git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/master:refs/remotes/origin/master
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/qa/*:refs/remotes/origin/qa/*
</span></span></code></pre></div><p>Если ваш рабочий процесс является сложным, и разные команды: разработчики, тестеры, внедренцы — коммитят в разные ветки одного и того же проекта, то так вы с лёгкостью можете разделить их по разным пространствам имён.</p><h3 id=спецификации-ссылок-для-команды-push class="relative group">Спецификации ссылок для команды push <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d0%b8-%d1%81%d1%81%d1%8b%d0%bb%d0%be%d0%ba-%d0%b4%d0%bb%d1%8f-%d0%ba%d0%be%d0%bc%d0%b0%d0%bd%d0%b4%d1%8b-push aria-label=Якорь>#</a></span></h3><p>Это хорошо, что мы научились получать данные по ссылкам в отдельных пространствах имён, но нам же ещё надо сделать так, чтобы команда QA сначала смогла отправить свои ветки в пространство имён <code>qa/</code>. Мы решим эту задачу, используя спецификации ссылок для команды <code>push</code>.</p><p>Если разработчик из команды QA хочет отправить изменения из локальной ветки <code>master</code> в <code>qa/master</code> на удалённом сервере, он может выполнить команду</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin master:refs/heads/qa/master
</span></span></code></pre></div><p>Если хочется, чтобы Git автоматически делал так при вызове <code>git push origin</code>, можно добавить в конфигурационный файл значение для <code>push</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>remote <span style=color:#e6db74>&#34;origin&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>       url <span style=color:#f92672>=</span> git@github.com:schacon/simplegit-progit.git
</span></span><span style=display:flex><span>       fetch <span style=color:#f92672>=</span> +refs/heads/*:refs/remotes/origin/*
</span></span><span style=display:flex><span>       push <span style=color:#f92672>=</span> refs/heads/master:refs/heads/qa/master
</span></span></code></pre></div><p>Опять же, это приведёт к тому, что при вызове <code>git push origin</code> локальная ветка <code>master</code> будет по умолчанию отправляться в удалённую ветку <code>qa/master</code>.</p><h3 id=удаление-ссылок class="relative group">Удаление ссылок <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d1%81%d1%8b%d0%bb%d0%be%d0%ba aria-label=Якорь>#</a></span></h3><p>Кроме всего прочего, спецификации ссылок можно использовать следующим образом для удаления ссылок на удалённом сервере:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin :topic
</span></span></code></pre></div><p>Так как спецификация ссылки задаётся в виде <code>&lt;src>:&lt;dst></code>, опускание <code>&lt;src></code> означает, что указанную ветку на удалённом сервере надо сделать пустой, что приводит к её удалению.</p><h2 id=протоколы-передачи class="relative group">Протоколы передачи <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb%d1%8b-%d0%bf%d0%b5%d1%80%d0%b5%d0%b4%d0%b0%d1%87%d0%b8 aria-label=Якорь>#</a></span></h2><p>Git может передавать данные между репозиториями одним из двух основных способов: через HTTP или через &ldquo;умные&rdquo; протоколы для транспортов <code>file://</code>, <code>ssh://</code> и <code>git://</code>. В данном разделе мы кратко рассмотрим, как эти два протокола работают.</p><h3 id=тупой-протокол class="relative group">Тупой протокол <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%82%d1%83%d0%bf%d0%be%d0%b9-%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb aria-label=Якорь>#</a></span></h3><p>Git-транспорт, работающий по HTTP, часто называют &ldquo;тупым&rdquo; протоколом, потому что для его работы во время передачи данных не требуется исполнения никакого Git-специфичного кода на стороне сервера. Процесс извлечения данных представляет собой последовательность GET-запросов, клиент обращается к стандартной структуре каталогов Git&rsquo;а. Давайте рассмотрим процесс получения данных по HTTP на примере библиотеки simplegit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone http://github.com/schacon/simplegit-progit.git
</span></span></code></pre></div><p>Первое действие, выполняемое данной командой — загрузка файла <code>info/refs</code>. Данный файл записывается командой <code>update-server-info</code>, поэтому для использования HTTP-транспорта необходимо запускать эту команду в перехватчике <code>post-receive</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET info/refs
</span></span><span style=display:flex><span>ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
</span></span></code></pre></div><p>Теперь у нас имеется список удалённых веток и их хеши. Далее, нам надо посмотреть, куда ссылается HEAD, чтобы знать на какую версию переключиться после завершения работы команды.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET HEAD
</span></span><span style=display:flex><span>ref: refs/heads/master
</span></span></code></pre></div><p>Нам надо переключиться на ветку <code>master</code> после завершения процесса.
На данном этапе можно начать обход дерева. Начальной точкой является объект-коммит <code>ca82a6</code>, о чём мы узнали из файла <code>info/refs</code>, и мы начинаем с его загрузки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span><span style=color:#f92672>(</span><span style=color:#ae81ff>179</span> bytes of binary data<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Объект получен, он был в рыхлом формате на сервере, и мы получили его по HTTP, используя статический GET-запрос. Теперь можно его разархивировать, отрезать заголовок и посмотреть на его содержимое:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
</span></span><span style=display:flex><span>parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>author Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1205815931</span> -0700
</span></span><span style=display:flex><span>committer Scott Chacon &lt;schacon@gmail.com&gt; <span style=color:#ae81ff>1240030591</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>changed the version number
</span></span></code></pre></div><p>Далее, необходимо загрузить ещё два объекта: <code>cfda3b</code> — объект-дерево, который обозначен как содержимое только что загруженного коммита, и <code>085bb3</code> — родительский коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span><span style=color:#f92672>(</span><span style=color:#ae81ff>179</span> bytes of data<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Так, мы получили следующий объект-коммит. Прихватим и наш объект-дерево:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
</span></span><span style=display:flex><span><span style=color:#f92672>(</span><span style=color:#ae81ff>404</span> - Not Found<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Ой! Похоже, этого объекта-дерева нет на сервере в рыхлом формате, поэтому мы получили ответ 404. У этого могут быть две причины: или объект в другом репозитории, или в упакованном файле текущего репозитория. Сперва Git проверяет список альтернативных репозиториев:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/info/http-alternates
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>empty file<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Если бы этот запрос вернул нам список альтернативных URL, Git обратился бы по ним в поиске &ldquo;рыхлых&rdquo; и pack-файлов — это такой механизм, позволяющий не дублировать данные проектам, являющимися форками друг для друга. Так как в данном случае альтернативных адресов нет, объект должен быть в pack-файле. Для того чтобы узнать, какие упакованные файлы есть на сервере, необходимо загрузить файл со списком pack-файлов: <code>objects/info/packs</code> (который также генерируется <code>update-server-info</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/info/packs
</span></span><span style=display:flex><span>P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
</span></span></code></pre></div><p>На сервере имеется только один pack-файл, поэтому объект точно там, но необходимо проверить индексный файл, чтобы в этом убедиться. Если бы на сервере было несколько pack-файлов, загрузив сначала индексы, мы смогли бы определить, в каком именно pack-файле находится нужный нам объект:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>4k of binary data<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Теперь, когда мы получили индекс упакованного файла, можно проверить, тут ли наш объект. Это возможно благодаря тому, что в индексе хранятся SHA-1 объектов содержащихся в pack-файле, а также их смещения. Необходимый объект там присутствует, так что продолжим и получим весь pack-файл:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>13k of binary data<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Итак, мы получили наш объект-дерево, можно продолжить обход списка коммитов. Все они лежат внутри упакованного файла, который мы только что скачали, так что снова обращаться к серверу не надо. Git извлекает рабочую копию ветки <code>master</code>, на которую ссылается HEAD.</p><p>Полный вывод этого процесса выглядит так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone http://github.com/schacon/simplegit-progit.git
</span></span><span style=display:flex><span>Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
</span></span><span style=display:flex><span>got ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>walk ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>Getting alternates list <span style=color:#66d9ef>for</span> http://github.com/schacon/simplegit-progit.git
</span></span><span style=display:flex><span>Getting pack list <span style=color:#66d9ef>for</span> http://github.com/schacon/simplegit-progit.git
</span></span><span style=display:flex><span>Getting index <span style=color:#66d9ef>for</span> pack 816a9b2334da9953e530f27bcac22082a9f5b835
</span></span><span style=display:flex><span>Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
</span></span><span style=display:flex><span> which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
</span></span><span style=display:flex><span>walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>walk a11bef06a3f659402fe7563abf99ad00de2209e6
</span></span></code></pre></div><h3 id=умный-протокол class="relative group">Умный протокол <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%bc%d0%bd%d1%8b%d0%b9-%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb aria-label=Якорь>#</a></span></h3><p>Методика работы HTTP проста, но неэффективна, поэтому чаще используются &ldquo;умные&rdquo; протоколы. Эти протоколы обслуживаются процессом на стороне сервера, который учитывает особенности работы Git&rsquo;а — он считывает локальные данные, выясняет, что есть и чего не хватает на клиенте, и генерирует для него соответствующие данные. Существует два набора процессов передачи данных: процессы для загрузки данных и процессы для скачивания.</p><h4 id=загрузка-данных class="relative group">Загрузка данных <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b0-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85 aria-label=Якорь>#</a></span></h4><p>Для загрузки данных на удалённый сервер используются процессы <code>send-pack</code> и <code>receive-pack</code>. Процесс <code>send-pack</code> запускается на стороне клиента и подключается к <code>receive-pack</code> на стороне сервера.</p><p>Например, выполняется команда <code>git push origin master</code> и <code>origin</code> определён как URL использующий протокол SSH. Git запускает процесс <code>send-pack</code>, который устанавливает соединение с сервером по протоколу SSH. Он пытается запустить команду на удалённом сервере через вызов команды ssh, который выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ssh -x git@github.com <span style=color:#e6db74>&#34;git-receive-pack &#39;schacon/simplegit-progit.git&#39;&#34;</span>
</span></span><span style=display:flex><span>005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs
</span></span><span style=display:flex><span>003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span>
</span></span></code></pre></div><p>Команда <code>git-receive-pack</code> тут же посылает в ответ по одной строке на каждую из имеющихся в наличии ссылок — в данном случае только ветку <code>master</code> и её SHA. Первая строка также содержит список возможностей сервера (здесь это <code>report-status</code> и <code>delete-refs</code>).</p><p>Каждая строка начинается с 4-байтового шестнадцатеричного значения, содержащего длину оставшейся строки. Первая строка начинается с 005b, это 91 в 16-ричном виде, значит в этой строке ещё 91 байт. Следующая строка начинается с 003e, что означает 62, то есть надо прочитать 62 байта. Далее следует строка 0000, которая означает, что сервер закончил листинг своих ссылок.</p><p>Теперь, когда процесс <code>send-pack</code> выяснил состояние сервера, он определяет коммиты, которые есть локально, но которых нет на сервере. Для каждой ссылки, которая будет обновлена текущей командой <code>push</code>, процесс <code>send-pack</code> передаёт процессу <code>receive-pack</code> эти данные. Например, если мы обновляем ветку <code>master</code>, и добавляем ветку <code>experiment</code>, ответ <code>send-pack</code> будет выглядеть следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
</span></span><span style=display:flex><span><span style=color:#ae81ff>00670000000000000000000000000000000000000000</span> cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span>
</span></span></code></pre></div><p>Значение SHA-1 из одних нулей означает, что раньше здесь ничего не было — так получилось из-за того, что мы добавили новую ссылку <code>experiment</code>. Если бы мы удаляли ссылку, было бы на оборот: одни нули были бы справа.</p><p>Git отправляет строку для каждой ссылки, для которой производится обновление. В строке содержится старый хеш, новый хеш и имя обновляемой ссылки. Первая строка также содержит возможности клиента. Далее, клиент загружает упакованный файл со всеми объектами, которых ещё нет на сервере. В конце, сервер отвечает статусным сообщением сообщающем об успехе (или ошибке):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>000Aunpack ok
</span></span></code></pre></div><h4 id=скачивание-данных class="relative group">Скачивание данных <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%ba%d0%b0%d1%87%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85 aria-label=Якорь>#</a></span></h4><p>Если выполняется скачивание данных, используются процессы <code>fetch-pack</code> и <code>upload-pack</code>. Клиент запускает процесс <code>fetch-pack</code>, который подключается к процессу <code>upload-pack</code> на удалённой машине для определения, какие данные будут переданы.</p><p>Существуют разные способы запуска <code>upload-pack</code> на удалённом репозитории. Можно запустить его по SSH так же, как и <code>receive-pack</code>. Ещё можно вызвать процесс через Git-демон, по умолчанию принимающий соединения на порте 9418. Процесс <code>fetch-pack</code> после подключения отправляет демону данные примерно следующего вида:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>003fgit-upload-pack schacon/simplegit-progit.git<span style=color:#ae81ff>\0</span>host<span style=color:#f92672>=</span>myserver.com<span style=color:#ae81ff>\0</span>
</span></span></code></pre></div><p>Начальные 4 байта задают размер последующих данных, далее следует команда, которую следует запустить, завершаемая нулевым байтом, а потом имя сервера и последний нулевой байт. Git-демон проверяет возможность выполнения команды, а также, что репозиторий существует и имеет необходимые права доступа. Если всё хорошо, демон запускает процесс <code>upload-pack</code> и передаёт запрос ему.</p><p>Если извлечение данных производится по SSH, <code>fetch-pack</code> выполняет другие действия:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ssh -x git@github.com <span style=color:#e6db74>&#34;git-upload-pack &#39;schacon/simplegit-progit.git&#39;&#34;</span>
</span></span></code></pre></div><p>В обоих случаях, после того как <code>fetch-pack</code> подключится, <code>upload-pack</code> передаст обратно следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0088ca82a6dff817ec66f44342007202690a93763949 HEAD<span style=color:#ae81ff>\0</span>multi_ack thin-pack <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  side-band side-band-64k ofs-delta shallow no-progress include-tag
</span></span><span style=display:flex><span>003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
</span></span><span style=display:flex><span>003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span>
</span></span></code></pre></div><p>Это очень похоже на ответ <code>receive-pack</code>, но только возможности другие. Вдобавок <code>upload-pack</code> отсылает обратно ссылку HEAD, чтобы клиент понимал, на какую ветку переключиться, если выполняется клонирование.</p><p>На данном этапе процесс <code>fetch-pack</code> смотрит на объекты, имеющиеся в наличии, и для недостающих объектов отвечает словом &ldquo;want&rdquo; и за ним SHA объекта. Для уже имеющихся объектов процесс отправляет их хеши со словом &ldquo;have&rdquo;. В конце списка он пишет &ldquo;done&rdquo;, и это даёт понять процессу <code>upload-pack</code>, что пора начинать отправлять упакованный файл с необходимыми данными:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
</span></span><span style=display:flex><span>0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000</span>
</span></span><span style=display:flex><span>0009done
</span></span></code></pre></div><p>Это самый основной случай передачи данных. В более сложных случаях клиент поддерживает функции <code>multi_ack</code> или <code>side-band</code>, но этот пример иллюстрирует основные взаимодействия, используемые процессами умного протокола.</p><h2 id=обслуживание-и-восстановление-данных class="relative group">Обслуживание и восстановление данных <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d1%81%d0%bb%d1%83%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b8-%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85 aria-label=Якорь>#</a></span></h2><p>Иногда требуется выполнить очистку — сделать репозиторий более компактным, почистить импортированный репозиторий или восстановить потерянную работу. Данный раздел охватывает некоторые из этих сценариев.</p><h3 id=обслуживание class="relative group">Обслуживание <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d1%81%d0%bb%d1%83%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5 aria-label=Якорь>#</a></span></h3><p>Иногда Git сам выполняет команду, запускающую автоматический сборщик мусора. Чаще всего эта команда ничего не делает. Однако, если неупакованных объектов слишком много или у вас слишком много pack-файлов, Git запускает полноценную команду <code>git gc</code>. Здесь <code>gc</code> это сокращение от &ldquo;garbage collect&rdquo;, что означает &ldquo;сборка мусора&rdquo;. Эта команда выполняет несколько действий: собирает все объекты в рыхлом формате и упаковывает их в pack-файлы, объединяет несколько упакованных файлов в один большой, удаляет объекты, недостижимые ни из одного коммита и хранящиеся дольше нескольких месяцев.</p><p>Вы также можете запустить сборку мусора вручную:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git gc --auto
</span></span></code></pre></div><p>Опять же, как правило, эта команда ничего не делает. Необходимо иметь 7000 несжатых объектов или более 50 упакованных файлов, чтобы запустился настоящий <code>gc</code>. Данные пределы можно изменить с помощью параметров <code>gc.auto</code> и <code>gc.autopacklimit</code> в конфигурационном файле.</p><p>Другое действие, выполняемое <code>gc</code> — упаковка ссылок в единый файл. Предположим, репозиторий содержит следующие ветки и теги:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find .git/refs -type f
</span></span><span style=display:flex><span>.git/refs/heads/experiment
</span></span><span style=display:flex><span>.git/refs/heads/master
</span></span><span style=display:flex><span>.git/refs/tags/v1.0
</span></span><span style=display:flex><span>.git/refs/tags/v1.1
</span></span></code></pre></div><p>Если выполнить <code>git gc</code>, данные файлы в каталоге <code>refs</code> перестанут существовать. Git перенесёт их в файл <code>.git/packed-refs</code> в угоду эффективности. Файл будет иметь следующий вид:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .git/packed-refs 
</span></span><span style=display:flex><span><span style=color:#75715e># pack-refs with: peeled </span>
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
</span></span><span style=display:flex><span>ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
</span></span><span style=display:flex><span>9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
</span></span><span style=display:flex><span>^1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span></code></pre></div><p>При обновлении ссылки Git не будет редактировать этот файл, а добавит новый файл в <code>refs/heads</code>. Для получения хеша для нужной ссылки Git сначала проверит наличие ссылки в каталоге <code>refs</code>, а к файлу <code>packed-refs</code> обратится только в случае неудачи. Однако, если в каталоге <code>refs</code> файла нет, скорее всего, он в <code>packed-refs</code>.</p><p>Заметьте, последняя строка файла начинается с <code>^</code>. Это означает, что метка непосредственно над ней является аннотированной и данная строка — это коммит, на который аннотированная метка указывает.</p><h3 id=восстановление-данных class="relative group">Восстановление данных <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85 aria-label=Якорь>#</a></span></h3><p>В какой-то момент при работе с Git&rsquo;ом вы нечаянно можете потерять коммит. Как правило, такое случается, когда вы удаляете ветку, в которой находились некоторые наработки, а потом оказывается, что они всё-таки были нужными. Либо вы жёстко сбросили ветку, тем самым отказавшись от коммитов, которые теперь понадобились. Как же в таком случае заполучить свои коммиты обратно?</p><p>Рассмотрим пример, в котором жёстко сбросим ветку master в тестовом репозитории на какой-нибудь более ранний коммит и затем восстановим потерянные коммиты. Для начала рассмотрим, в каком состоянии находится репозиторий на данном этапе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline
</span></span><span style=display:flex><span>ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
</span></span><span style=display:flex><span>484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d second commit
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></span></code></pre></div><p>Теперь сдвинем ветку <code>master</code> на несколько коммитов назад:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span><span style=display:flex><span>HEAD is now at 1a410ef third commit
</span></span><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d second commit
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></span></code></pre></div><p>Итак, теперь два последних коммита по-настоящему потеряны — они не достижимы ни из одной ветки. Необходимо найти SHA последнего коммита и создать ветку, указывающую на него. Сложность в том, чтобы найти этот самый SHA последнего коммита, ведь вряд ли вы его запомнили, да?</p><p>Зачастую самый быстрый способ — использовать инструмент под названием <code>git reflog</code>. Во время вашей работы Git записывает все изменения HEAD. Каждый раз при переключении веток и коммите, добавляется запись в reflog. Также обновление производится при вызове <code>git update-ref</code>, это, в частности, является причиной необходимости использования этой команды вместо прямой записи значения хеша в ref-файл, как было рассмотрено в разделе &ldquo;Ссылки в Git&rdquo;. Итак, изменения HEAD в хронологическом порядке можно увидеть, вызвав <code>git reflog</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reflog
</span></span><span style=display:flex><span>1a410ef HEAD@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD
</span></span><span style=display:flex><span>ab1afef HEAD@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD
</span></span></code></pre></div><p>Здесь мы видим два коммита, на которых мы когда-то находились, однако информации не так много. Более интересный вывод можно получить, используя <code>git log -g</code>, что даст стандартный вывод лога для записей из reflog:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -g
</span></span><span style=display:flex><span>commit 1a410efbd13591db07496601ebc7a059dd55cfe9
</span></span><span style=display:flex><span>Reflog: HEAD@<span style=color:#f92672>{</span>0<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>Scott Chacon &lt;schacon@gmail.com&gt;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Reflog message: updating HEAD
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri May <span style=color:#ae81ff>22</span> 18:22:37 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    third commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit ab1afef80fac8e34258ff41fc1b867c702daa24b
</span></span><span style=display:flex><span>Reflog: HEAD@<span style=color:#f92672>{</span>1<span style=color:#f92672>}</span> <span style=color:#f92672>(</span>Scott Chacon &lt;schacon@gmail.com&gt;<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Reflog message: updating HEAD
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gmail.com&gt;
</span></span><span style=display:flex><span>Date:   Fri May <span style=color:#ae81ff>22</span> 18:15:24 <span style=color:#ae81ff>2009</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     modified repo a bit
</span></span></code></pre></div><p>Похоже, что нижний коммит — это тот, который мы потеряли, и он может быть восстановлен созданием ветки, указывающей на него. Например, создадим ветку с именем <code>recover-branch</code>, указывающую на этот коммит (ab1afef):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch recover-branch ab1afef
</span></span><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline recover-branch
</span></span><span style=display:flex><span>ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
</span></span><span style=display:flex><span>484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
</span></span><span style=display:flex><span>1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
</span></span><span style=display:flex><span>cac0cab538b970a37ea1e769cbbde608743bc96d second commit
</span></span><span style=display:flex><span>fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></span></code></pre></div><p>Здорово, теперь у нас есть ветка <code>recover-branch</code>, указывающая туда, куда ранее указывала <code>master</code>, и потерянные коммиты вновь доступны.
Теперь, положим, потерянная ветка по какой-то причине не попала в reflog, для этого удалим восстановленную ветку и весь reflog. Теперь два первых коммита недоступны ниоткуда:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -D recover-branch
</span></span><span style=display:flex><span>$ rm -Rf .git/logs/
</span></span></code></pre></div><p>Теперь данные из <code>.git/logs/</code> удалены, а значит, и reflog больше нет, так как все его данные находились там. Как восстановить коммиты теперь? Один способ — использовать утилиту <code>git fsck</code>, проверяющую базу на целостность. Если выполнить её с ключом <code>--full</code>, будут показаны все объекты, недостижимые из других объектов:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fsck --full
</span></span><span style=display:flex><span>dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
</span></span><span style=display:flex><span>dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
</span></span><span style=display:flex><span>dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
</span></span><span style=display:flex><span>dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
</span></span></code></pre></div><p>В данном случае потерянный коммит указан после слов &ldquo;dangling commit&rdquo; (dangling commit в пер. с англ. — &ldquo;висячий&rdquo; коммит). Его можно восстановить аналогичным образом, добавив ветку, указывающую на данный хеш.</p><h3 id=удаление-объектов class="relative group">Удаление объектов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>У Git&rsquo;а есть много замечательных особенностей, но одна из них способна вызвать проблемы — команда <code>git clone</code> загружает проект вместе со всей историей, включая все версии всех файлов. Это нормально, если в репозитории хранится только исходный код, так как Git хорошо оптимизирован под такой тип данных и может эффективно сжимать их. Однако, если когда-либо в проект был добавлен большой файл, каждый, кто потом захочет клонировать проект, будет вынужден скачивать этот большой файл, даже если он был удалён в следующем же коммите. Он будет в базе всегда, просто потому, что он доступен в истории.</p><p>Это может стать огромной проблемой при конвертации репозиториев Subversion или Perforce в Git. В данных системах вам не нужно загружать всю историю, поэтому добавление больших бинарных файлов не имеет там особых последствий. Если при импорте из другой системы или при каких-либо других обстоятельствах стало ясно, что ваш репозиторий намного больше, чем он должен быть, то как раз сейчас мы расскажем как можно найти и удалить большие объекты.</p><p>Будьте внимательны, данный способ разрушителен по отношению к истории коммитов. Каждый коммит будет переписан, начиная с самого раннего, из которого вы удалите ссылку на большой файл. Если сделать это непосредственно после импорта, когда никто ещё не работал с репозиторием, всё хорошо, иначе придётся сообщать всем участникам разработки о необходимости перемещения их правок на новые коммиты.</p><p>Для примера добавим большой файл в свой тестовый репозиторий, удалим его в следующем коммите, а потом найдём и удалим его полностью из базы. Для начала добавим большой файл в нашу историю:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 &gt; git.tbz2
</span></span><span style=display:flex><span>$ git add git.tbz2
</span></span><span style=display:flex><span>$ git commit -am <span style=color:#e6db74>&#39;added git tarball&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master 6df7640<span style=color:#f92672>]</span> added git tarball
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>0</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>100644</span> git.tbz2
</span></span></code></pre></div><p>Упс, кажется, этот огромный архив нам в проекте не нужен. Избавимся от него:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm git.tbz2 
</span></span><span style=display:flex><span>rm <span style=color:#e6db74>&#39;git.tbz2&#39;</span>
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;oops - removed large tarball&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master da3f30d<span style=color:#f92672>]</span> oops - removed large tarball
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>0</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> delete mode <span style=color:#ae81ff>100644</span> git.tbz2
</span></span></code></pre></div><p>Теперь &ldquo;соберём мусор&rdquo; в базе и узнаем её размер:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git gc
</span></span><span style=display:flex><span>Counting objects: 21, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Delta compression using <span style=color:#ae81ff>2</span> threads.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>16/16<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>21/21<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>21</span> <span style=color:#f92672>(</span>delta 3<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>15</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Чтобы быстро узнать, сколько у нас занято места, можно воспользоваться командой <code>count-objects</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git count-objects -v
</span></span><span style=display:flex><span>count: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>size: <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>in-pack: <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>packs: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>size-pack: <span style=color:#ae81ff>2016</span>
</span></span><span style=display:flex><span>prune-packable: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>garbage: <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Запись <code>size-pack</code> — это размер упакованных файлов в килобайтах, то есть всего занято 2 MБ. Перед последним коммитом использовалось около 2 КБ, то есть удаление файла не удалило его из истории. Из-за того, что мы однажды случайно добавили большой файл, при каждом клонировании этого репозитория каждому человеку придётся скачивать все эти 2 МБ, только для того, чтобы получить этот крошечный проект. Попробуем избавиться от этого файла.</p><p>Сперва найдём его. В данном случае, мы знаем, что это за файл. Но если бы не знали, как можно было бы определить, какие файлы занимают много места? При вызове <code>git gc</code> все объекты упаковываются в один файл, но, несмотря на это, определить самые крупные файлы можно, запустив служебную команду <code>git verify-pack</code>, и отсортировав её вывод по третьей колонке, в которой записан размер файла. К тому же, так как нас интересуют только самые крупные файлы, оставим только последние несколько строк, направив вывод команде <code>tail</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k <span style=color:#ae81ff>3</span> -n | tail -3
</span></span><span style=display:flex><span>e3f094f522629ae358806b17daf78246c27c007b blob   <span style=color:#ae81ff>1486</span> <span style=color:#ae81ff>734</span> <span style=color:#ae81ff>4667</span>
</span></span><span style=display:flex><span>05408d195263d853f09dca71d55116663690c27c blob   <span style=color:#ae81ff>12908</span> <span style=color:#ae81ff>3478</span> <span style=color:#ae81ff>1189</span>
</span></span><span style=display:flex><span>7a9eb2fba2b1811321254ac360970fc169ba2330 blob   <span style=color:#ae81ff>2056716</span> <span style=color:#ae81ff>2056872</span> <span style=color:#ae81ff>5401</span>
</span></span></code></pre></div><p>Большой объект в самом внизу, его размер — 2 МБ. Для того чтобы узнать, что это за файл, воспользуемся командой <code>rev-list</code>. Если передать ей ключ <code>--objects</code>, то она выдаст хеши всех коммитов, а также хеши объектов и соответствующие им имена файлов. Воспользуемся этим для определения имени выбранного объекта:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rev-list --objects --all | grep 7a9eb2fb
</span></span><span style=display:flex><span>7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2
</span></span></code></pre></div><p>Теперь необходимо удалить данный файл из всех деревьев в прошлом по истории. Легко получить все коммиты, которые меняли данный файл:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline --branches -- git.tbz2
</span></span><span style=display:flex><span>da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball
</span></span><span style=display:flex><span>6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball
</span></span></code></pre></div><p>Необходимо переписать все коммиты, начиная с <code>6df76</code> для полного удаления данного файла. Для этого воспользуемся командой <code>filter-branch</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git filter-branch --index-filter <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;git rm --cached --ignore-unmatch git.tbz2&#39;</span> -- 6df7640^..
</span></span><span style=display:flex><span>Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 <span style=color:#f92672>(</span>1/2<span style=color:#f92672>)</span>rm <span style=color:#e6db74>&#39;git.tbz2&#39;</span>
</span></span><span style=display:flex><span>Rewrite da3f30d019005479c99eb4c3406225613985a1db <span style=color:#f92672>(</span>2/2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Ref <span style=color:#e6db74>&#39;refs/heads/master&#39;</span> was rewritten
</span></span></code></pre></div><p>Опция <code>--index-filter</code> похожа на <code>--tree-filter</code>, за исключением того, что вместо передачи команды, модифицирующей файлы на диске, мы используем команду, изменяющую файлы в индексе. Вместо удаления файла чем-то вроде <code>rm file</code>, стоит сделать это командой <code>git rm --cached</code>, так как нам надо удалить файл из индекса, а не с диска. Причина, по которой мы делаем именно так, — скорость. Нет необходимости извлекать каждую ревизию на диск, чтобы применить фильтр, а это может очень сильно ускорить процесс. Можете использовать и <code>tree-filter</code> для получения аналогичного результата, если хотите. Опция <code>--ignore-unmatch</code> команды <code>git rm</code> отключает вывод сообщения об ошибке в случае отсутствия файлов, соответствующих шаблону. И последнее, команда <code>filter-branch</code> переписывает историю, начиная с коммита <code>6df7640</code>, потому что мы знаем, что именно с этого коммита появилась проблема. По умолчанию перезапись начинается с самого первого коммита, что потребовало бы гораздо больше времени.</p><p>Теперь наша история не содержит ссылок на данный файл. Однако, в reflog и в новом наборе ссылок, добавленном Git&rsquo;ом в <code>.git/refs/original</code> после выполнения <code>filter-branch</code>, ссылки на него всё ещё присутствуют. Поэтому необходимо их удалить, а потом переупаковать базу. Необходимо избавиться от всех возможных ссылок на старые коммиты перед переупаковкой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ rm -Rf .git/refs/original
</span></span><span style=display:flex><span>$ rm -Rf .git/logs/
</span></span><span style=display:flex><span>$ git gc
</span></span><span style=display:flex><span>Counting objects: 19, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Delta compression using <span style=color:#ae81ff>2</span> threads.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>14/14<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>19/19<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>19</span> <span style=color:#f92672>(</span>delta 3<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>16</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Посмотрим, сколько места удалось сохранить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git count-objects -v
</span></span><span style=display:flex><span>count: <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>size: <span style=color:#ae81ff>2040</span>
</span></span><span style=display:flex><span>in-pack: <span style=color:#ae81ff>19</span>
</span></span><span style=display:flex><span>packs: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>size-pack: <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>prune-packable: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>garbage: <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Размер упакованного репозитория сократился до 7 КБ, что намного лучше, чем 2 МБ. Из значения поля size видно, что большой объект всё ещё хранится в одном из ваших &ldquo;рыхлых&rdquo; объектов, но, что самое важное, при любой последующей отправке данных наружу и в том числе при клонировании он передаваться не будет. Если очень хочется, можно удалить его навсегда локально, выполнив <code>git prune --expire</code>.</p><h2 id=итоги class="relative group">Итоги <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%82%d0%be%d0%b3%d0%b8 aria-label=Якорь>#</a></span></h2><p>Теперь вы довольно хорошо понимаете, что Git делает в фоне и, в некоторой степени, как он написан. В данной Лекции мы рассмотрели несколько служебных команд — простых команд, работающих на более низком уровне, чем обычные пользовательские команды, описанные в остальной части книги. Понимание принципов работы Git&rsquo;а на низком уровне упрощает понимание работы Git&rsquo;а в целом и даёт возможность написания собственных утилит и сценариев для организации специфического процесса работы с Git&rsquo;ом.</p><p>Git как контентно-адресуемая файловая система — это очень мощный инструмент, который можно использовать не только как систему контроля версий. Надеюсь, полученное знание внутренней реализации Git&rsquo;а поможет вам в написании ваших собственных интересных приложений, использующих данные технологии, и сделает вашу работу с Git&rsquo;ом более продвинутой и комфортной.</p></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=400 height=400 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt="Андрей Куманяев" loading=lazy decoding=async src=https://zzet.org/img/author.jpeg></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Автор</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Андрей Куманяев</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://twitter.com/username target=_blank aria-label=Twitter rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/zzet target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://x.com/zzetorg target=_blank aria-label=X rel="me noopener noreferrer"></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.reddit.com/user/zzet/ target=_blank aria-label=Reddit rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.linkedin.com/in/andrey-kumanyaev/ target=_blank aria-label=Linkedin rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></span></a></div></div></div></div><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.facebook.com/sharer/sharer.php?u=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;quote=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Поделиться на Facebook" aria-label="Поделиться на Facebook" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://x.com/intent/tweet/?url=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;text=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Post on X" aria-label="Post on X" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://tootpick.org/#text=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Поделиться на Mastodon" aria-label="Поделиться на Mastodon" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://reddit.com/submit/?url=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;resubmit=true&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Опубликовать на Reddit" aria-label="Опубликовать на Reddit" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Поделиться на LinkedIn" aria-label="Поделиться на LinkedIn" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;subject=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Послать через email" aria-label="Послать через email" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.threads.net/intent/post?text=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Post on Threads" aria-label="Post on Threads" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M331.5 235.7c2.2.9 4.2 1.9 6.3 2.8 29.2 14.1 50.6 35.2 61.8 61.4 15.7 36.5 17.2 95.8-30.3 143.2-36.2 36.2-80.3 52.5-142.6 53h-.3c-70.2-.5-124.1-24.1-160.4-70.2-32.3-41-48.9-98.1-49.5-169.6V256v-.2C17 184.3 33.6 127.2 65.9 86.2 102.2 40.1 156.2 16.5 226.4 16h.3c70.3.5 124.9 24 162.3 69.9 18.4 22.7 32 50 40.6 81.7l-40.4 10.8c-7.1-25.8-17.8-47.8-32.2-65.4-29.2-35.8-73-54.2-130.5-54.6-57 .5-100.1 18.8-128.2 54.4C72.1 146.1 58.5 194.3 58 256c.5 61.7 14.1 109.9 40.3 143.3 28 35.6 71.2 53.9 128.2 54.4 51.4-.4 85.4-12.6 113.7-40.9 32.3-32.2 31.7-71.8 21.4-95.9-6.1-14.2-17.1-26-31.9-34.9-3.7 26.9-11.8 48.3-24.7 64.8-17.1 21.8-41.4 33.6-72.7 35.3-23.6 1.3-46.3-4.4-63.9-16-20.8-13.8-33-34.8-34.3-59.3-2.5-48.3 35.7-83 95.2-86.4 21.1-1.2 40.9-.3 59.2 2.8-2.4-14.8-7.3-26.6-14.6-35.2-10-11.7-25.6-17.7-46.2-17.8H227c-16.6.0-39 4.6-53.3 26.3l-34.4-23.6c19.2-29.1 50.3-45.1 87.8-45.1h.8c62.6.4 99.9 39.5 103.7 107.7l-.2.2zm-156 68.8c1.3 25.1 28.4 36.8 54.6 35.3 25.6-1.4 54.6-11.4 59.5-73.2-13.2-2.9-27.8-4.4-43.4-4.4-4.8.0-9.6.1-14.4.4-42.9 2.4-57.2 23.2-56.2 41.8l-.1.1z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://telegram.me/share/url?text=https://zzet.org/ru/archive/2014-04-04-lection-5-git-course-undev/&amp;url=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%205.%20Git%20%d0%b8%d0%b7%d0%bd%d1%83%d1%82%d1%80%d0%b8." title="Поделиться на Telegram" aria-label="Поделиться на Telegram" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111.033 8 0 119.033.0 256S111.033 504 248 504 496 392.967 496 256 384.967 8 248 8zM362.952 176.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452.0 013.53 6.716A43.765 43.765.0 01362.952 176.66z"/></svg></span></a></section><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=https://zzet.org/ru/archive/2014-02-28-lection-1-git-course-undev/><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Git. Просто Git. Лекция 1. Введение.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time>
</span></span></a></span><span><a class="group flex text-right" href=https://zzet.org/ru/archive/2014-03-28-lection-4-git-course-undev/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Git. Просто Git. Лекция 4. Git на сервере.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-03-28 00:00:00 +0000 UTC">28 марта 2014 г.</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=Вверх title=Вверх>&uarr;</a></div><footer class="py-10 print:hidden"><nav class="pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="group mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a href=/ru/archive/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Архив</span></a></li></ul></nav><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2026
Андрей Куманяев</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Работает на <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer></div></body></html>