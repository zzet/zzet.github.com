<!doctype html><html lang=ru dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>Git. Просто Git. Лекция 2. Основы Git, Ветвление. &#183; Андрей Куманяев</title><meta name=title content="Git. Просто Git. Лекция 2. Основы Git, Ветвление. &#183; Андрей Куманяев"><script type=text/javascript src=https://zzet.org/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=https://zzet.org/css/main.bundle.min.100caa677b4bc416cdd884107b203b4869f9b413a19aa57d12069fb826f1abe9.css integrity="sha256-EAyqZ3tLxBbN2IQQeyA7SGn5tBOhmqV9EgafuCbxq+k="><meta name=description content="
      
        
      
    "><meta name=robots content="all"><link rel=canonical href=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/"><meta property="og:site_name" content="Андрей Куманяев"><meta property="og:title" content="Git. Просто Git. Лекция 2. Основы Git, Ветвление."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2014-02-09T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git. Просто Git. Лекция 2. Основы Git, Ветвление."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"","name":"Git. Просто Git. Лекция 2. Основы Git, Ветвление.","headline":"Git. Просто Git. Лекция 2. Основы Git, Ветвление.","inLanguage":"ru","url":"https:\/\/zzet.org\/ru\/archive\/2014-03-07-lection-2-git-course-undev\/","author":{"@type":"Person","name":"Андрей Куманяев"},"copyrightYear":"2014","dateCreated":"2014-02-09T00:00:00\u002b00:00","datePublished":"2014-02-09T00:00:00\u002b00:00","dateModified":"2014-02-09T00:00:00\u002b00:00","mainEntityOfPage":"true","wordCount":"15734"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://zzet.org/ru/","name":"Андрей Куманяев","position":1},{"@type":"ListItem","item":"https://zzet.org/ru/archive/","name":"","position":2},{"@type":"ListItem","name":"Git. Просто Git. Лекция 2. Основы Git, Ветвление.","position":3}]}</script><meta name=author content="Андрей Куманяев"><link href=https://twitter.com/username rel=me><link href=https://github.com/zzet rel=me><link href=https://x.com/zzetorg rel=me><link href=https://www.reddit.com/user/zzet/ rel=me><link href=https://www.linkedin.com/in/andrey-kumanyaev/ rel=me><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGXR3BQCTQ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VGXR3BQCTQ")}</script></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Перейти к содержанию</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/ru/>Андрей Куманяев</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/about/ title="Обо мне"><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Обо мне</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/ru/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Блог</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://github.com/zzet title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=https://x.com/zzetorg title target=_blank><span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg></span></span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/>Андрей Куманяев</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/>archive</a><span class="px-1 text-primary-500">/</span></li><li class="hidden inline"><a class="dark:underline-neutral-600 decoration-neutral-300 hover:underline" href=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/>Git. Просто Git. Лекция 2. Основы Git, Ветвление.</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Git. Просто Git. Лекция 2. Основы Git, Ветвление.</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time><span class="px-2 text-primary-500">&#183;</span><span title="Время чтения">74 минуты</span><span class="px-2 text-primary-500">&#183;</span>
<span class=mb-[2px]><a href=https://github.com/zzet.github.com/content/archive/2014-03-07-lection-2-git-course-undev.ru.md class="text-lg hover:text-primary-500" rel="noopener noreferrer" target=_blank title=Редактировать><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M490.3 40.4c21.9 21.87 21.9 57.33.0 79.2l-30 30.1-98-97.98 30.1-30.06C414.3-.2135 449.7-.2135 471.6 21.66L490.3 40.4zM172.4 241.7 339.7 74.34l98 97.96L270.3 339.6C264.2 345.8 256.7 350.4 248.4 353.2l-88.8 29.6C150.1 385.6 141.5 383.4 135 376.1 128.6 370.5 126.4 361 129.2 352.4l29.6-88.8C161.6 255.3 166.2 247.8 172.4 241.7v0zM192 63.1c17.7.0 32 15.23 32 32 0 18.6-14.3 32-32 32H96c-17.67.0-32 15.2-32 32V416c0 17.7 14.33 32 32 32H352c17.7.0 32-14.3 32-32V319.1c0-16.8 14.3-32 32-32s32 15.2 32 32V416c0 53-43 96-96 96H96c-53.02.0-96-43-96-96V159.1c0-53 42.98-96 96-96h96z"/></svg></span></a></span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><h1 id=основы-git class="relative group">Основы Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-git aria-label=Якорь>#</a></span></h1><p>На прошлой лекции говорилось, о том, как начать работу с Git. Если быть честными, то этого было не достаточно и достаточный минимум вы получите именно на этой лекции :)
Мы рассмотрим все базовые команды, необходимые вам для решения подавляющего большинства задач возникающих при работе с Git&rsquo;ом. После этой лекции вы научитесь настраивать и инициализировать репозиторий, начинать и прекращать версионный контроль файлов, а также подготавливать и фиксировать изменения. Мы также продемонстрируем вам как настроить в Git&rsquo;е игнорирование отдельных файлов или их групп, как быстро и просто отменить ошибочные изменения, как просмотреть историю вашего проекта и изменения между отдельными коммитами (commit), а также как отправлять (push) и получать (pull) изменения в/из удалённого (remote) репозитория. Также мы познакомимся с killer фичей Git&rsquo;а - ветвлением.</p><h2 id=создание-git-репозитория class="relative group">Создание Git-репозитория <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-git-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f aria-label=Якорь>#</a></span></h2><p>Для создания Git-репозитория существуют два основных подхода. Первый подход — импорт в Git уже существующего проекта или каталога. Второй — клонирование уже существующего репозитория с сервера.</p><h3 id=создание-репозитория-в-существующем-каталоге class="relative group">Создание репозитория в существующем каталоге <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f-%d0%b2-%d1%81%d1%83%d1%89%d0%b5%d1%81%d1%82%d0%b2%d1%83%d1%8e%d1%89%d0%b5%d0%bc-%d0%ba%d0%b0%d1%82%d0%b0%d0%bb%d0%be%d0%b3%d0%b5 aria-label=Якорь>#</a></span></h3><p>Если вы собираетесь начать использовать Git для существующего проекта, то вам необходимо перейти в проектный каталог и в командной строке ввести</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git init
</span></span></code></pre></div><p>Эта команда создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория — основу Git-репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. (Более подробно рассмотрим файлы содержащихся в только что созданном вами каталоге <code>.git</code> позже, в рамках следующих лекций)</p><p>Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит проиндексировать эти файлы и осуществить первую фиксацию изменений. Осуществить это вы можете с помощью нескольких команд <code>git add</code> указывающих индексируемые файлы, а затем <code>commit</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add *.c
</span></span><span style=display:flex><span>$ git add README
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;initial project version&#39;</span>
</span></span></code></pre></div><p>Мы разберём, что делают эти команды чуть позже. На данном этапе, у вас есть Git-репозиторий с добавленными файлами и начальным коммитом.</p><h3 id=клонирование-существующего-репозитория class="relative group">Клонирование существующего репозитория <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%ba%d0%bb%d0%be%d0%bd%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%81%d1%83%d1%89%d0%b5%d1%81%d1%82%d0%b2%d1%83%d1%8e%d1%89%d0%b5%d0%b3%d0%be-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Если вы желаете получить копию существующего репозитория Git, например, проекта, в котором вы хотите поучаствовать, то вам нужна команда <code>git clone</code>. Если вы знакомы с другими системами контроля версий, такими как Subversion, то заметите, что команда называется <code>clone</code>, а не <code>checkout</code>. Это важное отличие — Git получает копию практически всех данных, что есть на сервере. Каждая версия каждого файла из истории проекта забирается (pulled) с сервера, когда вы выполняете <code>git clone</code>. Фактически, если серверный диск выйдет из строя, вы можете использовать любой из клонов на любом из клиентов, для того чтобы вернуть сервер в то состояние, в котором он находился в момент клонирования (вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но все данные, помещённые под версионный контроль, будут сохранены, подробнее см. в главе 4).</p><p>Клонирование репозитория осуществляется командой <code>git clone [url]</code>. Например, если вы хотите клонировать библиотеку Ruby Git, известную как Grit, вы можете сделать это следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone git://github.com/libgit2/rugged.git
</span></span></code></pre></div><p>Эта команда создаёт каталог с именем <code>rugged</code>, инициализирует в нём каталог <code>.git</code>, скачивает все данные для этого репозитория и создаёт (checks out) рабочую копию последней версии. Если вы зайдёте в новый каталог <code>rugged</code>, вы увидите в нём проектные файлы, пригодные для работы и использования. Если вы хотите клонировать репозиторий в каталог, отличный от <code>rugged</code>, можно это указать в следующем параметре командной строки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone git://github.com/libgit2/rugged.git myrugget
</span></span></code></pre></div><p>Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван myrugget.</p><p>В Git&rsquo;е реализовано несколько транспортных протоколов, которые вы можете использовать. В предыдущем примере использовался протокол <code>git://</code>, вы также можете встретить <code>http(s)://</code> или <code>user@server:/path.git</code>, использующий протокол передачи SSH. В рамках следующих лекций мы познакомимся со всеми доступными вариантами конфигурации сервера для обеспечения доступа к вашему Git-репозиторию, а также рассмотрим их достоинства и недостатки.</p><h2 id=запись-изменений-в-репозиторий class="relative group">Запись изменений в репозиторий <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b7%d0%b0%d0%bf%d0%b8%d1%81%d1%8c-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9-%d0%b2-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h2><p>Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать “снимки” состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.</p><p>Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть неизменёнными, изменёнными или подготовленными к коммиту (staged). Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища (checked them out) и ничего пока не редактировали.</p><p>Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. Этот жизненный цикл изображён на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0201-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 2-1. Жизненный цикл состояний файлов.</p></blockquote><h3 id=определение-состояния-файлов class="relative group">Определение состояния файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда <code>git status</code>. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span>nothing to commit <span style=color:#f92672>(</span>working directory clean<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Это означает, что у вас чистый рабочий каталог, другими словами — в нём нет отслеживаемых изменённых файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. И наконец, команда сообщает вам на какой ветке (branch) вы сейчас находитесь. Пока что это всегда ветка <code>master</code> — это ветка по умолчанию. Позже подробно поработаем с ветками и ссылками.</p><p>Предположим, вы добавили в свой проект новый файл, простой файл README. Если этого файла раньше не было, и вы выполните <code>git status</code>, вы увидите свой неотслеживаемый файл вот так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ touch README
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Untracked files:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	README</span>
</span></span><span style=display:flex><span>nothing added to commit but untracked files present <span style=color:#f92672>(</span>use <span style=color:#e6db74>&#34;git add&#34;</span> to track<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Понять, что новый файл README неотслеживаемый можно по тому, что он находится в секции &ldquo;Untracked files&rdquo; в выводе команды <code>status</code>. Статус &ldquo;неотслеживаемый файл&rdquo;, по сути, означает, что Git видит файл, отсутствующий в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять. Мы хотели добавить README, так давайте сделаем это.</p><h3 id=отслеживание-новых-файлов class="relative group">Отслеживание новых файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d1%81%d0%bb%d0%b5%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bd%d0%be%d0%b2%d1%8b%d1%85-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда <code>git add</code>. Чтобы начать отслеживание файла README, вы можете выполнить следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add README
</span></span></code></pre></div><p>Если вы снова выполните команду <code>status</code>, то увидите, что файл README теперь отслеживаемый и индексированный:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Вы можете видеть, что файл проиндексирован по тому, что он находится в секции “Changes to be committed”. Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды <code>git add</code>, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили <code>git init</code>, вы затем выполнили <code>git add (файлы)</code> — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда <code>git add</code> принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в данном каталоге.</p><h3 id=индексация-изменённых-файлов class="relative group">Индексация изменённых файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b0%d1%86%d0%b8%d1%8f-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d1%91%d0%bd%d0%bd%d1%8b%d1%85-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый файл benchmarks.rb и после этого снова выполните команду <code>status</code>, то результат будет примерно следующим:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Файл benchmarks.rb находится в секции “Changes not staged for commit” — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду <code>git add</code> (это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния). Выполним <code>git add</code>, чтобы проиндексировать benchmarks.rb, а затем снова выполним <code>git status</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add benchmarks.rb
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в benchmarks.rb до фиксации. Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним <code>git status</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vim benchmarks.rb
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Что за чёрт? Теперь benchmarks.rb отображается как проиндексированный и непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно демонстрирует, что Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду <code>git add</code>. Если вы выполните коммит сейчас, то файл benchmarks.rb попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду <code>git add</code>, а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения <code>git commit</code>. Если вы изменили файл после выполнения <code>git add</code>, вам придётся снова выполнить <code>git add</code>, чтобы проиндексировать последнюю версию файла:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add benchmarks.rb
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><h3 id=игнорирование-файлов class="relative group">Игнорирование файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b3%d0%bd%d0%be%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т.п.). В таком случае, вы можете создать файл .gitignore с перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat .gitignore
</span></span><span style=display:flex><span>*.<span style=color:#f92672>[</span>oa<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>*~
</span></span></code></pre></div><p>Первая строка предписывает Git&rsquo;у игнорировать любые файлы заканчивающиеся на .o или .a — объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (<code>~</code>), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла .gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.</p><p>К шаблонам в файле .gitignore применяются следующие правила:</p><ul><li>Пустые строки, а также строки, начинающиеся с #, игнорируются.</li><li>Можно использовать стандартные glob шаблоны.</li><li>Можно заканчивать шаблон символом слэша (<code>/</code>) для указания каталога.</li><li>Можно инвертировать шаблон, использовав восклицательный знак (<code>!</code>) в качестве первого символа.</li></ul><blockquote><p>Glob-шаблоны представляют собой упрощённые регулярные выражения
используемые командными интерпретаторами. Символ <code>*</code> соответствует 0
или более символам; последовательность <code>[abc]</code> — любому символу из
указанных в скобках (в данном примере a, b или c); знак вопроса (<code>?</code>)
соответствует одному символу; <code>[0-9]</code> соответствует любому символу из
интервала (в данном случае от 0 до 9).</p></blockquote><p>Вот ещё один пример файла .gitignore:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># комментарий — эта строка игнорируется</span>
</span></span><span style=display:flex><span><span style=color:#75715e># не обрабатывать файлы, имя которых заканчивается на .a</span>
</span></span><span style=display:flex><span>*.a
</span></span><span style=display:flex><span><span style=color:#75715e># НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила</span>
</span></span><span style=display:flex><span>!lib.a
</span></span><span style=display:flex><span><span style=color:#75715e># игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO</span>
</span></span><span style=display:flex><span>/TODO
</span></span><span style=display:flex><span><span style=color:#75715e># игнорировать все файлы в каталоге build/</span>
</span></span><span style=display:flex><span>build/
</span></span><span style=display:flex><span><span style=color:#75715e># игнорировать doc/notes.txt, но не doc/server/arch.txt</span>
</span></span><span style=display:flex><span>doc/*.txt
</span></span><span style=display:flex><span><span style=color:#75715e># игнорировать все .txt файлы в каталоге doc/</span>
</span></span><span style=display:flex><span>doc/**/*.txt
</span></span></code></pre></div><p>Шаблон <code>**/</code> доступен в Git, начиная с версии 1.8.2.</p><h3 id=просмотр-индексированных-и-неиндексированных-изменений class="relative group">Просмотр индексированных и неиндексированных изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b8-%d0%bd%d0%b5%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h3><p>Если результат работы команды <code>git status</code> недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду <code>git diff</code>. Позже мы рассмотрим команду <code>git diff</code> подробнее; вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь фиксировать. Если <code>git status</code> отвечает на эти вопросы слишком обобщённо, то <code>git diff</code> показывает вам непосредственно добавленные и удалённые строки — собственно заплатку (patch).</p><p>Допустим, вы снова изменили и проиндексировали файл README, а затем изменили файл benchmarks.rb без индексирования. Если вы выполните команду <code>status</code>, вы опять увидите что-то вроде:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите <code>git diff</code> без аргументов:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff
</span></span><span style=display:flex><span>diff --git a/benchmarks.rb b/benchmarks.rb
</span></span><span style=display:flex><span>index 3cb747f..da65585 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/benchmarks.rb
</span></span><span style=display:flex><span>+++ b/benchmarks.rb
</span></span><span style=display:flex><span>@@ -36,6 +36,10 @@ def main
</span></span><span style=display:flex><span>           @commit.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+        run_code<span style=color:#f92672>(</span>x, <span style=color:#e6db74>&#39;commits 1&#39;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>+          git.commits.size
</span></span><span style=display:flex><span>+        end
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>         run_code<span style=color:#f92672>(</span>x, <span style=color:#e6db74>&#39;commits 2&#39;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>           log <span style=color:#f92672>=</span> git.commits<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;master&#39;</span>, 15<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>           log.size
</span></span></code></pre></div><p>Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.</p><p>Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить <code>git diff --cached</code>. (В Git&rsquo;е версии 1.6.1 и выше, вы также можете использовать <code>git diff --staged</code>, которая легче запоминается.) Эта команда сравнивает ваши индексированные изменения с последним коммитом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff --cached
</span></span><span style=display:flex><span>diff --git a/README b/README
</span></span><span style=display:flex><span>new file mode <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>index 0000000..03902a1
</span></span><span style=display:flex><span>--- /dev/null
</span></span><span style=display:flex><span>+++ b/README2
</span></span><span style=display:flex><span>@@ -0,0 +1,5 @@
</span></span><span style=display:flex><span>+grit
</span></span><span style=display:flex><span>+ by Tom Preston-Werner, Chris Wanstrath
</span></span><span style=display:flex><span>+ http://github.com/mojombo/grit
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>+Grit is a Ruby library <span style=color:#66d9ef>for</span> extracting information from a Git repository
</span></span></code></pre></div><p>Важно отметить, что <code>git diff</code> сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то <code>git diff</code> ничего не вернёт.</p><p>Другой пример: вы проиндексировали файл benchmarks.rb и затем изменили его, вы можете использовать <code>git diff</code> для просмотра как индексированных изменений в этом файле, так и тех, что пока не проиндексированы:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add benchmarks.rb
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;# test line&#39;</span> &gt;&gt; benchmarks.rb
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Теперь вы можете используя <code>git diff</code> посмотреть непроиндексированные изменения</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff
</span></span><span style=display:flex><span>diff --git a/benchmarks.rb b/benchmarks.rb
</span></span><span style=display:flex><span>index e445e28..86b2f7c <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/benchmarks.rb
</span></span><span style=display:flex><span>+++ b/benchmarks.rb
</span></span><span style=display:flex><span>@@ -127,3 +127,4 @@ end
</span></span><span style=display:flex><span> main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>##pp Grit::GitRuby.cache_client.stats</span>
</span></span><span style=display:flex><span>+# test line
</span></span></code></pre></div><p>а также уже проиндексированные, используя <code>git diff --cached</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git diff --cached
</span></span><span style=display:flex><span>diff --git a/benchmarks.rb b/benchmarks.rb
</span></span><span style=display:flex><span>index 3cb747f..e445e28 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/benchmarks.rb
</span></span><span style=display:flex><span>+++ b/benchmarks.rb
</span></span><span style=display:flex><span>@@ -36,6 +36,10 @@ def main
</span></span><span style=display:flex><span>          @commit.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.parents<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+        run_code<span style=color:#f92672>(</span>x, <span style=color:#e6db74>&#39;commits 1&#39;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>+          git.commits.size
</span></span><span style=display:flex><span>+        end
</span></span><span style=display:flex><span>+       
</span></span><span style=display:flex><span>        run_code<span style=color:#f92672>(</span>x, <span style=color:#e6db74>&#39;commits 2&#39;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>          log <span style=color:#f92672>=</span> git.commits<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;master&#39;</span>, 15<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          log.size
</span></span></code></pre></div><h3 id=фиксация-изменений class="relative group">Фиксация изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%84%d0%b8%d0%ba%d1%81%d0%b0%d1%86%d0%b8%d1%8f-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h3><p>Теперь, когда ваш индекс настроен так, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили <code>git add</code> после момента редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске.
В нашем случае, когда вы в последний раз выполняли <code>git status</code>, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать <code>git commit</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit
</span></span></code></pre></div><p>Эта команда откроет выбранный вами текстовый редактор. (Редактор устанавливается системной переменной <code>$EDITOR</code> — обычно это vim или emacs, хотя вы можете установить ваш любимый с помощью команды <code>git config --global core.editor</code>, как было показано в предыдущей лекции).</p><p>В редакторе будет отображён следующий текст (это пример окна Vim&rsquo;а):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Please enter the commit message for your changes. Lines starting</span>
</span></span><span style=display:flex><span><span style=color:#75715e># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       new file:   README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span>~
</span></span><span style=display:flex><span>~
</span></span><span style=display:flex><span>~
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;.git/COMMIT_EDITMSG&#34;</span> 10L, 283C
</span></span></code></pre></div><p>Вы можете видеть, что комментарий по умолчанию для коммита содержит закомментированный результат работы (&ldquo;выхлоп&rdquo;) команды <code>git status</code> и ещё одну пустую строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же оставить их для напоминания о том, что вы фиксируете. (Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент <code>-v</code> в команду <code>git commit</code>. Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть всё, что сделано.) Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением (удаляя комментарии и вывод diff&rsquo;а).</p><p>Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой <code>commit</code>, указав его после параметра -m, как в следующем примере:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#34;Story 182: Fix benchmarks for speed&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master<span style=color:#f92672>]</span>: created 463dc4f: <span style=color:#e6db74>&#34;Fix benchmarks for speed&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span> files changed, <span style=color:#ae81ff>3</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> create mode <span style=color:#ae81ff>100644</span> README
</span></span></code></pre></div><p>Итак, вы создали свой первый коммит! Вы можете видеть, что коммит вывел вам немного информации о себе: на какую ветку вы выполнили коммит (master), какая контрольная сумма SHA-1 у этого коммита (<code>463dc4f</code>), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.</p><p>Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и торчит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.</p><h3 id=игнорирование-индексации class="relative group">Игнорирование индексации <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b3%d0%bd%d0%be%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b0%d1%86%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h3><p>Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы. Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра <code>-a</code> в команду <code>git commit</code> заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без <code>git add</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;added new benchmarks&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>master 83e38c7<span style=color:#f92672>]</span> added new benchmarks
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>5</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Обратите внимание на то, что в данном случае перед коммитом вам не нужно выполнять <code>git add</code> для файла benchmarks.rb.</p><h3 id=удаление-файлов class="relative group">Удаление файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>Для того чтобы удалить файл из Git&rsquo;а, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда <code>git rm</code>, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”.</p><p>Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции “Changes not staged for commit” (“Изменённые но не обновлённые” — читай не проиндексированные) вывода команды <code>git status</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ rm grit.gemspec
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add/rm &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       deleted:    grit.gemspec</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Затем, если вы выполните команду <code>git rm</code>, удаление файла попадёт в индекс:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm grit.gemspec
</span></span><span style=display:flex><span>rm <span style=color:#e6db74>&#39;grit.gemspec&#39;</span>
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       deleted:    grit.gemspec</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра <code>-f</code>. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git&rsquo;а.</p><p>Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на винчестере, и убрать его из-под бдительного ока Git&rsquo;а. Это особенно полезно, если вы забыли добавить что-то в файл <code>.gitignore</code> и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию <code>--cached</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm --cached readme.txt
</span></span></code></pre></div><p>В команду <code>git rm</code> можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm log/<span style=color:#ae81ff>\*</span>.log
</span></span></code></pre></div><p>Обратите внимание на обратный слэш (<code>\</code>) перед <code>*</code>. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы, которые имеют расширение <code>.log</code> в каталоге <code>log/</code>. Или же вы можете сделать вот так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rm <span style=color:#ae81ff>\*</span>~
</span></span></code></pre></div><p>Эта команда удаляет все файлы, чьи имена заканчиваются на <code>~</code>.</p><h3 id=перемещение-файлов class="relative group">Перемещение файлов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2 aria-label=Якорь>#</a></span></h3><p>В отличие от многих других систем версионного контроля, Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git&rsquo;е, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован. Однако, Git довольно умён в плане обнаружения перемещений постфактум — мы рассмотрим обнаружение перемещения файлов чуть позже.</p><p>Таким образом, наличие в Git&rsquo;е команды <code>mv</code> выглядит несколько странным. Если вам хочется переименовать файл в Git&rsquo;е, вы можете сделать что-то вроде:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git mv file_from file_to
</span></span></code></pre></div><p>и это отлично сработает. На самом деле, если вы выполните что-то вроде этого и посмотрите на статус, вы увидите, что Git считает, что произошло переименование файла:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git mv README.txt README
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Your branch is ahead of &#39;origin/master&#39; by 1 commit.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       renamed:    README.txt -&gt; README</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Однако, это эквивалентно выполнению следующих команд:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ mv README.txt README
</span></span><span style=display:flex><span>$ git rm README.txt
</span></span><span style=display:flex><span>$ git add README
</span></span></code></pre></div><p>Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду <code>mv</code>. Единственное отличие состоит лишь в том, что <code>mv</code> — это одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ, чтобы переименовать файл, и затем воспользоваться add/rm перед коммитом.</p><h2 id=просмотр-истории-коммитов class="relative group">Просмотр истории коммитов <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80-%d0%b8%d1%81%d1%82%d0%be%d1%80%d0%b8%d0%b8-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%be%d0%b2 aria-label=Якорь>#</a></span></h2><p>После того как вы создадите несколько коммитов, или же вы склонируете репозиторий с уже существующей историей коммитов, вы, вероятно, захотите оглянуться назад и узнать, что же происходило с этим репозиторием. Наиболее простой и в то же время мощный инструмент для этого — команда <code>git log</code>.</p><p>Данные примеры используют очень простой проект, названный simplegit, который я часто использую для демонстраций. Чтобы получить этот проект, выполните:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone git://github.com/schacon/simplegit-progit.git
</span></span></code></pre></div><p>В результате выполнения <code>git log</code> в данном проекте, вы должны получить что-то вроде этого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log
</span></span><span style=display:flex><span>commit ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Mar <span style=color:#ae81ff>17</span> 21:52:11 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    changed the version number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sat Mar <span style=color:#ae81ff>15</span> 16:40:33 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    removed unnecessary test code
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit a11bef06a3f659402fe7563abf99ad00de2209e6
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sat Mar <span style=color:#ae81ff>15</span> 10:31:28 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    first commit
</span></span></code></pre></div><p>По умолчанию, без аргументов, <code>git log</code> выводит список коммитов созданных в данном репозитории в обратном хронологическом порядке. То есть самые последние коммиты показываются первыми. Как вы можете видеть, эта команда отображает каждый коммит вместе с его контрольной суммой SHA-1, именем и электронной почтой автора, датой создания и комментарием.</p><p>Существует превеликое множество параметров команды <code>git log</code> и их комбинаций, для того чтобы показать вам именно то, что вы ищете. Здесь мы покажем вам несколько наиболее часто применяемых.</p><p>Один из наиболее полезных параметров — это <code>-p</code>, который показывает дельту (разницу/diff), привнесенную каждым коммитом. Вы также можете использовать <code>-2</code>, что ограничит вывод до 2-х последних записей:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -p -2
</span></span><span style=display:flex><span>commit ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Mar <span style=color:#ae81ff>17</span> 21:52:11 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    changed the version number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>diff --git a/Rakefile b/Rakefile
</span></span><span style=display:flex><span>index a874b73..8f94139 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/Rakefile
</span></span><span style=display:flex><span>+++ b/Rakefile
</span></span><span style=display:flex><span>@@ -5,5 +5,5 @@ require <span style=color:#e6db74>&#39;rake/gempackagetask&#39;</span>
</span></span><span style=display:flex><span> spec <span style=color:#f92672>=</span> Gem::Specification.new <span style=color:#66d9ef>do</span> |s|
</span></span><span style=display:flex><span>     s.name      <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;simplegit&#34;</span>
</span></span><span style=display:flex><span>-    s.version   <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span>+    s.version   <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;0.1.1&#34;</span>
</span></span><span style=display:flex><span>     s.author    <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;Scott Chacon&#34;</span>
</span></span><span style=display:flex><span>     s.email     <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;schacon@gee-mail.com
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Date:   Sat Mar 15 16:40:33 2008 -0700
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    removed unnecessary test code
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
</span></span></span><span style=display:flex><span><span style=color:#e6db74>index a0a60ae..47c6340 100644
</span></span></span><span style=display:flex><span><span style=color:#e6db74>--- a/lib/simplegit.rb
</span></span></span><span style=display:flex><span><span style=color:#e6db74>+++ b/lib/simplegit.rb
</span></span></span><span style=display:flex><span><span style=color:#e6db74>@@ -18,8 +18,3 @@ class SimpleGit
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     end
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74> end
</span></span></span><span style=display:flex><span><span style=color:#e6db74>-
</span></span></span><span style=display:flex><span><span style=color:#e6db74>-if </span>$0<span style=color:#e6db74> == __FILE__
</span></span></span><span style=display:flex><span><span style=color:#e6db74>-  git = SimpleGit.new
</span></span></span><span style=display:flex><span><span style=color:#e6db74>-  puts git.show
</span></span></span><span style=display:flex><span><span style=color:#e6db74>-end
</span></span></span><span style=display:flex><span><span style=color:#e6db74>\ No newline at end of file
</span></span></span></code></pre></div><p>Этот параметр показывает ту же самую информацию плюс внесённые изменения, отображаемые непосредственно после каждого коммита. Это очень удобно для инспекций кода или для того, чтобы быстро посмотреть, что происходило в результате последовательности коммитов, добавленных коллегой.</p><p>В некоторых ситуациях гораздо удобней просматривать внесённые изменения на уровне слов, а не на уровне строк. Чтобы получить дельту по словам вместо обычной дельты по строкам, нужно дописать после команды <code>git log -p</code> опцию <code>--word-diff</code>. Дельты на уровне слов практически бесполезны при работе над программным кодом, но они буду очень кстати при работе над длинным текстом, таким как книга или диссертация. Рассмотрим пример:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log -U1 --word-diff
</span></span><span style=display:flex><span>commit ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Mar <span style=color:#ae81ff>17</span> 21:52:11 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    changed the version number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>diff --git a/Rakefile b/Rakefile
</span></span><span style=display:flex><span>index a874b73..8f94139 <span style=color:#ae81ff>100644</span>
</span></span><span style=display:flex><span>--- a/Rakefile
</span></span><span style=display:flex><span>+++ b/Rakefile
</span></span><span style=display:flex><span>@@ -7,3 +7,3 @@ spec <span style=color:#f92672>=</span> Gem::Specification.new <span style=color:#66d9ef>do</span> |s|
</span></span><span style=display:flex><span>    s.name      <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;simplegit&#34;</span>
</span></span><span style=display:flex><span>    s.version   <span style=color:#f92672>=</span>   <span style=color:#f92672>[</span>-<span style=color:#e6db74>&#34;0.1.0&#34;</span>-<span style=color:#f92672>]{</span>+<span style=color:#e6db74>&#34;0.1.1&#34;</span>+<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    s.author    <span style=color:#f92672>=</span>   <span style=color:#e6db74>&#34;Scott Chacon&#34;</span>
</span></span></code></pre></div><p>Как видите, в этом выводе нет ни добавленных ни удалённых строк, как для обычного diff&rsquo;а. Вместо этого изменения показаны внутри строки. Добавленное слово заключено в <code>{+ +}</code>, а удалённое в <code>[- -]</code>. Также может быть полезно сократить обычные три строки контекста в выводе команды <code>diff</code> до одной строки, так как контекстом в данном случае являются слова, а не строки. Сделать это можно с помощью опции <code>-U1</code> как было показано в примере выше.</p><p>С командой <code>git log</code> вы также можете использовать группы суммирующих параметров. Например, если вы хотите получить некоторую краткую статистику по каждому коммиту, вы можете использовать параметр <code>--stat</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --stat
</span></span><span style=display:flex><span>commit ca82a6dff817ec66f44342007202690a93763949
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Mar <span style=color:#ae81ff>17</span> 21:52:11 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    changed the version number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> Rakefile |    <span style=color:#ae81ff>2</span> +-
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>1</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sat Mar <span style=color:#ae81ff>15</span> 16:40:33 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    removed unnecessary test code
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> lib/simplegit.rb |    <span style=color:#ae81ff>5</span> -----
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>0</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>5</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit a11bef06a3f659402fe7563abf99ad00de2209e6
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sat Mar <span style=color:#ae81ff>15</span> 10:31:28 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    first commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> README           |    <span style=color:#ae81ff>6</span> ++++++
</span></span><span style=display:flex><span> Rakefile         |   <span style=color:#ae81ff>23</span> +++++++++++++++++++++++
</span></span><span style=display:flex><span> lib/simplegit.rb |   <span style=color:#ae81ff>25</span> +++++++++++++++++++++++++
</span></span><span style=display:flex><span> <span style=color:#ae81ff>3</span> files changed, <span style=color:#ae81ff>54</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Как видно из лога, параметр <code>--stat</code> выводит под каждым коммитом список изменённых файлов, количество изменённых файлов, а также количество добавленных и удалённых строк в этих файлах. Он также выводит сводную информацию в конце.
Другой действительно полезный параметр — это <code>--pretty</code>. Он позволяет изменить формат вывода лога. Для вас доступны несколько предустановленных вариантов. Параметр <code>oneline</code> выводит каждый коммит в одну строку, что удобно если вы просматриваете большое количество коммитов. В дополнение к этому, параметры <code>short</code>, <code>full</code>, и <code>fuller</code>, практически не меняя формат вывода, позволяют выводить меньше или больше деталей соответственно:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline
</span></span><span style=display:flex><span>ca82a6dff817ec66f44342007202690a93763949 changed the version number
</span></span><span style=display:flex><span>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
</span></span><span style=display:flex><span>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
</span></span></code></pre></div><p>Наиболее интересный параметр — это <code>format</code>, который позволяет вам полностью создать собственный формат вывода лога. Это особенно полезно, когда вы создаёте отчёты для автоматического разбора (парсинга) — поскольку вы явно задаёте формат и уверены в том, что он не будет изменяться при обновлениях Git&rsquo;а:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#34;%h - %an, %ar : %s&#34;</span>
</span></span><span style=display:flex><span>ca82a6d - Scott Chacon, <span style=color:#ae81ff>11</span> months ago : changed the version number
</span></span><span style=display:flex><span>085bb3b - Scott Chacon, <span style=color:#ae81ff>11</span> months ago : removed unnecessary test code
</span></span><span style=display:flex><span>a11bef0 - Scott Chacon, <span style=color:#ae81ff>11</span> months ago : first commit
</span></span></code></pre></div><p>Таблица 2-1 содержит список наиболее полезных параметров формата.</p><pre tabindex=0><code>Параметр	Описание выводимых данных
%H	        Хеш коммита
%h	        Сокращённый хеш коммита
%T	        Хеш дерева
%t	        Сокращённый хеш дерева
%P	        Хеши родительских коммитов
%p	        Сокращённые хеши родительских коммитов
%an	        Имя автора
%ae	        Электронная почта автора
%ad	        Дата автора (формат соответствует параметру `--date=`)
%ar	        Дата автора, относительная (пр. &#34;2 мес. назад&#34;)
%cn	        Имя коммитера
%ce	        Электронная почта коммитера
%cd	        Дата коммитера
%cr	        Дата коммитера, относительная
%s          Комментарий
</code></pre><p>Вас может заинтересовать, в чём же разница между <em>автором</em> и <em>коммитером</em>. Автор — это человек, изначально сделавший работу, тогда как коммитер — это человек, который последним применил эту работу. Так что если вы послали патч (заплатку) в проект и один из основных разработчиков применил этот патч, вы оба не будете забыты — вы как автор, а разработчик как коммитер.</p><p>Параметры <code>oneline</code> и <code>format</code> также полезны с другим параметром команды <code>log</code> — <code>--graph</code>. Этот параметр добавляет миленький ASCII-граф, показывающий историю ветвлений и слияний. Один из таких можно увидеть для нашей копии репозитория проекта Grit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>format:<span style=color:#e6db74>&#34;%h %s&#34;</span> --graph
</span></span><span style=display:flex><span>* 2d3acf9 ignore errors from SIGCHLD on trap
</span></span><span style=display:flex><span>*  5e3ee11 Merge branch <span style=color:#e6db74>&#39;master&#39;</span> of git://github.com/dustin/grit
</span></span><span style=display:flex><span>|<span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>| * 420eac9 Added a method <span style=color:#66d9ef>for</span> getting the current branch.
</span></span><span style=display:flex><span>* | 30e367c timeout code and tests
</span></span><span style=display:flex><span>* | 5a09431 add timeout protection to grit
</span></span><span style=display:flex><span>* | e1193f8 support <span style=color:#66d9ef>for</span> heads with slashes in them
</span></span><span style=display:flex><span>|/
</span></span><span style=display:flex><span>* d6016bc require time <span style=color:#66d9ef>for</span> xmlschema
</span></span><span style=display:flex><span>*  11d191e Merge branch <span style=color:#e6db74>&#39;defunkt&#39;</span> into local
</span></span></code></pre></div><p>Мы рассмотрели только самые простые параметры форматирования вывода для <code>git log</code> — их гораздо больше. Таблица ниже содержит как уже рассмотренные нами параметры, так и другие полезные параметры вместе с описанием того, как они влияют на вывод команды <code>log</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Параметр	    Описание
</span></span><span style=display:flex><span>-p	            Для каждого коммита показывать дельту внесённых им изменений.
</span></span><span style=display:flex><span>--word-diff	    Показывать изменения на уровне слов.
</span></span><span style=display:flex><span>--stat	        Для каждого коммита дополнительно выводить статистику по изменённым файлам.
</span></span><span style=display:flex><span>--shortstat	    Показывать только строку changed/insertions/deletions от вывода с опцией <span style=color:#e6db74>`</span>--stat<span style=color:#e6db74>`</span>.
</span></span><span style=display:flex><span>--name-only	    Показывать список изменённых файлов после информации о коммите.
</span></span><span style=display:flex><span>--name-status	Выводить список изменённых файлов вместе с информацией о добавлении/изменении/удалении.
</span></span><span style=display:flex><span>--abbrev-commit	Выводить только первые несколько символов контрольной суммы SHA-1 вместо всех 40.
</span></span><span style=display:flex><span>--relative-date	Выводить дату в относительном формате <span style=color:#f92672>(</span>например, <span style=color:#e6db74>&#34;2 weeks ago&#34;</span><span style=color:#f92672>)</span> вместо полной даты.
</span></span><span style=display:flex><span>--graph	        Показывать ASCII-граф истории ветвлений и слияний рядом с выводом лога.
</span></span><span style=display:flex><span>--pretty	    Отображать коммиты в альтернативном формате. Возможные параметры: <span style=color:#e6db74>`</span>oneline<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>short<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>full<span style=color:#e6db74>`</span>, <span style=color:#e6db74>`</span>fuller<span style=color:#e6db74>`</span> и <span style=color:#e6db74>`</span>format<span style=color:#e6db74>`</span> <span style=color:#f92672>(</span>где вы можете указать свой собственный формат<span style=color:#f92672>)</span>.
</span></span></code></pre></div><h3 id=ограничение-вывода-команды-log class="relative group">Ограничение вывода команды log <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d0%b0-%d0%ba%d0%be%d0%bc%d0%b0%d0%bd%d0%b4%d1%8b-log aria-label=Якорь>#</a></span></h3><p>Кроме опций для форматирования вывода, <code>git log</code> имеет ряд полезных ограничительных параметров, то есть параметров, которые дают возможность отобразить часть коммитов. Вы уже видели один из таких параметров — параметр <code>-2</code>, который отображает только два последних коммита. На самом деле, вы можете задать <code>-&lt;n></code>, где <code>n</code> это количество отображаемых коммитов. На практике вам вряд ли придётся часто этим пользоваться потому, что по умолчанию Git через канал (pipe) отправляет весь вывод на pager, так что вы всегда будете видеть только одну страницу.</p><p>А вот параметры, ограничивающие по времени, такие как <code>--since</code> и <code>--until</code>, весьма полезны. Например, следующая команда выдаёт список коммитов, сделанных за последние две недели:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --since<span style=color:#f92672>=</span>2.weeks
</span></span></code></pre></div><p>Такая команда может работать с множеством форматов — вы можете указать точную дату (“2008-01-15”) или относительную дату, такую как “2 years 1 day 3 minutes ago”.</p><p>Вы также можете отфильтровать список коммитов по какому-либо критерию поиска. Опция <code>--author</code> позволяет фильтровать по автору, опция <code>--grep</code> позволяет искать по ключевым словам в сообщении. (Заметим, что, если вы укажете и опцию <code>author</code>, и опцию <code>grep</code>, то будут найдены все коммиты, которые удовлетворяют первому ИЛИ второму критерию. Чтобы найти коммиты, которые удовлетворяют первому И второму критерию, следует добавить опцию <code>--all-match</code>.)</p><p>Последняя действительно полезная опция-фильтр для <code>git log</code> — это путь. Указав имя каталога или файла, вы ограничите вывод log теми коммитами, которые вносят изменения в указанные файлы. Эта опция всегда указывается последней и обычно предваряется двумя минусами (<code>--</code>), чтобы отделить пути от остальных опций.</p><p>В таблице для справки приведён список часто употребляемых опций.</p><pre tabindex=0><code>Опция	            Описание
-(n)	            Показать последние n коммитов
--since, --after	Ограничить коммиты теми, которые сделаны после указанной даты.
--until, --before	Ограничить коммиты теми, которые сделаны до указанной даты.
--author	        Показать только те коммиты, автор которых соответствует указанной строке.
--committer	        Показать только те коммиты, коммитер которых соответствует указанной строке.
</code></pre><p>Например, если вы хотите посмотреть из истории Git&rsquo;а такие коммиты, которые вносят изменения в тестовые файлы, были сделаны Junio Hamano, не являются слияниями и были сделаны в октябре 2008го, вы можете выполнить что-то вроде такого:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;%h - %s&#34;</span> --author<span style=color:#f92672>=</span>gitster --since<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2008-10-01&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --before<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2008-11-01&#34;</span> --no-merges -- t/
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>5610e3b - Fix testcase failure when extended attribute
</span></span><span style=display:flex><span>acd3b9e - Enhance hold_lock_file_for_<span style=color:#f92672>{</span>update,append<span style=color:#f92672>}()</span>
</span></span><span style=display:flex><span>f563754 - demonstrate breakage of detached checkout wi
</span></span><span style=display:flex><span>d1a43f2 - reset --hard/read-tree --reset -u: remove un
</span></span><span style=display:flex><span>51a94af - Fix <span style=color:#e6db74>&#34;checkout --track -b newbranch&#34;</span> on detac
</span></span><span style=display:flex><span>b0ad11e - pull: allow <span style=color:#e6db74>&#34;git pull origin </span>$something<span style=color:#e6db74>:</span>$cur<span style=color:#e6db74>
</span></span></span></code></pre></div><p>Из примерно 20 000 коммитов в истории Git&rsquo;а, данная команда выбрала всего 6 коммитов, соответствующих заданным критериям.</p><h3 id=использование-графического-интерфейса-для-визуализации-истории class="relative group">Использование графического интерфейса для визуализации истории <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b3%d1%80%d0%b0%d1%84%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b3%d0%be-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81%d0%b0-%d0%b4%d0%bb%d1%8f-%d0%b2%d0%b8%d0%b7%d1%83%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d0%b8-%d0%b8%d1%81%d1%82%d0%be%d1%80%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h3><p>Если у вас есть желание использовать какой-нибудь графический инструмент для визуализации истории коммитов, можно попробовать распространяемую вместе с Git&rsquo;ом программу gitk, написанную на Tcl/Tk. В сущности gitk — это наглядный вариант <code>git log</code>, к тому же он принимает почти те же фильтрующие опции, что и <code>git log</code>. Если наберёте в командной строке gitk, находясь в проекте, то увидите что-то наподобие.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0202-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 2-2. Визуализация истории с помощью gitk.</p></blockquote><p>В верхней части окна располагается история коммитов вместе с подробным графом наследников. Просмотрщик дельт в нижней половине окна отображает изменения, сделанные выбранным коммитом. Указать коммит можно с помощью щелчка мышью.</p><h2 id=отмена-изменений class="relative group">Отмена изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%bc%d0%b5%d0%bd%d0%b0-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h2><p>На любой стадии может возникнуть необходимость что-либо отменить. Здесь мы рассмотрим несколько основных инструментов для отмены произведённых изменений. Будьте осторожны, ибо не всегда можно отменить сами отмены. Это одно из немногих мест в Git&rsquo;е, где вы можете потерять свою работу если сделаете что-то неправильно.</p><h3 id=изменение-последнего-коммита class="relative group">Изменение последнего коммита <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d0%bd%d0%b5%d0%b3%d0%be-%d0%ba%d0%be%d0%bc%d0%bc%d0%b8%d1%82%d0%b0 aria-label=Якорь>#</a></span></h3><p>Одна из типичных отмен происходит тогда, когда вы делаете коммит слишком рано, забыв добавить какие-то файлы, или напутали с комментарием к коммиту. Если вам хотелось бы сделать этот коммит ещё раз, вы можете выполнить commit с опцией <code>--amend</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div><p>Эта команда берёт индекс и использует его для коммита. Если после последнего коммита не было никаких изменений (например, вы запустили приведённую команду сразу после предыдущего коммита), то состояние проекта будет абсолютно таким же и всё, что вы измените, это комментарий к коммиту.</p><p>Появится всё тот же редактор для комментариев к коммитам, но уже с введённым комментарием к последнему коммиту. Вы можете отредактировать это сообщение так же, как обычно, и оно перепишет предыдущее.</p><p>Для примера, если после совершения коммита вы осознали, что забыли проиндексировать изменения в файле, которые хотели добавить в этот коммит, вы можете сделать что-то подобное:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;initial commit&#39;</span>
</span></span><span style=display:flex><span>$ git add forgotten_file
</span></span><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div><p>Все три команды вместе дают один коммит — второй коммит заменяет результат первого.</p><h3 id=отмена-индексации-файла class="relative group">Отмена индексации файла <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%bc%d0%b5%d0%bd%d0%b0-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b0%d1%86%d0%b8%d0%b8-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0 aria-label=Якорь>#</a></span></h3><p>В следующих двух разделах мы продемонстрируем, как переделать изменения в индексе и в рабочем каталоге. Приятно то, что команда, используемая для определения состояния этих двух вещей, дополнительно напоминает о том, как отменить изменения в них. Приведём пример. Допустим, вы внесли изменения в два файла и хотите записать их как два отдельных коммита, но случайно набрали <code>git add .</code> и проиндексировали оба файла. Как теперь отменить индексацию одного из двух файлов? Команда <code>git status</code> напомнит вам об этом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add .
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   README.txt</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Сразу после надписи “Changes to be committed”, написано использовать <code>git reset HEAD &lt;файл>...</code> для исключения из индекса. Так что давайте последуем совету и отменим индексацию файла benchmarks.rb:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git reset HEAD benchmarks.rb
</span></span><span style=display:flex><span>benchmarks.rb: locally modified
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   README.txt</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Эта команда немного странновата, но она работает. Файл benchmarks.rb изменён, но снова не в индексе.</p><h3 id=отмена-изменений-файла class="relative group">Отмена изменений файла <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%bc%d0%b5%d0%bd%d0%b0-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0 aria-label=Якорь>#</a></span></h3><p>Что, если вы поняли, что не хотите оставлять изменения, внесённые в файл benchmarks.rb? Как быстро отменить изменения, вернуть то состояние, в котором он находился во время последнего коммита (или первоначального клонирования, или какого-то другого действия, после которого файл попал в рабочий каталог)? К счастью, <code>git status</code> говорит, как добиться и этого. В выводе для последнего примера, неиндексированная область выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   benchmarks.rb</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Здесь довольно ясно сказано, как отменить сделанные изменения (по крайней мере новые версии Git&rsquo;а, начиная с 1.6.1, делают это; если у вас версия старее, мы настоятельно рекомендуем обновиться, чтобы получать такие подсказки и сделать свою работу удобней). Давайте сделаем то, что написано:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -- benchmarks.rb
</span></span><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   README.txt</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Как вы видите, изменения были отменены. Вы должны понимать, что это опасная команда: все сделанные вами изменения в этом файле пропали — вы просто скопировали поверх него другой файл. Никогда не используйте эту команду, если вы не полностью уверены, что этот файл вам не нужен. Если вам нужно просто сделать, чтобы он не мешался, мы рассмотрим прятание (stash) и ветвление; эти способы обычно более предпочтительны.</p><p>Помните, что всё, что является частью коммита в Git&rsquo;е, почти всегда может быть восстановлено. Даже коммиты, которые находятся на ветках, которые были удалены, и коммиты переписанные с помощью <code>--amend</code> могут быть восстановлены. Несмотря на это, всё, что никогда не попадало в коммит, вы скорее всего уже не увидите снова.</p><h2 id=работа-с-удалёнными-репозиториями class="relative group">Работа с удалёнными репозиториями <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0-%d1%81-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d0%bc%d0%b8-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h2><p>Чтобы иметь возможность совместной работы над каким-либо Git-проектом, необходимо знать, как управлять удалёнными репозиториями. Удалённые репозитории — это модификации проекта, которые хранятся в интернете или ещё где-то в сети. Их может быть несколько, каждый из которых, как правило, доступен для вас либо только на чтение, либо на чтение и запись. Совместная работа включает в себя управление удалёнными репозиториями и помещение (push) и получение (pull) данных в и из них тогда, когда нужно обменяться результатами работы.
Управление удалёнными репозиториями включает умение добавлять удалённые репозитории, удалять те из них, которые больше не действуют, умение управлять различными удалёнными ветками и определять их как отслеживаемые (tracked) или нет и прочее. Данный раздел охватывает все перечисленные навыки по управлению удалёнными репозиториями.</p><h3 id=отображение-удалённых-репозиториев class="relative group">Отображение удалённых репозиториев <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%be%d0%b1%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d0%b5-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d1%85-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d0%b5%d0%b2 aria-label=Якорь>#</a></span></h3><p>Чтобы просмотреть, какие удалённые серверы у вас уже настроены, следует выполнить команду <code>git remote</code>. Она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов. Если вы склонировали ваш репозиторий, у вас должен отобразиться, по крайней мере, origin — это имя по умолчанию, которое Git присваивает серверу, с которого вы склонировали:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone git://github.com/schacon/ticgit.git
</span></span><span style=display:flex><span>Initialized empty Git repository in /private/tmp/ticgit/.git/
</span></span><span style=display:flex><span>remote: Counting objects: 595, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>269/269<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>595</span> <span style=color:#f92672>(</span>delta 255<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>589</span> <span style=color:#f92672>(</span>delta 253<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Receiving objects: 100% <span style=color:#f92672>(</span>595/595<span style=color:#f92672>)</span>, 73.31 KiB | <span style=color:#ae81ff>1</span> KiB/s, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Resolving deltas: 100% <span style=color:#f92672>(</span>255/255<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>$ cd ticgit
</span></span><span style=display:flex><span>$ git remote
</span></span><span style=display:flex><span>origin
</span></span></code></pre></div><p>Чтобы посмотреть, какому URL соответствует сокращённое имя в Git, можно указать команде опцию <code>-v</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote -v
</span></span><span style=display:flex><span>origin  git://github.com/schacon/ticgit.git <span style=color:#f92672>(</span>fetch<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>origin  git://github.com/schacon/ticgit.git <span style=color:#f92672>(</span>push<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Если у вас больше одного удалённого репозитория, команда покажет их все. Например, мой репозиторий Grit выглядит следующим образом.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cd grit
</span></span><span style=display:flex><span>$ git remote -v
</span></span><span style=display:flex><span>bakkdoor  git://github.com/bakkdoor/grit.git
</span></span><span style=display:flex><span>cho45     git://github.com/cho45/grit.git
</span></span><span style=display:flex><span>defunkt   git://github.com/defunkt/grit.git
</span></span><span style=display:flex><span>koke      git://github.com/koke/grit.git
</span></span><span style=display:flex><span>origin    git@github.com:mojombo/grit.git
</span></span></code></pre></div><p>Это означает, что мы легко можем получить изменения от любого из этих пользователей. Но, заметьте, что origin — это единственный удалённый сервер прописанный как SSH-ссылка, поэтому он единственный, в который я могу помещать свои изменения (мы рассмотрим подробнее этот момент в рамках следуюзих лекций).</p><h3 id=добавление-удалённых-репозиториев class="relative group">Добавление удалённых репозиториев <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d1%85-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d0%b5%d0%b2 aria-label=Якорь>#</a></span></h3><p>В предыдущих разделах мы упомянули и немного продемонстрировали добавление удалённых репозиториев, сейчас мы рассмотрим это более детально. Чтобы добавить новый удалённый Git-репозиторий под именем-сокращением, к которому будет проще обращаться, выполните <code>git remote add [сокращение] [url]</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote
</span></span><span style=display:flex><span>origin
</span></span><span style=display:flex><span>$ git remote add pb git://github.com/paulboone/ticgit.git
</span></span><span style=display:flex><span>$ git remote -v
</span></span><span style=display:flex><span>origin	git://github.com/schacon/ticgit.git
</span></span><span style=display:flex><span>pb	git://github.com/paulboone/ticgit.git
</span></span></code></pre></div><p>Теперь вы можете использовать в командной строке имя pb вместо полного URL. Например, если вы хотите извлечь (fetch) всю информацию, которая есть в репозитории Павла, но нет в вашем, вы можете выполнить <code>git fetch pb</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fetch pb
</span></span><span style=display:flex><span>remote: Counting objects: 58, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>41/41<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>44</span> <span style=color:#f92672>(</span>delta 24<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Unpacking objects: 100% <span style=color:#f92672>(</span>44/44<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>From git://github.com/paulboone/ticgit
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      master     -&gt; pb/master
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      ticgit     -&gt; pb/ticgit
</span></span></code></pre></div><p>Ветка <code>master</code> Павла теперь доступна локально как <code>pb/master</code>. Вы можете слить (merge) её в одну из своих веток или перейти на эту ветку, если хотите её проверить.</p><h3 id=fetch-и-pull class="relative group">Fetch и Pull <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fetch-%d0%b8-pull aria-label=Якорь>#</a></span></h3><p>Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fetch <span style=color:#f92672>[</span>имя удал. сервера<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта. Теперь эти ветки в любой момент могут быть просмотрены или слиты.</p><p>Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем origin. Таким образом, <code>git fetch origin</code> извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch). Важно отметить, что команда <code>fetch</code> забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.</p><p>Если у вас есть ветка, настроенная на отслеживание удалённой ветки (для дополнительной информации смотри следующий раздел и главу 3), то вы можете использовать команду <code>git pull</code>. Она автоматически извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку. Этот способ может для вас оказаться более простым или более удобным. К тому же по умолчанию команда <code>git clone</code> автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали (подразумевается, что на удалённом сервере есть ветка master). Выполнение <code>git pull</code>, как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.</p><h3 id=push class="relative group">Push <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#push aria-label=Якорь>#</a></span></h3><p>Когда вы хотите поделиться своими наработками, вам необходимо отправить (push) их в главный репозиторий. Команда для этого действия простая: <code>git push [удал. сервер] [ветка]</code>. Чтобы отправить вашу ветку master на сервер <code>origin</code> (повторимся, что клонирование, как правило, настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки наработок на сервер:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin master
</span></span></code></pre></div><p>Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push.</p><h3 id=инспекция-удалённого-репозитория class="relative group">Инспекция удалённого репозитория <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d0%bd%d1%81%d0%bf%d0%b5%d0%ba%d1%86%d0%b8%d1%8f-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d0%be%d0%b3%d0%be-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду <code>git remote show [удал. сервер]</code>. Если вы выполните эту команду с некоторым именем, например, <code>origin</code>, вы получите что-то подобное:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote show origin
</span></span><span style=display:flex><span>* remote origin
</span></span><span style=display:flex><span>  URL: git://github.com/schacon/ticgit.git
</span></span><span style=display:flex><span>  Remote branch merged with <span style=color:#e6db74>&#39;git pull&#39;</span> <span style=color:#66d9ef>while</span> on branch master
</span></span><span style=display:flex><span>    master
</span></span><span style=display:flex><span>  Tracked remote branches
</span></span><span style=display:flex><span>    master
</span></span><span style=display:flex><span>    ticgit
</span></span></code></pre></div><p>Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните <code>git pull</code>, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.</p><p>Это был пример для простой ситуации, и наверняка вы встретились с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от <code>git remote show</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote show origin
</span></span><span style=display:flex><span>* remote origin
</span></span><span style=display:flex><span>  URL: git@github.com:defunkt/github.git
</span></span><span style=display:flex><span>  Remote branch merged with <span style=color:#e6db74>&#39;git pull&#39;</span> <span style=color:#66d9ef>while</span> on branch issues
</span></span><span style=display:flex><span>    issues
</span></span><span style=display:flex><span>  Remote branch merged with <span style=color:#e6db74>&#39;git pull&#39;</span> <span style=color:#66d9ef>while</span> on branch master
</span></span><span style=display:flex><span>    master
</span></span><span style=display:flex><span>  New remote branches <span style=color:#f92672>(</span>next fetch will store in remotes/origin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    caching
</span></span><span style=display:flex><span>  Stale tracking branches <span style=color:#f92672>(</span>use <span style=color:#e6db74>&#39;git remote prune&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    libwalker
</span></span><span style=display:flex><span>    walker2
</span></span><span style=display:flex><span>  Tracked remote branches
</span></span><span style=display:flex><span>    acl
</span></span><span style=display:flex><span>    apiv2
</span></span><span style=display:flex><span>    dashboard2
</span></span><span style=display:flex><span>    issues
</span></span><span style=display:flex><span>    master
</span></span><span style=display:flex><span>    postgres
</span></span><span style=display:flex><span>  Local branch pushed with <span style=color:#e6db74>&#39;git push&#39;</span>
</span></span><span style=display:flex><span>    master:master
</span></span></code></pre></div><p>Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении <code>git push</code>. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере. И для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении <code>git pull</code>.</p><h3 id=удаление-и-переименование-удалённых-репозиториев class="relative group">Удаление и переименование удалённых репозиториев <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d0%bf%d0%b5%d1%80%d0%b5%d0%b8%d0%bc%d0%b5%d0%bd%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d1%85-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d0%b5%d0%b2 aria-label=Якорь>#</a></span></h3><p>Для переименования ссылок в новых версиях Git&rsquo;а можно вылолнить <code>git remote rename</code>, это изменит сокращённое имя, используемое для удалённого репозитория. Например, если вы хотите переименовать <code>pb</code> в <code>paul</code>, вы можете сделать это следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote rename pb paul
</span></span><span style=display:flex><span>$ git remote
</span></span><span style=display:flex><span>origin
</span></span><span style=display:flex><span>paul
</span></span></code></pre></div><p>Стоит упомянуть, что это также меняет для вас имена удалённых веток. То, к чему вы обращались как <code>pb/master</code>, стало <code>paul/master</code>.</p><p>Если по какой-то причине вы хотите удалить ссылку (вы сменили сервер или больше не используете определённое зеркало, или, возможно, контрибьютор перестал быть активным), вы можете использовать <code>git remote rm</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git remote rm paul
</span></span><span style=display:flex><span>$ git remote
</span></span><span style=display:flex><span>origin
</span></span></code></pre></div><h2 id=работа-с-метками class="relative group">Работа с метками <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0-%d1%81-%d0%bc%d0%b5%d1%82%d0%ba%d0%b0%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h2><p>Как и большинство СКВ, Git имеет возможность помечать (tag) определённые моменты в истории как важные. Как правило, этот функционал используется для отметки моментов выпуска версий (v1.0, и т.п.). В этом разделе вы узнаете, как посмотреть имеющиеся метки (tag), как создать новые. А также вы узнаете, что из себя представляют разные типы меток.</p><h3 id=просмотр-меток class="relative group">Просмотр меток <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80-%d0%bc%d0%b5%d1%82%d0%be%d0%ba aria-label=Якорь>#</a></span></h3><p>Просмотр имеющихся меток (tag) в Git&rsquo;е делается просто. Достаточно набрать <code>git tag</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag
</span></span><span style=display:flex><span>v0.1
</span></span><span style=display:flex><span>v1.3
</span></span></code></pre></div><p>Данная команда перечисляет метки в алфавитном порядке; порядок их появления не имеет значения.</p><p>Для меток вы также можете осуществлять поиск по шаблону. Например, репозиторий Git&rsquo;а содержит более 240 меток. Если вас интересует просмотр только выпусков 1.4.2, вы можете выполнить следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -l <span style=color:#e6db74>&#39;v1.4.2.*&#39;</span>
</span></span><span style=display:flex><span>v1.4.2.1
</span></span><span style=display:flex><span>v1.4.2.2
</span></span><span style=display:flex><span>v1.4.2.3
</span></span><span style=display:flex><span>v1.4.2.4
</span></span></code></pre></div><h3 id=создание-меток class="relative group">Создание меток <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b5%d1%82%d0%be%d0%ba aria-label=Якорь>#</a></span></h3><p>Git использует два основных типа меток: легковесные и аннотированные. Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. А вот аннотированные метки хранятся в базе данных Git&rsquo;а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.</p><h3 id=аннотированные-метки class="relative group">Аннотированные метки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b0%d0%bd%d0%bd%d0%be%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5-%d0%bc%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Создание аннотированной метки в Git&rsquo;е выполняется легко. Самый простой способ это указать <code>-a</code> при выполнении команды <code>tag</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -a v1.4 -m <span style=color:#e6db74>&#39;my version 1.4&#39;</span>
</span></span><span style=display:flex><span>$ git tag
</span></span><span style=display:flex><span>v0.1
</span></span><span style=display:flex><span>v1.3
</span></span><span style=display:flex><span>v1.4
</span></span></code></pre></div><p>Опция <code>-m</code> задаёт меточное сообщение, которое будет храниться вместе с меткой. Если не указать сообщение для аннотированной метки, Git запустит редактор, чтоб вы смогли его ввести.</p><p>Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с помощью команды <code>git show</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show v1.4
</span></span><span style=display:flex><span>tag v1.4
</span></span><span style=display:flex><span>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Feb <span style=color:#ae81ff>9</span> 14:45:11 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my version 1.4
</span></span><span style=display:flex><span>commit 15027957951b64cf874c3557a0f3547bd83b3ff6
</span></span><span style=display:flex><span>Merge: 4a447f7... a6b4c97...
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sun Feb <span style=color:#ae81ff>8</span> 19:02:46 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge branch <span style=color:#e6db74>&#39;experiment&#39;</span>
</span></span></code></pre></div><p>Она показывает информацию о выставившем метку, дату отметки коммита и аннотирующее сообщение перед информацией о коммите.</p><h3 id=подписанные-метки class="relative group">Подписанные метки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%be%d0%b4%d0%bf%d0%b8%d1%81%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5-%d0%bc%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Вы также можете подписывать свои метки с помощью GPG, конечно, если у вас есть ключ. Всё что нужно сделать, это использовать <code>-s</code> вместо <code>-a</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -s v1.5 -m <span style=color:#e6db74>&#39;my signed 1.5 tag&#39;</span>
</span></span><span style=display:flex><span>You need a passphrase to unlock the secret key <span style=color:#66d9ef>for</span>
</span></span><span style=display:flex><span>user: <span style=color:#e6db74>&#34;Scott Chacon &lt;schacon@gee-mail.com&gt;&#34;</span>
</span></span><span style=display:flex><span>1024-bit DSA key, ID F721C45A, created 2009-02-09
</span></span></code></pre></div><p>Если вы выполните <code>git show</code> на этой метке, то увидите прикреплённую к ней GPG-подпись:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show v1.5
</span></span><span style=display:flex><span>tag v1.5
</span></span><span style=display:flex><span>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Feb <span style=color:#ae81ff>9</span> 15:22:20 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my signed 1.5 tag
</span></span><span style=display:flex><span>-----BEGIN PGP SIGNATURE-----
</span></span><span style=display:flex><span>Version: GnuPG v1.4.8 <span style=color:#f92672>(</span>Darwin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
</span></span><span style=display:flex><span>Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>WryJ
</span></span><span style=display:flex><span>-----END PGP SIGNATURE-----
</span></span><span style=display:flex><span>commit 15027957951b64cf874c3557a0f3547bd83b3ff6
</span></span><span style=display:flex><span>Merge: 4a447f7... a6b4c97...
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sun Feb <span style=color:#ae81ff>8</span> 19:02:46 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge branch <span style=color:#e6db74>&#39;experiment&#39;</span>
</span></span></code></pre></div><p>Чуть позже вы узнаете, как верифицировать метки с подписью.</p><h3 id=легковесные-метки class="relative group">Легковесные метки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bb%d0%b5%d0%b3%d0%ba%d0%be%d0%b2%d0%b5%d1%81%d0%bd%d1%8b%d0%b5-%d0%bc%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Легковесная метка — это ещё один способ отметки коммитов. В сущности, это контрольная сумма коммита, сохранённая в файл — больше никакой информации не хранится. Для создания легковесной метки не передавайте опций <code>-a</code>, <code>-s</code> и <code>-m</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag v1.4-lw
</span></span><span style=display:flex><span>$ git tag
</span></span><span style=display:flex><span>v0.1
</span></span><span style=display:flex><span>v1.3
</span></span><span style=display:flex><span>v1.4
</span></span><span style=display:flex><span>v1.4-lw
</span></span><span style=display:flex><span>v1.5
</span></span></code></pre></div><p>На этот раз при выполнении <code>git show</code> на этой метке вы не увидите дополнительной информации. Команда просто покажет помеченный коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git show v1.4-lw
</span></span><span style=display:flex><span>commit 15027957951b64cf874c3557a0f3547bd83b3ff6
</span></span><span style=display:flex><span>Merge: 4a447f7... a6b4c97...
</span></span><span style=display:flex><span>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sun Feb <span style=color:#ae81ff>8</span> 19:02:46 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Merge branch <span style=color:#e6db74>&#39;experiment&#39;</span>
</span></span></code></pre></div><h3 id=верификация-меток class="relative group">Верификация меток <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d0%b5%d1%80%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d1%8f-%d0%bc%d0%b5%d1%82%d0%be%d0%ba aria-label=Якорь>#</a></span></h3><p>Для верификации подписанной метки, используйте <code>git tag -v [имя метки]</code>. Эта команда использует GPG для верификации подписи. Вам нужен открытый ключ автора подписи, чтобы команда работала правильно:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -v v1.4.2.1
</span></span><span style=display:flex><span>object 883653babd8ee7ea23e6a5c392bb739348b1eb61
</span></span><span style=display:flex><span>type commit
</span></span><span style=display:flex><span>tag v1.4.2.1
</span></span><span style=display:flex><span>tagger Junio C Hamano &lt;junkio@cox.net&gt; <span style=color:#ae81ff>1158138501</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>GIT 1.4.2.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Minor fixes since 1.4.2, including git-mv and git-http with alternates.
</span></span><span style=display:flex><span>gpg: Signature made Wed Sep <span style=color:#ae81ff>13</span> 02:08:25 <span style=color:#ae81ff>2006</span> PDT using DSA key ID F3119B9A
</span></span><span style=display:flex><span>gpg: Good signature from <span style=color:#e6db74>&#34;Junio C Hamano &lt;junkio@cox.net&gt;&#34;</span>
</span></span><span style=display:flex><span>gpg:                 aka <span style=color:#e6db74>&#34;[jpeg image of size 1513]&#34;</span>
</span></span><span style=display:flex><span>Primary key fingerprint: <span style=color:#ae81ff>3565</span> 2A26 <span style=color:#ae81ff>2040</span> E066 C9A7  4A7D C0C6 D9A4 F311 9B9A
</span></span></code></pre></div><p>Если у вас нет открытого ключа автора подписи, вы вместо этого получите что-то подобное:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gpg: Signature made Wed Sep <span style=color:#ae81ff>13</span> 02:08:25 <span style=color:#ae81ff>2006</span> PDT using DSA key ID F3119B9A
</span></span><span style=display:flex><span>gpg: Can<span style=color:#e6db74>&#39;t check signature: public key not found
</span></span></span><span style=display:flex><span><span style=color:#e6db74>error: could not verify the tag &#39;</span>v1.4.2.1<span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span></code></pre></div><h3 id=выставление-меток-позже class="relative group">Выставление меток позже <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d1%8b%d1%81%d1%82%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b5%d1%82%d0%be%d0%ba-%d0%bf%d0%be%d0%b7%d0%b6%d0%b5 aria-label=Якорь>#</a></span></h3><p>Также возможно помечать уже пройденные коммиты. Предположим, что история коммитов выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --pretty<span style=color:#f92672>=</span>oneline
</span></span><span style=display:flex><span>15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span style=color:#e6db74>&#39;experiment&#39;</span>
</span></span><span style=display:flex><span>a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
</span></span><span style=display:flex><span>0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
</span></span><span style=display:flex><span>6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span style=color:#e6db74>&#39;experiment&#39;</span>
</span></span><span style=display:flex><span>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit <span style=color:#66d9ef>function</span>
</span></span><span style=display:flex><span>4682c3261057305bdd616e23b64b0857d832627b added a todo file
</span></span><span style=display:flex><span>166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
</span></span><span style=display:flex><span>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
</span></span><span style=display:flex><span>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
</span></span><span style=display:flex><span>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
</span></span></code></pre></div><p>Теперь предположим, что вы забыли отметить версию проекта v1.2, которая была там, где находится коммит &ldquo;updated rakefile&rdquo;. Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag -a v1.2 -m <span style=color:#e6db74>&#39;version 1.2&#39;</span> 9fceb02
</span></span></code></pre></div><p>Можете проверить, что коммит теперь отмечен:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git tag
</span></span><span style=display:flex><span>v0.1
</span></span><span style=display:flex><span>v1.2
</span></span><span style=display:flex><span>v1.3
</span></span><span style=display:flex><span>v1.4
</span></span><span style=display:flex><span>v1.4-lw
</span></span><span style=display:flex><span>v1.5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ git show v1.2
</span></span><span style=display:flex><span>tag v1.2
</span></span><span style=display:flex><span>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Feb <span style=color:#ae81ff>9</span> 15:32:16 <span style=color:#ae81ff>2009</span> -0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>version 1.2
</span></span><span style=display:flex><span>commit 9fceb02d0ae598e95dc970b74767f19372d61af8
</span></span><span style=display:flex><span>Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
</span></span><span style=display:flex><span>Date:   Sun Apr <span style=color:#ae81ff>27</span> 20:43:35 <span style=color:#ae81ff>2008</span> -0700
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    updated rakefile
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h3 id=обмен-метками class="relative group">Обмен метками <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d0%b1%d0%bc%d0%b5%d0%bd-%d0%bc%d0%b5%d1%82%d0%ba%d0%b0%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h3><p>По умолчанию, команда <code>git push</code> не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки на общий сервер после того, как вы их создали. Это делается так же, как и выкладывание в совместное пользование удалённых веток — нужно выполнить <code>git push origin [имя метки]</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin v1.5
</span></span><span style=display:flex><span>Counting objects: 50, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>38/38<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>44/44<span style=color:#f92672>)</span>, 4.56 KiB, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>44</span> <span style=color:#f92672>(</span>delta 18<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>8</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>To git@github.com:schacon/simplegit.git
</span></span><span style=display:flex><span>* <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v1.5 -&gt; v1.5
</span></span></code></pre></div><p>Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию <code>--tags</code> для команды <code>git push</code>. В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin --tags
</span></span><span style=display:flex><span>Counting objects: 50, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>38/38<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>44/44<span style=color:#f92672>)</span>, 4.56 KiB, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>44</span> <span style=color:#f92672>(</span>delta 18<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>8</span> <span style=color:#f92672>(</span>delta 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>To git@github.com:schacon/simplegit.git
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v0.1 -&gt; v0.1
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v1.2 -&gt; v1.2
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v1.4 -&gt; v1.4
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v1.4-lw -&gt; v1.4-lw
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new tag<span style=color:#f92672>]</span>         v1.5 -&gt; v1.5
</span></span></code></pre></div><p>Теперь, если кто-то склонирует (clone) или выполнит <code>git pull</code> из вашего репозитория, то он получит вдобавок к остальному и ваши метки.</p><h2 id=полезные-советы class="relative group">Полезные советы <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%be%d0%bb%d0%b5%d0%b7%d0%bd%d1%8b%d0%b5-%d1%81%d0%be%d0%b2%d0%b5%d1%82%d1%8b aria-label=Якорь>#</a></span></h2><p>Перед тем как закончить об основах Git&rsquo;а, дадим несколько полезных советов о том, как сделать ваш опыт работы с Git&rsquo;ом проще, удобнее или привычнее. Многие люди используют Git, не прибегая к этим советам, и мы дальше в книге не будем ссылаться на них или подразумевать, что вы ими пользуетесь, но вам всё же стоит знать о них.</p><h3 id=автоматическое-дополнение class="relative group">Автоматическое дополнение <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b0%d0%b2%d1%82%d0%be%d0%bc%d0%b0%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%b4%d0%be%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5 aria-label=Якорь>#</a></span></h3><p>Если вы используете командную оболочку Bash, Git поставляется с замечательным сценарием (script), который вы можете активировать. Скачайте исходный код Git&rsquo;а и посмотрите в каталоге <code>contrib/completion</code>; там должен быть файл <code>git-completion.bash</code>. Скопируйте этот файл в свой домашний каталог и добавьте следующее в файл <code>.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>source ~/.git-completion.bash
</span></span></code></pre></div><p>Если вы хотите настроить автоматическое дополнение в Bash&rsquo;е для всех пользователей, скопируйте этот сценарий в каталог <code>/opt/local/etc/bash_completion.d</code> на Mac-системах или в каталог <code>/etc/bash_completion.d/</code> на Linux-системах. Это каталог, из которого Bash автоматически загружает сценарии для автодополнения.</p><p>Если вы используете Git Bash на Windows, что является стандартным при установке Git&rsquo;а на Windows с помощью msysGit, то автодополнение должно быть настроено заранее.</p><p>Нажав Tab во время ввода команды для Git&rsquo;а, вы должны получить набор вариантов на выбор:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git co&lt;tab&gt;&lt;tab&gt;
</span></span><span style=display:flex><span>commit config
</span></span></code></pre></div><p>В данном случае, набрав <code>git co</code> и дважды нажав клавишу Tab, вы получите как варианты commit и config. Добавление <code>m&lt;tab></code> выполнит дополнение до <code>git commit</code> автоматически.</p><p>То же самое работает и для опций, что, возможно, полезней. Например, если вы хотите выполнить команду <code>git log</code> и не помните какую-то опцию, вы можете начать её печатать и затем нажать Tab, чтобы увидеть, что подходит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git log --s&lt;tab&gt;
</span></span><span style=display:flex><span>--shortstat  --since<span style=color:#f92672>=</span>  --src-prefix<span style=color:#f92672>=</span>  --stat   --summary
</span></span></code></pre></div><p>Это довольно приятная уловка, которая может сэкономить вам немного рабочего времени от чтения документации.</p><h3 id=псевдонимы-в-git class="relative group">Псевдонимы в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%81%d0%b5%d0%b2%d0%b4%d0%be%d0%bd%d0%b8%d0%bc%d1%8b-%d0%b2-git aria-label=Якорь>#</a></span></h3><p>Git не будет пытаться сделать вывод о том, какую команду вы хотели ввести, если вы ввели её неполностью. Если вы не хотите печатать каждую команду для Git&rsquo;а целиком, вы легко можете настроить псевдонимы (alias) для любой команды с помощью <code>git config</code>. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global alias.co checkout
</span></span><span style=display:flex><span>$ git config --global alias.br branch
</span></span><span style=display:flex><span>$ git config --global alias.ci commit
</span></span><span style=display:flex><span>$ git config --global alias.st status
</span></span></code></pre></div><p>Это означает, что, например, вместо набирания <code>git commit</code>, вам достаточно набрать только <code>git ci</code>. По мере освоения Git&rsquo;а вам, вероятно, придётся часто пользоваться и другими командами. В этом случае без колебаний создавайте новые псевдонимы.</p><p>Такой способ может также быть полезен для создания команд, которые, вы думаете, должны существовать. Например, чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним unstage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global alias.unstage <span style=color:#e6db74>&#39;reset HEAD --&#39;</span>
</span></span></code></pre></div><p>Это делает следующие две команды эквивалентными:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git unstage fileA
</span></span><span style=display:flex><span>$ git reset HEAD fileA
</span></span></code></pre></div><p>Так как будто немного понятней. Также обычно добавляют команду <code>last</code> следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global alias.last <span style=color:#e6db74>&#39;log -1 HEAD&#39;</span>
</span></span></code></pre></div><p>Так легко можно просмотреть последний коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git last
</span></span><span style=display:flex><span>commit 66938dae3329c7aebe598c2246a8e6af90d04646
</span></span><span style=display:flex><span>Author: Josh Goebel &lt;dreamer3@example.com&gt;
</span></span><span style=display:flex><span>Date:   Tue Aug <span style=color:#ae81ff>26</span> 19:48:51 <span style=color:#ae81ff>2008</span> +0800
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    test <span style=color:#66d9ef>for</span> current head
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;
</span></span></code></pre></div><p>Можно сказать, что Git просто заменяет эти новые команды на то, для чего вы создавали псевдоним (alias). Однако, возможно, вы захотите выполнять внешнюю команду, а не подкоманду Git&rsquo;а. В этом случае, следует начать команду с символа <code>!</code>. Такое полезно, если вы пишите свои утилиты для работы с Git-репозиторием. Продемонстрируем этот случай на примере создания псевдонима <code>git visual</code> для запуска <code>gitk</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global alias.visual <span style=color:#e6db74>&#39;!gitk&#39;</span>
</span></span></code></pre></div><h2 id=итоги class="relative group">Итоги <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%82%d0%be%d0%b3%d0%b8 aria-label=Якорь>#</a></span></h2><p>К этому моменту вы умеете выполнять все базовые локальные операции с Git&rsquo;ом: создавать или клонировать репозиторий, вносить изменения, индексировать и фиксировать эти изменения, а также просматривать историю всех изменений в репозитории. Дальше мы рассмотрим самую убийственную особенность Git&rsquo;а — его модель ветвления.</p><h1 id=ветвление-в-git class="relative group">Ветвление в Git <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b2-git aria-label=Якорь>#</a></span></h1><p>Почти каждая СКВ имеет в какой-то форме поддержку ветвления. Ветвление означает, что вы отклоняетесь от основной линии разработки и продолжаете работу, не вмешиваясь в основную линию. Во многих СКВ это в некотором роде дорогостоящий процесс, зачастую требующий от вас создания новой копии каталога с исходным кодом, что может занять продолжительное время для больших проектов.</p><p>Некоторые говорят, что модель ветвления Git&rsquo;а это его “killer feature“ и она безусловно выделяет Git в СКВ-сообществе. Что же в ней такого особенного? Способ ветвления в Git&rsquo;е чрезвычайно легковесен, что делает операции ветвления практически мгновенными и переключение туда-сюда между ветками обычно так же быстрым. В отличие от многих других СКВ, Git поощряет процесс работы, при котором ветвление и слияние осуществляется часто, даже по несколько раз в день. Понимание и владение этой функциональностью даёт вам уникальный мощный инструмент и может буквально изменить то, как вы ведёте разработку.</p><h2 id=что-такое-ветка class="relative group">Что такое ветка? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b0 aria-label=Якорь>#</a></span></h2><p>Чтобы на самом деле разобраться в том, как Git работает с ветками, мы должны сделать шаг назад и рассмотреть, как Git хранит свои данные. Как вы, наверное, помните из первой лекции, Git хранит данные не как последовательность изменений или дельт, а как последовательность снимков состояния (snapshot).</p><p>Когда вы создаёте коммит в Git&rsquo;е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток.</p><p>Для наглядности давайте предположим, что у вас есть каталог, содержащий три файла, и вы хотите добавить их все в индекс и сделать коммит. При добавлении файлов в индекс для каждого из них вычислится контрольная сумма (SHA-1 хеш, о котором мы упоминали в главе 1), затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git add README test.rb LICENSE
</span></span><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;initial commit of my project&#39;</span>
</span></span></code></pre></div><p>Когда вы создаёте коммит, выполняя <code>git commit</code>, Git вычисляет контрольную сумму каждого подкаталога (в нашем случае только корневого каталога) и сохраняет эти объекты-деревья в Git-репозиторий. Затем Git создаёт объект для коммита, в котором есть метаданные и указатель на объект-дерево для корня проекта. Таким образом, Git сможет воссоздать текущее состояние, когда будет нужно.</p><p>Ваш Git-репозиторий теперь содержит пять объектов:</p><ul><li>по одному блобу для содержимого каждого из трёх файлов,</li><li>одно дерево, в котором перечислено содержимое каталога и определено соответствие имён файлов и блобов,</li><li>один коммит с указателем на тот самый объект-дерево для корня и со всеми метаданными коммита.</li></ul><p>Схематично данные в этом Git-репозитории выглядят так, как показано на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0301-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-1. Данные репозитория с единственным коммитом.</p></blockquote><p>Если вы сделаете некоторые изменения и создадите новый коммит, то следующий коммит сохранит указатель на коммит, который шёл непосредственно перед ним. После следующих двух коммитов история может выглядеть, как на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0302-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-2. Данные объектов Git&rsquo;а для нескольких коммитов.</p></blockquote><p>Ветка в Git&rsquo;е — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git&rsquo;е называется <code>master</code>. Когда вы создаёте коммиты на начальном этапе, вам дана ветка <code>master</code>, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0303-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-3. Ветка указывает на историю коммитов.</p></blockquote><p>Что произойдёт, если вы создадите новую ветку? Итак, этим вы создадите новый указатель, который можно будет перемещать. Скажем, создадим новую ветку под названием <code>testing</code>. Это делается командой <code>git branch</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch testing
</span></span></code></pre></div><p>Эта команда создаст новый указатель на тот самый коммит, на котором вы сейчас находитесь.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0304-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-4. Несколько веток, указывающих на историю коммитов.</p></blockquote><p>Откуда Git узнает, на какой ветке вы находитесь в данный момент? Он хранит специальный указатель, который называется HEAD (верхушка). Учтите, что это сильно отличается от концепции HEAD в других СКВ, таких как Subversion или CVS, к которым вы, возможно, привыкли. В Git&rsquo;е это указатель на локальную ветку, на которой вы находитесь. В данный момент вы всё ещё на ветке <code>master</code>. Команда <code>git branch</code> только создала новую ветку, она не переключила вас на неё.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0305-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-5. Файл HEAD указывает на текущую ветку.</p></blockquote><p>Чтобы перейти на существующую ветку, вам надо выполнить команду <code>git checkout</code>. Давайте перейдём на новую ветку <code>testing</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout testing
</span></span></code></pre></div><p>Это действие передвинет HEAD так, чтобы тот указывал на ветку <code>testing</code>.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0306-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-6. HEAD указывает на другую ветку после переключения веток.</p></blockquote><p>В чём же важность этого? Давайте сделаем ещё один коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vim test.rb
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;made a change&#39;</span>
</span></span></code></pre></div><p>На рисунке показан результат.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0307-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-7. Ветка, на которую указывает HEAD, движется вперёд с каждым коммитом.</p></blockquote><p>Это интересно, потому что теперь ваша ветка <code>testing</code> передвинулась вперёд, но ветка <code>master</code> всё ещё указывает на коммит, на котором вы были, когда выполняли <code>git checkout</code>, чтобы переключить ветки. Давайте перейдём обратно на ветку <code>master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span></code></pre></div><p>На рисунке можно увидеть результат.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0308-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-8. HEAD перемещается на другую ветку при checkout&rsquo;е.</p></blockquote><p>Эта команда выполнила два действия. Она передвинула указатель HEAD назад на ветку <code>master</code> и вернула файлы в вашем рабочем каталоге назад, в соответствие со снимком состояния, на который указывает <code>master</code>. Это также означает, что изменения, которые вы делаете, начиная с этого момента, будут ответвляться от старой версии проекта. Это, по сути, откатывает изменения, которые вы временно делали на ветке <code>testing</code>, так что дальше вы можете двигаться в другом направлении.</p><p>Давайте снова внесём немного изменений и сделаем коммит:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vim test.rb
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;made other changes&#39;</span>
</span></span></code></pre></div><p>Теперь история вашего проекта разветвилась. Вы создали новую ветку, перешли на неё, поработали на ней немного, переключились обратно на основную ветку и выполнили другую работу. Оба эти изменения изолированы в отдельных ветках: вы можете переключаться туда и обратно между ветками и слить их, когда будете готовы. И всё это было сделано простыми командами <code>branch</code> и <code>checkout</code>.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0309-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-9. История с разошедшимися ветками.</p></blockquote><p>Из-за того, что ветка в Git&rsquo;е на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно. Создание новой ветки настолько же быстрое и простое, как запись 41 байта в файл (40 символов + символ новой строки).</p><p>Это разительно отличается от того, как в большинстве СКВ делается ветвление. Там это приводит к копированию всех файлов проекта в другой каталог. Это может занять несколько секунд или даже минут, в зависимости от размера проекта, тогда как в Git&rsquo;е это всегда происходит моментально. Также благодаря тому, что мы запоминаем предков для каждого коммита, поиск нужной базовой версии для слияния уже автоматически выполнен за нас, и в общем случае слияние делается легко. Эти особенности помогают поощрять разработчиков к частому созданию и использованию веток.</p><p>Давайте поймём, почему и вам стоит так делать.</p><h2 id=основы-ветвления-и-слияния class="relative group">Основы ветвления и слияния <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-%d0%b2%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f-%d0%b8-%d1%81%d0%bb%d0%b8%d1%8f%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h2><p>Давайте рассмотрим ветвление и слияние на простом примере с таким процессом работы, который вы могли бы использовать в настоящей разработке. Мы выполним следующие шаги:</p><ol><li>Поработаем над веб-сайтом.</li><li>Создадим ветку для работы над новой задачей.</li><li>Выполним некоторую работу на этой ветке.</li></ol><p>На этом этапе вам поступит звонок о том, что сейчас критична другая проблема, и её надо срочно решить. Мы сделаем следующее:</p><ol><li>Вернёмся на ветку для версии в производстве.</li><li>Создадим ветку для исправления ошибки.</li><li>После тестирования ветки с исправлением сольём её обратно и отправим в продакшн.</li><li>Вернёмся к своей исходной задаче и продолжим работать над ней.</li></ol><h3 id=основы-ветвления class="relative group">Основы ветвления <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-%d0%b2%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Для начала представим, что вы работаете над своим проектом и уже имеете пару коммитов.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0310-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-10. Короткая и простая история коммитов.</p></blockquote><p>Вы решили, что вы будете работать над проблемой №53 из системы отслеживания ошибок, используемой вашей компанией. Разумеется, Git не привязан к какой-то определенной системе отслеживания ошибок. Так как проблема №53 является обособленной задачей, над которой вы собираетесь работать, мы создадим новую ветку и будем работать на ней. Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду <code>git checkout</code> с ключом <code>-b</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b iss53
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;iss53&#34;</span>
</span></span></code></pre></div><p>Это сокращение для:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch iss53
</span></span><span style=display:flex><span>$ git checkout iss53
</span></span></code></pre></div><p>Результат.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0311-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-11. Создание новой ветки / указателя.</p></blockquote><p>Во время работы над своим веб-сайтом вы делаете несколько коммитов. Эти действия сдвигают ветку <code>iss53</code> вперёд потому, что вы на неё перешли (то есть ваш HEAD указывает на неё:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vim index.html
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;added a new footer [issue 53]&#39;</span>
</span></span></code></pre></div><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0312-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-12. Ветка iss53 передвинулась вперёд во время работы.</p></blockquote><p>Теперь вы получаете звонок о том, что есть проблема с веб-сайтом, которую необходимо немедленно устранить. С Git&rsquo;ом вам нет нужды делать исправления для неё поверх тех изменений, которые вы уже сделали в <code>iss53</code>, и нет необходимости прикладывать много усилий для отмены этих изменений перед тем, как вы сможете начать работать над решением срочной проблемы. Всё, что вам нужно сделать, это перейти на ветку <code>master</code>.</p><p>Однако, прежде чем сделать это, учтите, что если в вашем рабочем каталоге или индексе имеются незафиксированные изменения, которые конфликтуют с веткой, на которую вы переходите, Git не позволит переключить ветки. Лучше всего при переключении веток иметь чистое рабочее состояние. Существует несколько способов добиться этого (а именно, прятанье (stash) работы и правка (amend) коммита), которые мы рассмотрим позже. А на данный момент представим, что все изменения были добавлены в коммит, и теперь вы можете переключиться обратно на ветку <code>master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>Switched to branch <span style=color:#e6db74>&#34;master&#34;</span>
</span></span></code></pre></div><p>Теперь рабочий каталог проекта находится точно в таком же состоянии, что и в момент начала работы над проблемой №53, так что вы можете сконцентрироваться на исправлении срочной проблемы. Очень важно запомнить: Git возвращает ваш рабочий каталог к снимку состояния того коммита, на который указывает ветка, на которую вы переходите. Он добавляет, удаляет и изменяет файлы автоматически, чтобы гарантировать, что состояние вашей рабочей копии идентично последнему коммиту на ветке.</p><p>Итак, вам надо срочно исправить ошибку. Давайте создадим для этого ветку, на которой вы будете работать:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b hotfix
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;hotfix&#34;</span>
</span></span><span style=display:flex><span>$ vim index.html
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;fixed the broken email address&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>hotfix<span style=color:#f92672>]</span>: created 3a0874c: <span style=color:#e6db74>&#34;fixed the broken email address&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>0</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>1</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0313-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-13. Ветка для решения срочной проблемы базируется на ветке master.</p></blockquote><p>Вы можете запустить тесты, убедиться, что решение работает, и слить (merge) изменения назад в ветку <code>master</code>, чтобы включить их в продукт. Это делается с помощью команды <code>git merge</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge hotfix
</span></span><span style=display:flex><span>Updating f42c576..3a0874c
</span></span><span style=display:flex><span>Fast forward
</span></span><span style=display:flex><span> README |    <span style=color:#ae81ff>1</span> -
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>0</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>1</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Наверное, вы заметили фразу &ldquo;Fast forward&rdquo; в этом слиянии. Так как ветка, которую мы слили, указывала на коммит, являющийся прямым родителем коммита, на котором мы сейчас находимся, Git просто сдвинул её указатель вперёд. Иными словами, когда вы пытаетесь слить один коммит с другим таким, которого можно достигнуть, проследовав по истории первого коммита, Git поступает проще, перемещая указатель вперёд, так как нет расходящихся изменений, которые нужно было бы сливать воедино. Это называется &ldquo;перемотка&rdquo; (fast forward).</p><p>Ваши изменения теперь в снимке состояния коммита, на который указывает ветка <code>master</code>, и вы можете включить изменения в продукт.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0314-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-14. После слияния ветка master указывает туда же, куда и ветка hotfix.</p></blockquote><p>После того как очень важная проблема решена, вы готовы вернуться обратно к тому, над чем вы работали перед тем, как вас прервали. Однако, сначала удалите ветку <code>hotfix</code>, так как она больше не нужна — ветка <code>master</code> уже указывает на то же место. Вы можете удалить ветку с помощью опции <code>-d</code> к <code>git branch</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -d hotfix
</span></span><span style=display:flex><span>Deleted branch hotfix <span style=color:#f92672>(</span>3a0874c<span style=color:#f92672>)</span>.
</span></span></code></pre></div><p>Теперь вы можете вернуться обратно к рабочей ветке для проблемы №53 и продолжить работать над ней:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout iss53
</span></span><span style=display:flex><span>Switched to branch <span style=color:#e6db74>&#34;iss53&#34;</span>
</span></span><span style=display:flex><span>$ vim index.html
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;finished the new footer [issue 53]&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>iss53<span style=color:#f92672>]</span>: created ad82d7a: <span style=color:#e6db74>&#34;finished the new footer [issue 53]&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0315-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-15. Ветка iss53 может двигаться вперёд независимо.</p></blockquote><p>Стоит напомнить, что работа, сделанная на ветке <code>hotfix</code>, не включена в файлы на ветке <code>iss53</code>. Если вам это необходимо, вы можете слить ветку <code>master</code> в ветку <code>iss53</code> посредством команды <code>git merge master</code>. Или же вы можете подождать с интеграцией изменений до тех пор, пока не решите включить изменения на <code>iss53</code> в продуктовую ветку <code>master</code>.</p><h3 id=основы-слияния class="relative group">Основы слияния <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-%d1%81%d0%bb%d0%b8%d1%8f%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Допустим, вы разобрались с проблемой №53 и готовы объединить эту ветку и свой <code>master</code>. Чтобы сделать это, мы сольём ветку <code>iss53</code> в ветку <code>master</code> точно так же, как мы делали это ранее с веткой <code>hotfix</code>. Всё, что вам нужно сделать, — перейти на ту ветку, в которую вы хотите слить свои изменения, и выполнить команду <code>git merge</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge iss53
</span></span><span style=display:flex><span>Merge made by recursive.
</span></span><span style=display:flex><span> README |    <span style=color:#ae81ff>1</span> +
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span> files changed, <span style=color:#ae81ff>1</span> insertions<span style=color:#f92672>(</span>+<span style=color:#f92672>)</span>, <span style=color:#ae81ff>0</span> deletions<span style=color:#f92672>(</span>-<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Это слияние немного отличается от слияния, сделанного ранее для ветки <code>hotfix</code>. В данном случае история разработки разделилась в некоторой точке. Так как коммит на той ветке, на которой вы находитесь, не является прямым предком для ветки, которую вы сливаете, Git&rsquo;у придётся проделать кое-какую работу. В этом случае Git делает простое трёхходовое слияние, используя при этом те два снимка состояния репозитория, на которые указывают вершины веток, и общий для этих двух веток снимок-прародитель. На рисунке выделены три снимка состояния, которые Git будет использовать для слияния в данном случае.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0316-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-16. Git автоматически определяет наилучшего общего предка для слияния веток.</p></blockquote><p>Вместо того чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый снимок состояния, который является результатом трёхходового слияния, и автоматически создаёт новый коммит, который указывает на этот новый снимок состояния. Такой коммит называют коммит-слияние, так как он является особенным из-за того, что имеет больше одного предка.</p><p>Стоит отметить, что Git сам определяет наилучшего общего предка для слияния веток; в CVS или Subversion (версии ранее 1.5) этого не происходит. Разработчик должен сам указать основу для слияния. Это делает слияние в Git&rsquo;е гораздо более простым занятием, чем в других системах.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0317-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-17. Git автоматически создаёт новый коммит, содержащий результаты слияния.</p></blockquote><p>Теперь, когда вы осуществили слияние ваших наработок, ветка <code>iss53</code> вам больше не нужна. Можете удалить её и затем вручную закрыть карточку (ticket) в своей системе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -d iss53
</span></span></code></pre></div><h3 id=основы-конфликтов-при-слиянии class="relative group">Основы конфликтов при слиянии <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-%d0%ba%d0%be%d0%bd%d1%84%d0%bb%d0%b8%d0%ba%d1%82%d0%be%d0%b2-%d0%bf%d1%80%d0%b8-%d1%81%d0%bb%d0%b8%d1%8f%d0%bd%d0%b8%d0%b8 aria-label=Якорь>#</a></span></h3><p>Иногда процесс слияния не идёт гладко. Если вы изменили одну и ту же часть файла по-разному в двух ветках, которые собираетесь слить, Git не сможет сделать это чисто. Если ваше решение проблемы №53 изменяет ту же часть файла, что и <code>hotfix</code>, вы получите конфликт слияния, и выглядеть он будет примерно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git merge iss53
</span></span><span style=display:flex><span>Auto-merging index.html
</span></span><span style=display:flex><span>CONFLICT <span style=color:#f92672>(</span>content<span style=color:#f92672>)</span>: Merge conflict in index.html
</span></span><span style=display:flex><span>Automatic merge failed; fix conflicts and <span style=color:#66d9ef>then</span> commit the result.
</span></span></code></pre></div><p>Git не создал новый коммит для слияния. Он приостановил этот процесс до тех пор, пока вы не разрешите конфликт. Если вы хотите посмотреть, какие файлы не прошли слияние (на любом этапе после возникновения конфликта), выполните команду <code>git status</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>master*<span style=color:#f92672>]</span>$ git status
</span></span><span style=display:flex><span>index.html: needs merge
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	unmerged:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Всё, что имеет отношение к конфликту слияния и что не было разрешено, отмечено как unmerged. Git добавляет стандартные маркеры к файлам, которые имеют конфликт, так что вы можете открыть их вручную и разрешить эти конфликты. Ваш файл содержит секцию, которая выглядит примерно так:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD:index.html
</span></span><span style=display:flex><span>&lt;div id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;footer&#34;</span>&gt;contact : email.support@github.com&lt;/div&gt;
</span></span><span style=display:flex><span><span style=color:#f92672>=======</span>
</span></span><span style=display:flex><span>&lt;div id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;footer&#34;</span>&gt;
</span></span><span style=display:flex><span>  please contact us at support@github.com
</span></span><span style=display:flex><span>&lt;/div&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html
</span></span></code></pre></div><p>В верхней части блока (всё что выше <code>=======</code>) это версия из HEAD (вашей ветки master, так как именно на неё вы перешли перед выполнением команды merge), всё, что находится в нижней части — версия в <code>iss53</code>. Чтобы разрешить конфликт, вы должны либо выбрать одну из этих частей, либо как-то объединить содержимое по своему усмотрению. Например, вы можете разрешить этот конфликт заменой всего блока, показанного выше, следующим блоком:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&lt;div id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;footer&#34;</span>&gt;
</span></span><span style=display:flex><span>  please contact us at email.support@github.com
</span></span><span style=display:flex><span>&lt;/div&gt;
</span></span></code></pre></div><p>Это решение содержит понемногу из каждой части, и я полностью удалил строки <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> и <code>>>>>>>></code>. После того как вы разобрались с каждой из таких секций в каждом из конфликтных файлов, выполните <code>git add</code> для каждого конфликтного файла. Индексирование будет означать для Git&rsquo;а, что все конфликты в файле теперь разрешены.
Если вы хотите использовать графические инструменты для разрешения конфликтов, можете выполнить команду <code>git mergetool</code>, которая запустит соответствующий графический инструмент и покажет конфликтные ситуации:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git mergetool
</span></span><span style=display:flex><span>merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
</span></span><span style=display:flex><span>Merging the files: index.html
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Normal merge conflict <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;index.html&#39;</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span>local<span style=color:#f92672>}</span>: modified
</span></span><span style=display:flex><span>  <span style=color:#f92672>{</span>remote<span style=color:#f92672>}</span>: modified
</span></span><span style=display:flex><span>Hit <span style=color:#66d9ef>return</span> to start merge resolution tool <span style=color:#f92672>(</span>opendiff<span style=color:#f92672>)</span>:
</span></span></code></pre></div><p>Если вы хотите использовать другой инструмент для слияния, нежели выбираемый по умолчанию (Git выбрал <code>opendiff</code> для меня, так как я выполнил команду на Mac&rsquo;е). Вы можете увидеть все поддерживаемые инструменты, указанные выше после “merge tool candidates”. Укажите название предпочтительного для вас инструмента. В рамках следующих лекций мы обсудим, как изменить это значение по умолчанию для вашего окружения.</p><p>После того как вы выйдете из инструмента для выполнения слияния, Git спросит вас, было ли оно успешным. Если вы отвечаете, что да — файл индексируется (добавляется в область для коммита), чтобы дать вам понять, что конфликт разрешён.</p><p>Можете выполнить <code>git status</code> ещё раз, чтобы убедиться, что все конфликты были разрешены:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#	modified:   index.html</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span></code></pre></div><p>Если вы довольны тем, что получили, и удостоверились, что всё, имевшее конфликты, было проиндексировано, можете выполнить <code>git commit</code> для завершения слияния. По умолчанию сообщение коммита будет выглядеть примерно так:</p><pre tabindex=0><code>Merge branch &#39;iss53&#39;

Conflicts:
  index.html
#
# It looks like you may be committing a MERGE.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
#
</code></pre><p>Вы можете дополнить это сообщение информацией о том, как вы разрешили конфликт, если считаете, что это может быть полезно для других в будущем. Например, можете указать почему вы сделали то, что сделали, если это не очевидно, конечно.</p><h2 id=управление-ветками class="relative group">Управление ветками <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b0%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h2><p>Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.</p><p>Команда <code>git branch</code> делает несколько больше, чем просто создаёт и удаляет ветки. Если вы выполните её без аргументов, то получите простой список имеющихся у вас веток:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch
</span></span><span style=display:flex><span>  iss53
</span></span><span style=display:flex><span>* master
</span></span><span style=display:flex><span>  testing
</span></span></code></pre></div><p>Обратите внимание на символ <code>*</code>, стоящий перед веткой <code>master</code>: он указывает на ветку, на которой вы находитесь в настоящий момент. Это означает, что если вы сейчас выполните коммит, ветка <code>master</code> переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду <code>git branch -v</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -v
</span></span><span style=display:flex><span>  iss53   93b412c fix javascript issue
</span></span><span style=display:flex><span>* master  7a98805 Merge branch <span style=color:#e6db74>&#39;iss53&#39;</span>
</span></span><span style=display:flex><span>  testing 782fd34 add scott to the author list in the readmes
</span></span></code></pre></div><p>Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в Git&rsquo;е есть опции <code>--merged</code> и <code>--no-merged</code>. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду <code>git branch --merged</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch --merged
</span></span><span style=display:flex><span>  iss53
</span></span><span style=display:flex><span>* master
</span></span></code></pre></div><p>Из-за того что мы ранее слили <code>iss53</code>, мы видим её в этом списке. Те ветки из этого списка, перед которыми нет символа <code>*</code>, можно смело удалять командой <code>git branch -d</code>; вы уже включили наработки из этих веток в другую ветку, так что вы ничего не потеряете.</p><p>Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду <code>git branch --no-merged</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch --no-merged
</span></span><span style=display:flex><span>  testing
</span></span></code></pre></div><p>Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой <code>git branch -d</code> не увенчается успехом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -d testing
</span></span><span style=display:flex><span>error: The branch <span style=color:#e6db74>&#39;testing&#39;</span> is not an ancestor of your current HEAD.
</span></span><span style=display:flex><span>If you are sure you want to delete it, run <span style=color:#e6db74>&#39;git branch -D testing&#39;</span>.
</span></span></code></pre></div><p>Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции <code>-D</code>, как указано в подсказке.</p><h2 id=приёмы-работы-с-ветками class="relative group">Приёмы работы с ветками <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d1%80%d0%b8%d1%91%d0%bc%d1%8b-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b-%d1%81-%d0%b2%d0%b5%d1%82%d0%ba%d0%b0%d0%bc%d0%b8 aria-label=Якорь>#</a></span></h2><p>Теперь, когда вы познакомились с основами ветвления и слияния, что вам делать с ветками дальше? В этом разделе мы рассмотрим некоторые стандартные приёмы работы, которые становятся возможными благодаря лёгкости осуществления ветвления. И вы сможете выбрать, включить ли вам какие-то из них в свой цикл разработки.</p><h3 id=долгоживущие-ветки class="relative group">Долгоживущие ветки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b4%d0%be%d0%bb%d0%b3%d0%be%d0%b6%d0%b8%d0%b2%d1%83%d1%89%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Так как Git использует простое трёхходовое слияние, периодически сливать одну ветку с другой на протяжении большого промежутка времени достаточно просто. Это значит, вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать их одну в другую.</p><p>Многие разработчики Git&rsquo;а придерживаются такого подхода, при котором ветка <code>master</code> содержит исключительно стабильный код — единственный выпускаемый код. Для разработки и тестирования используется параллельная ветка, называемая <code>develop</code> или <code>next</code>, она может не быть стабильной постоянно, но в стабильные моменты её можно слить в <code>master</code>. Эта ветка используется для объединения завершённых задач из тематических веток (временных веток наподобие <code>iss53</code>), чтобы удостовериться, что эти изменения проходят все тесты и не вызывают ошибок.</p><p>В действительности же, мы говорим об указателях, передвигающихся вверх по линии коммитов, которые вы делаете. Стабильные ветки далеко внизу линии вашей истории коммитов, наиболее свежие ветки находятся ближе к верхушке этой линии.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0318-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-18. Более стабильные ветки, как правило, находятся дальше в истории коммитов.</p></blockquote><p>В общем, об этом проще думать как о силосных башнях, где набор коммитов переходит в более стабильную башню только тогда, когда он полностью протестирован.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0319-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-19. Может быть полезным думать о ветках как о силосных башнях.</p></blockquote><p>Вы можете применять эту идею для нескольких разных уровней стабильности. Некоторые большие проекты также имеют ветку <code>proposed</code> или <code>pu</code> (proposed updates — предлагаемые изменения), которые включают в себя ветки, не готовые для перехода в ветку <code>next</code> или <code>master</code>. Идея такова, что ваши ветки находятся на разных уровнях стабильности; когда они достигают более высокого уровня стабильности, они сливаются с веткой, стоящей на более высоком уровне.
Опять-таки, иметь долгоживущие ветки не обязательно, но зачастую это полезно, особенно когда вы имеете дело с очень большими и сложными проектами.</p><h3 id=тематические-ветки class="relative group">Тематические ветки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%82%d0%b5%d0%bc%d0%b0%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h3><p>Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка — недолговечная ветка, которую вы создаёте и используете для работы над некоторой отдельной функциональностью или для вспомогательной работы. Это то, чего вы, вероятно, никогда не делали с системами контроля версий раньше, так как создание и слияние веток обычно слишком затратно. Но в Git&rsquo;е принято создавать ветки, работать над ними, сливать и удалять их по несколько раз в день.</p><p>Мы видели подобное в последнем разделе, где вы создавали ветки <code>iss53</code> и <code>hotfix</code>. Вы сделали всего несколько коммитов на этих ветках и удалили их сразу же после слияния с основной веткой. Такая техника позволяет быстро и полноценно переключать контекст. Ибо когда все изменения разбиты по веткам и определённым темам, намного проще понять, что было сделано, во время проверки и просмотра кода. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их в основную ветку, независимо от порядка, в котором их создавали или работали над ними.</p><p>Рассмотрим пример, когда при выполнении некоторой работы в ветке <code>master</code>, делается новая ветка для решения некой проблемы (<code>iss91</code>), выполняется немного работы на ней, от неё ответвляется ещё одна ветка для другого пути решения той же задачи (<code>iss91v2</code>), потом осуществляется переход назад на основную ветку (<code>master</code>), и некоторое время работа ведётся на ней, затем делается ответвление от неё для выполнения чего-то, в чём вы не уверены, что это хорошая идея (ветка <code>dumbidea</code>). Ваша история коммитов будет выглядеть примерно так как на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0320-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-20. История коммитов с несколькими тематическими ветками.</p></blockquote><p>Теперь представим, вы решили, что вам больше нравится второе решение для вашей задачи (<code>iss91v2</code>); и вы показываете ветку <code>dumbidea</code> вашим коллегам и оказывается, что она просто гениальна. Так что вы можете выбросить оригинальную ветку <code>iss91</code> (теряя при этом коммиты C5 и C6) и слить две другие. Тогда ваша история будет выглядеть как на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0321-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-21. Ваша история после слияния dumbidea и iss91v2.</p></blockquote><p>Важно запомнить, что когда вы выполняете все эти действия, ветки являются полностью локальными. Когда вы выполняете ветвление и слияние, всё происходит только в вашем репозитории — связь с сервером не осуществляется.</p><h2 id=удалённые-ветки class="relative group">Удалённые ветки <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d1%8b%d0%b5-%d0%b2%d0%b5%d1%82%d0%ba%d0%b8 aria-label=Якорь>#</a></span></h2><p>Удалённые ветки — это ссылки на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.</p><p>Они выглядят как <code>(имя удал. репоз.)/(ветка)</code>. Например, если вы хотите посмотреть, как выглядела ветка <code>master</code> на сервере <code>origin</code> во время последнего соединения с ним, проверьте ветку <code>origin/master</code>. Если вы с партнёром работали над одной проблемой, и он выложил ветку <code>iss53</code>, у вас может быть своя локальная ветка <code>iss53</code>; но та ветка на сервере будет указывать на коммит в <code>origin/iss53</code>.</p><p>Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас в сети есть свой Git-сервер на <code>git.ourcompany.com</code>. Если вы с него что-то склонируете (clone), Git автоматически назовёт его <code>origin</code>, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка <code>master</code>, и назовёт его локально <code>origin/master</code> (но вы не можете его двигать). Git также сделает вам вашу собственную ветку <code>master</code>, которая будет начинаться там же, где и ветка <code>master</code> в origin, так что вам будет с чем работать.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0322-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-22. Клонирование Git-проекта даёт вам собственную ветку master и origin/master, указывающий на ветку master в origin.</p></blockquote><p>Если вы сделаете что-то в своей локальной ветке <code>master</code>, а тем временем кто-то ещё отправит (push) изменения на <code>git.ourcompany.com</code> и обновит там ветку <code>master</code>, то ваши истории продолжатся по-разному. Ещё, до тех пор, пока вы не свяжетесь с сервером origin, ваш указатель <code>origin/master</code> не будет сдвигаться.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0323-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-23. При выполнении локальной работы и отправке кем-то изменений на удалённый сервер каждая история продолжается по-разному.</p></blockquote><p>Для синхронизации вашей работы выполняется команда <code>git fetch origin</code>. Эта команда ищет, какому серверу соответствует origin (в нашем случае это <code>git.ourcompany.com</code>); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель <code>origin/master</code> на новую позицию.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0324-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-24. Команда git fetch обновляет ваши удалённые ссылки.</p></blockquote><p>Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на <code>git.team1.ourcompany.com</code>. Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды <code>git remote add</code> так же, как было описано ранее. Дайте этому удалённому серверу имя <code>teamone</code>, которое будет сокращением для полного URL.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0325-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-25. Добавление дополнительного удалённого сервера.</p></blockquote><p>Теперь можете выполнить <code>git fetch teamone</code>, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на сервере <code>origin</code>, Git не получает никаких данных, но выставляет удалённую ветку с именем <code>teamone/master</code>, которая указывает на тот же коммит, что и ветка <code>master</code> на сервере <code>teamone</code>.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0326-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-26. У вас появилась локальная ссылка на ветку master на teamone-е.</p></blockquote><h3 id=отправка-изменений class="relative group">Отправка изменений <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d0%bf%d1%80%d0%b0%d0%b2%d0%ba%d0%b0-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d0%b9 aria-label=Якорь>#</a></span></h3><p>Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться. Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.</p><p>Если у вас есть ветка <code>serverfix</code>, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку. Выполните <code>git push (удал. сервер) (ветка)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin serverfix
</span></span><span style=display:flex><span>Counting objects: 20, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Compressing objects: 100% <span style=color:#f92672>(</span>14/14<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Writing objects: 100% <span style=color:#f92672>(</span>15/15<span style=color:#f92672>)</span>, 1.74 KiB, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>Total <span style=color:#ae81ff>15</span> <span style=color:#f92672>(</span>delta 5<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>To git@github.com:schacon/simplegit.git
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      serverfix -&gt; serverfix
</span></span></code></pre></div><p>Это в некотором роде сокращение. Git автоматически разворачивает имя ветки <code>serverfix</code> до <code>refs/heads/serverfix:refs/heads/serverfix</code>, что означает “возьми мою локальную ветку serverfix и обнови из неё удалённую ветку serverfix”. Мы подробно обсудим часть с <code>refs/heads/</code> в рамках следующих лекций, но обычно её можно опустить. Вы также можете выполнить <code>git push origin serverfix:serverfix</code> — произойдёт то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”. Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем. Если вы не хотите, чтобы ветка называлась <code>serverfix</code> на удалённом сервере, то вместо предыдущей команды выполните <code>git push origin serverfix:awesomebranch</code>. Так ваша локальная ветка <code>serverfix</code> отправится в ветку <code>awesomebranch</code> удалённого проекта.</p><p>В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает <code>serverfix</code> на сервере, как удалённую ветку <code>origin/serverfix</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git fetch origin
</span></span><span style=display:flex><span>remote: Counting objects: 20, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Compressing objects: 100% <span style=color:#f92672>(</span>14/14<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>remote: Total <span style=color:#ae81ff>15</span> <span style=color:#f92672>(</span>delta 5<span style=color:#f92672>)</span>, reused <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>delta 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Unpacking objects: 100% <span style=color:#f92672>(</span>15/15<span style=color:#f92672>)</span>, <span style=color:#66d9ef>done</span>.
</span></span><span style=display:flex><span>From git@github.com:schacon/simplegit
</span></span><span style=display:flex><span> * <span style=color:#f92672>[</span>new branch<span style=color:#f92672>]</span>      serverfix    -&gt; origin/serverfix
</span></span></code></pre></div><p>Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку <code>serverfix</code> — только указатель <code>origin/serverfix</code>, который вы не можете менять.</p><p>Чтобы слить эти наработки в свою текущую рабочую ветку, выполните <code>git merge origin/serverfix</code>. Если вам нужна своя собственная ветка <code>serverfix</code>, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b serverfix origin/serverfix
</span></span><span style=display:flex><span>Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;serverfix&#34;</span>
</span></span></code></pre></div><p>Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и <code>origin/serverfix</code>.</p><h3 id=отслеживание-веток class="relative group">Отслеживание веток <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%82%d1%81%d0%bb%d0%b5%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%be%d0%ba aria-label=Якорь>#</a></span></h3><p>Получение локальной ветки с помощью <code>git checkout</code> из удалённой ветки автоматически создаёт то, что называется <em>отслеживаемой веткой</em>. Отслеживаемые ветки — это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на отслеживаемой ветке, вы наберёте <code>git push</code>, Git уже будет знать, на какой сервер и в какую ветку отправлять изменения. Аналогично выполнение <code>git pull</code> на одной из таких веток сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.</p><p>При клонировании репозитория, как правило, автоматически создаётся ветка <code>master</code>, которая отслеживает <code>origin/master</code>, поэтому <code>git push</code> и <code>git pull</code> работают для этой ветки &ldquo;из коробки&rdquo; и не требуют дополнительных аргументов. Однако, вы можете настроить отслеживание и других веток удалённого репозитория. Простой пример, как это сделать, вы увидели только что — <code>git checkout -b [ветка] [удал. сервер]/[ветка]</code>. Если вы используете Git версии 1.6.2 или более позднюю, можете также воспользоваться сокращением <code>--track</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout --track origin/serverfix
</span></span><span style=display:flex><span>Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;serverfix&#34;</span>
</span></span></code></pre></div><p>Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout -b sf origin/serverfix
</span></span><span style=display:flex><span>Branch sf set up to track remote branch refs/remotes/origin/serverfix.
</span></span><span style=display:flex><span>Switched to a new branch <span style=color:#e6db74>&#34;sf&#34;</span>
</span></span></code></pre></div><p>Теперь ваша локальная ветка sf будет автоматически отправлять (push) и получать (pull) изменения из origin/serverfix.</p><h3 id=удаление-веток-на-удалённом-сервере class="relative group">Удаление веток на удалённом сервере <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b2%d0%b5%d1%82%d0%be%d0%ba-%d0%bd%d0%b0-%d1%83%d0%b4%d0%b0%d0%bb%d1%91%d0%bd%d0%bd%d0%be%d0%bc-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b5 aria-label=Якорь>#</a></span></h3><p>Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <code>master</code> на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код). Вы можете удалить ветку на удалённом сервере, используя несколько бестолковый синтаксис <code>git push [удал. сервер] :[ветка]</code>. Чтобы удалить ветку <code>serverfix</code> на сервере, выполните следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git push origin :serverfix
</span></span><span style=display:flex><span>To git@github.com:schacon/simplegit.git
</span></span><span style=display:flex><span> - <span style=color:#f92672>[</span>deleted<span style=color:#f92672>]</span>         serverfix
</span></span></code></pre></div><p>Хлоп. Нет больше ветки на вашем сервере. Можно запомнить эту команду вернувшись к синтаксису <code>git push [удал. сервер] [лок. ветка]:[удал. ветка]</code>, который мы рассматривали немного раньше. Опуская часть <code>[лок. ветка]</code>, вы, по сути, говорите “возьми ничто в моём репозитории и сделай так, чтобы в <code>[удал. ветка]</code> было то же самое”.</p><h2 id=перемещение class="relative group">Перемещение <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d0%b5 aria-label=Якорь>#</a></span></h2><p>В Git&rsquo;е есть два способа включить изменения из одной ветки в другую: <code>merge</code> (слияние) и <code>rebase</code> (перемещение). В этом разделе вы узнаете, что такое перемещение, как его осуществлять, почему это удивительный инструмент и в каких случаях вам не следует его использовать.</p><h3 id=основы-перемещения class="relative group">Основы перемещения <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Если мы вернёмся назад к одному из ранних примеров из раздела про слияние, увидим, что мы разделили свою работу на два направления и сделали коммиты на двух разных ветках.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0327-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-27. Впервые разделенная история коммитов.</p></blockquote><p>Наиболее простое решение для объединения веток, как мы уже выяснили, команда <code>merge</code>. Эта команда выполняет трёхходовое слияние между двумя последними снимками состояний из веток (C3 и C4) и последним общим предком этих двух веток (C2), создавая новый снимок состояния (и коммит), как показано на рисунке 3-28.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0328-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-28. Слияние ветки для объединения разделившейся истории разработки.</p></blockquote><p>Однако, есть и другой путь: вы можете взять изменения, представленные в C3, и применить их поверх C4. В Git&rsquo;е это называется <em>перемещение</em> (rebasing). При помощи команды <code>rebase</code> вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.</p><p>Для этого примера надо выполнить следующее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout experiment
</span></span><span style=display:flex><span>$ git rebase master
</span></span><span style=display:flex><span>First, rewinding head to replay your work on top of it...
</span></span><span style=display:flex><span>Applying: added staged command
</span></span></code></pre></div><p>Перемещение работает следующим образом: находится общий предок для двух веток (на которой вы находитесь сейчас и на которую вы выполняете перемещение); для каждого из коммитов в текущей ветке берётся его дельта и сохраняется во временный файл; текущая ветка устанавливается на тот же коммит, что и ветка, на которую выполняется перемещение; и, наконец, одно за другим применяются все изменения. Рисунок иллюстрирует этот процесс.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0329-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-29. Перемещение изменений, сделанных в C3, на C4.</p></blockquote><p>На этом этапе можно переключиться на ветку <code>master</code> и выполнить слияние-перемотку (fast-forward merge).</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0330-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-30. Перемотка ветки master.</p></blockquote><p>Теперь снимок состояния, на который указывает C3&rsquo;, точно такой же, как тот, на который указывал C5 в примере со слиянием. Нет никакой разницы в конечном результате объединения, но перемещение выполняется для того, чтобы история была более аккуратной. Если вы посмотрите лог для перемещённой ветки, то увидите, что он выглядит как линейная история работы: выходит, что вся работа выполнялась последовательно, когда в действительности она выполнялась параллельно.</p><p>Часто вы будете делать это, чтобы удостовериться, что ваши коммиты правильно применяются для удалённых веток — возможно для проекта, владельцем которого вы не являетесь, но в который вы хотите внести свой вклад. В этом случае вы будете выполнять работу в какой-нибудь ветке, а затем, когда будете готовы внести свои изменения в основной проект, выполните перемещение вашей работы на <code>origin/master</code>. Таким образом, владельцу проекта не придётся делать никаких действий по объединению — просто перемотка (fast-forward) или чистое применение патчей.</p><p>Заметьте, что снимок состояния, на который указывает последний коммит, который у вас получился, является ли этот коммит последним перемещённым коммитом (для случая выполнения перемещения) или итоговым коммитом слияния (для случая выполнения слияния), есть один и тот же снимок — разной будет только история. Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.</p><h3 id=более-интересные-перемещения class="relative group">Более интересные перемещения <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b1%d0%be%d0%bb%d0%b5%d0%b5-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d0%b5%d1%81%d0%bd%d1%8b%d0%b5-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Можно также сделать так, чтобы при перемещении воспроизведение коммитов начиналось не от той ветки, на которую делается перемещение. Возьмём, например, историю разработки: Вы создали тематическую ветку (<code>server</code>), чтобы добавить в проект некоторый функционал для серверной части, и сделали коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку <code>server</code> и сделали ещё несколько коммитов.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0331-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-31. История разработки с тематической веткой, ответвлённой от другой тематической ветки.</p></blockquote><p>Предположим, вы решили, что хотите внести свои изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части, пока они не будут полностью протестированы. Вы можете взять изменения из ветки <code>client</code>, которых нет в <code>server</code> (C8 и C9), и применить их на ветке <code>master</code> при помощи опции <code>--onto</code> команды <code>git rebase</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rebase --onto master server client
</span></span></code></pre></div><p>По сути, это указание “переключиться на ветку <code>client</code>, взять изменения от общего предка веток <code>client</code> и <code>server</code> и повторить их на <code>master</code>”. Это немного сложно; но результат, показанный на рисунке 3-32, довольно классный.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0332-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-32. Перемещение тематической ветки, ответвлённой от другой тематической ветки.</p></blockquote><p>Теперь вы можете выполнить перемотку (fast-forward) для ветки <code>master</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge client
</span></span></code></pre></div><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0333-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-33. Перемотка ветки master для добавления изменений из ветки client.</p></blockquote><p>Представим, что вы решили включить работу и из ветки <code>server</code> тоже. Вы можете выполнить перемещение ветки <code>server</code> на ветку <code>master</code> без предварительного переключения на эту ветку при помощи команды <code>git rebase [осн. ветка] [тем. ветка]</code> — которая устанавливает тематическую ветку (в данном случае <code>server</code>) как текущую и применяет её изменения на основной ветке (<code>master</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git rebase master server
</span></span></code></pre></div><p>Эта команда применит изменения из вашей работы над веткой <code>server</code> на вершину ветки <code>master</code>, как показано на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0334-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-34. Перемещение ветки server на вершину ветки master.</p></blockquote><p>Затем вы можете выполнить перемотку основной ветки (<code>master</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge server
</span></span></code></pre></div><p>Вы можете удалить ветки <code>client</code> и <code>server</code>, так как вся работа из них включена в основную линию разработки и они вам больше не нужны. При этом полная история вашего рабочего процесса выглядит как на рисунке:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git branch -d client
</span></span><span style=display:flex><span>$ git branch -d server
</span></span></code></pre></div><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0335-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-35. Финальная история коммитов.</p></blockquote><h3 id=возможные-риски-перемещения class="relative group">Возможные риски перемещения <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d1%8b%d0%b5-%d1%80%d0%b8%d1%81%d0%ba%d0%b8-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d1%8f aria-label=Якорь>#</a></span></h3><p>Всё бы хорошо, но кое-что омрачает всю прелесть использования перемещения. Это выражается одной строчкой:</p><p><strong>Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.</strong></p><p>Если вы будете следовать этому указанию, всё будет хорошо. Если нет — люди возненавидят вас, вас будут презирать ваши друзья и семья.</p><p>Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, которые похожи на старые, но являются другими. Если вы выкладываете (push) свои коммиты куда-нибудь, и другие забирают (pull) их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой <code>git rebase</code> и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. В итоге вы получите путаницу, когда в очередной раз попытаетесь включить их работу в свою.</p><p>Давайте рассмотрим пример того, как перемещение публично доступных наработок может вызвать проблемы. Представьте себе, что вы склонировали себе репозиторий с центрального сервера и поработали в нём. И ваша история коммитов выглядит как на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0336-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-36. Клонирование репозитория и выполнение в нём какой-то работы.</p></blockquote><p>Теперь кто-то ещё выполняет работу, причём работа включает в себя и слияние, и отправляет свои изменения на центральный сервер. Вы извлекаете их и сливаете новую удалённую ветку со своей работой. Тогда ваша история выглядит как на рисунке.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0337-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-37. Извлечение коммитов и слияние их со своей работой.</p></blockquote><p>Далее, человек, выложивший коммит, содержащий слияние, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет <code>git push --force</code>, чтобы переписать историю на сервере. Затем вы извлекаете изменения с этого сервера, включая и новые коммиты.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0338-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-38. Кто-то выложил перемещённые коммиты, отменяя коммиты, на которых вы основывали свою работу.</p></blockquote><p>На этом этапе вы вынуждены объединить эту работу со своей снова, даже если вы уже сделали это ранее. Перемещение изменяет у этих коммитов SHA-1 хеши, так что для Git&rsquo;а они выглядят как новые коммиты, тогда как на самом деле вы уже располагаете наработками из C4 в своей истории.</p><p><figure><img src=https://raw.github.com/progit/progit/master/figures/18333fig0339-tn.png alt class="mx-auto my-0 rounded-md"></figure></p><blockquote><p>Рисунок 3-39. Вы снова выполняете слияние для той же самой работы в новый коммит слияния.</p></blockquote><p>Вы вынуждены объединить эту работу со своей на каком-либо этапе, чтобы иметь возможность продолжать работать с другими разработчиками в будущем. После того, как вы сделаете это, ваша история коммитов будет содержать оба коммита — C4 и C4&rsquo;, которые имеют разные SHA-1 хеши, но представляют собой одинаковые изменения и имеют одинаковые сообщения. Если вы выполните команду <code>git log</code>, когда ваша история выглядит таким образом, вы увидите два коммита, которые имеют одинакового автора и одни и те же сообщения. Это сбивает с толку. Более того, если вы отправите такую историю обратно на сервер, вы добавите все эти перемещенные коммиты в репозиторий центрального сервера, что может ещё больше запутать людей.</p><p>Если вы рассматриваете перемещение как возможность наведения порядка и работы с коммитами до того, как выложили их, и если вы перемещаете только коммиты, которые никогда не находились в публичном доступе — всё нормально. Если вы перемещаете коммиты, которые уже были представлены для общего доступа, и люди, возможно, основывали свою работу на этих коммитах, тогда вы можете получить наказание за разные неприятные проблемы.</p><h2 id=итоги-1 class="relative group">Итоги <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%d0%b8%d1%82%d0%be%d0%b3%d0%b8-1 aria-label=Якорь>#</a></span></h2><p>Мы рассмотрели основы ветвления и слияния в Git&rsquo;е. Теперь вы должны чувствовать себя уверенно при создании и переходе на новые ветки, переключении между ветками и слиянии локальных веток. А также вы должны уметь делиться своими ветками, выкладывая их на общий сервер, работать с другими людьми над общими ветками и перемещать свои ветки, пока они не представлены для общего доступа.</p></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=400 height=400 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt="Андрей Куманяев" loading=lazy decoding=async src=https://zzet.org/img/author.jpeg></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Автор</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Андрей Куманяев</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://twitter.com/username target=_blank aria-label=Twitter rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/zzet target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://x.com/zzetorg target=_blank aria-label=X rel="me noopener noreferrer"></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.reddit.com/user/zzet/ target=_blank aria-label=Reddit rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.linkedin.com/in/andrey-kumanyaev/ target=_blank aria-label=Linkedin rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></span></a></div></div></div></div><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.facebook.com/sharer/sharer.php?u=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;quote=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Поделиться на Facebook" aria-label="Поделиться на Facebook" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://x.com/intent/tweet/?url=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;text=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Post on X" aria-label="Post on X" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://tootpick.org/#text=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Поделиться на Mastodon" aria-label="Поделиться на Mastodon" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://reddit.com/submit/?url=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;resubmit=true&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Опубликовать на Reddit" aria-label="Опубликовать на Reddit" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;title=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Поделиться на LinkedIn" aria-label="Поделиться на LinkedIn" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;subject=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Послать через email" aria-label="Послать через email" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.threads.net/intent/post?text=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/%20Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Post on Threads" aria-label="Post on Threads" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M331.5 235.7c2.2.9 4.2 1.9 6.3 2.8 29.2 14.1 50.6 35.2 61.8 61.4 15.7 36.5 17.2 95.8-30.3 143.2-36.2 36.2-80.3 52.5-142.6 53h-.3c-70.2-.5-124.1-24.1-160.4-70.2-32.3-41-48.9-98.1-49.5-169.6V256v-.2C17 184.3 33.6 127.2 65.9 86.2 102.2 40.1 156.2 16.5 226.4 16h.3c70.3.5 124.9 24 162.3 69.9 18.4 22.7 32 50 40.6 81.7l-40.4 10.8c-7.1-25.8-17.8-47.8-32.2-65.4-29.2-35.8-73-54.2-130.5-54.6-57 .5-100.1 18.8-128.2 54.4C72.1 146.1 58.5 194.3 58 256c.5 61.7 14.1 109.9 40.3 143.3 28 35.6 71.2 53.9 128.2 54.4 51.4-.4 85.4-12.6 113.7-40.9 32.3-32.2 31.7-71.8 21.4-95.9-6.1-14.2-17.1-26-31.9-34.9-3.7 26.9-11.8 48.3-24.7 64.8-17.1 21.8-41.4 33.6-72.7 35.3-23.6 1.3-46.3-4.4-63.9-16-20.8-13.8-33-34.8-34.3-59.3-2.5-48.3 35.7-83 95.2-86.4 21.1-1.2 40.9-.3 59.2 2.8-2.4-14.8-7.3-26.6-14.6-35.2-10-11.7-25.6-17.7-46.2-17.8H227c-16.6.0-39 4.6-53.3 26.3l-34.4-23.6c19.2-29.1 50.3-45.1 87.8-45.1h.8c62.6.4 99.9 39.5 103.7 107.7l-.2.2zm-156 68.8c1.3 25.1 28.4 36.8 54.6 35.3 25.6-1.4 54.6-11.4 59.5-73.2-13.2-2.9-27.8-4.4-43.4-4.4-4.8.0-9.6.1-14.4.4-42.9 2.4-57.2 23.2-56.2 41.8l-.1.1z"/></svg>
</span></a><a class="m-1 inline-block min-w-[2.4rem] rounded bg-neutral-300 p-1 text-center text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://telegram.me/share/url?text=https://zzet.org/ru/archive/2014-03-07-lection-2-git-course-undev/&amp;url=Git.%20%d0%9f%d1%80%d0%be%d1%81%d1%82%d0%be%20Git.%20%d0%9b%d0%b5%d0%ba%d1%86%d0%b8%d1%8f%202.%20%d0%9e%d1%81%d0%bd%d0%be%d0%b2%d1%8b%20Git,%20%d0%92%d0%b5%d1%82%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5." title="Поделиться на Telegram" aria-label="Поделиться на Telegram" target=_blank rel="noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111.033 8 0 119.033.0 256S111.033 504 248 504 496 392.967 496 256 384.967 8 248 8zM362.952 176.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452.0 013.53 6.716A43.765 43.765.0 01362.952 176.66z"/></svg></span></a></section><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=https://zzet.org/ru/archive/2014-03-14-lection-3-git-course-undev/><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Git. Просто Git. Лекция 3. Инструменты Git.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time>
</span></span></a></span><span><a class="group flex text-right" href=https://zzet.org/ru/archive/2014-02-28-lection-1-git-course-undev/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Git. Просто Git. Лекция 1. Введение.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2014-02-09 00:00:00 +0000 UTC">9 февраля 2014 г.</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=Вверх title=Вверх>&uarr;</a></div><footer class="py-10 print:hidden"><nav class="pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="group mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a href=/ru/archive/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Архив</span></a></li></ul></nav><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2026
Андрей Куманяев</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Работает на <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer></div></body></html>